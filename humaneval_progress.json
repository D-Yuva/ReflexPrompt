{
  "start_time": 1761486679.200542,
  "current_time": 1761596928.03339,
  "elapsed_hours": 30.624675791131125,
  "completed_problems": [
    {
      "problem": "has_close_elements",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "# Manually recorded - PASSED",
          "tests_passed": 4,
          "total_tests": 4,
          "time": 0.0,
          "iterations_used": 1,
          "manual_entry": true
        }
      ],
      "num_passed": 1,
      "num_samples": 1,
      "manual_entry": true
    },
    {
      "problem": "separate_paren_groups",
      "samples": [
        {
          "sample_id": 1,
          "passed": false,
          "solution": "# Manually recorded - FAILED",
          "tests_passed": 0,
          "total_tests": 4,
          "time": 0.0,
          "iterations_used": 1,
          "manual_entry": true
        }
      ],
      "num_passed": 0,
      "num_samples": 1,
      "manual_entry": true
    },
    {
      "problem": "truncate_number",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "# Manually recorded - PASSED",
          "tests_passed": 4,
          "total_tests": 4,
          "time": 0.0,
          "iterations_used": 1,
          "manual_entry": true
        }
      ],
      "num_passed": 1,
      "num_samples": 1,
      "manual_entry": true
    },
    {
      "problem": "below_zero",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "# Manually recorded - PASSED",
          "tests_passed": 4,
          "total_tests": 4,
          "time": 0.0,
          "iterations_used": 1,
          "manual_entry": true
        }
      ],
      "num_passed": 1,
      "num_samples": 1,
      "manual_entry": true
    },
    {
      "problem": "mean_absolute_deviation",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "# Manually recorded - PASSED",
          "tests_passed": 4,
          "total_tests": 4,
          "time": 0.0,
          "iterations_used": 1,
          "manual_entry": true
        }
      ],
      "num_passed": 1,
      "num_samples": 1,
      "manual_entry": true
    },
    {
      "problem": "intersperse",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "# Manually recorded - PASSED",
          "tests_passed": 4,
          "total_tests": 4,
          "time": 0.0,
          "iterations_used": 1,
          "manual_entry": true
        }
      ],
      "num_passed": 1,
      "num_samples": 1,
      "manual_entry": true
    },
    {
      "problem": "parse_nested_parens",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "# Manually recorded - PASSED",
          "tests_passed": 4,
          "total_tests": 4,
          "time": 0.0,
          "iterations_used": 1,
          "manual_entry": true
        }
      ],
      "num_passed": 1,
      "num_samples": 1,
      "manual_entry": true
    },
    {
      "problem": "filter_by_substring",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "# Manually recorded - PASSED",
          "tests_passed": 4,
          "total_tests": 4,
          "time": 0.0,
          "iterations_used": 1,
          "manual_entry": true
        }
      ],
      "num_passed": 1,
      "num_samples": 1,
      "manual_entry": true
    },
    {
      "problem": "sum_product",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "# Manually recorded - PASSED",
          "tests_passed": 4,
          "total_tests": 4,
          "time": 0.0,
          "iterations_used": 1,
          "manual_entry": true
        }
      ],
      "num_passed": 1,
      "num_samples": 1,
      "manual_entry": true
    },
    {
      "problem": "rolling_max",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "# Manually recorded - PASSED",
          "tests_passed": 4,
          "total_tests": 4,
          "time": 0.0,
          "iterations_used": 1,
          "manual_entry": true
        }
      ],
      "num_passed": 1,
      "num_samples": 1,
      "manual_entry": true
    },
    {
      "problem": "is_palindrome",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import List, Any, Optional, Union, Tuple, Dict\n\ndef validate_and_sanitize_input(input_str):\n    # REASONING: Validate that input is not None and is a string\n    if input_str is None:\n        # REASONING: None is not a valid string; return empty string as fallback\n        return ''\n    if not isinstance(input_str, str):\n        # REASONING: Non-string types are not acceptable; attempt to convert to string\n        try:\n            input_str = str(input_str)\n        except Exception as e:\n            # REASONING: If conversion fails, log and return empty string\n            return ''\n    # REASONING: Strip surrounding whitespace\n    try:\n        sanitized = input_str.strip()\n    except Exception as e:\n        # REASONING: If strip fails (unlikely), return empty string\n        sanitized = ''\n    # REASONING: Ensure result is not empty; if it is, return empty string\n    if sanitized == '':\n        return ''\n    # REASONING: Return sanitized string\n    return sanitized\n\ndef find_shortest_palindrome_core(sanitized_str):\n    # REASONING: Validate that the input is a string to avoid type errors later.\n    if not isinstance(sanitized_str, str):\n        raise TypeError(\"sanitized_str must be a string\")\n    # REASONING: Empty string is already a palindrome; return immediately.\n    if sanitized_str == \"\":\n        return \"\"\n    # REASONING: If the string is already a palindrome, no changes are needed.\n    if sanitized_str == sanitized_str[::-1]:\n        return sanitized_str\n    rev = sanitized_str[::-1]\n    # REASONING: Find the longest suffix of sanitized_str that matches a prefix of rev.\n    try:\n        for i in range(len(sanitized_str), -1, -1):\n            if sanitized_str[-i:] == rev[:i]:\n                suffix_len = i\n                break\n    except Exception as e:\n        # REASONING: In case of unexpected errors, fallback to returning the original string.\n        return sanitized_str\n    # REASONING: Append the remaining part of rev to form the shortest palindrome.\n    palindrome = sanitized_str + rev[suffix_len:]\n    # REASONING: Assert that the result is a palindrome and starts with the original string.\n    assert palindrome == palindrome[::-1], \"Result is not a palindrome\"\n    assert palindrome.startswith(sanitized_str), \"Result does not start with input\"\n    return palindrome\n\nimport logging\nlogger = logging.getLogger(__name__)\n\ndef format_output_or_handle_error(result_or_exception):\n    '''Return the palindrome string or raise a descriptive exception if the core module fails.'''\n    logger.debug('Entered format_output_or_handle_error')\n    # REASONING: Validate input type\n    if not isinstance(result_or_exception, (str, Exception, type(None))):\n        raise TypeError('Input must be a string, Exception instance, or None.')\n    # REASONING: Handle None input\n    if result_or_exception is None:\n        raise ValueError('Input cannot be None.')\n    # REASONING: If input is an Exception instance, re-raise it\n    if isinstance(result_or_exception, Exception):\n        raise result_or_exception\n    # At this point, input is a string\n    pal_str = result_or_exception\n    # REASONING: Check that string is palindrome\n    try:\n        if pal_str != pal_str[::-1]:\n            raise ValueError('Provided string is not a palindrome.')\n    except Exception as e:\n        # REASONING: Wrap any unexpected exception\n        raise RuntimeError('Error during palindrome validation.') from e\n    # REASONING: Postcondition: output is a palindrome\n    assert pal_str == pal_str[::-1], 'Output is not a palindrome.'\n    return pal_str\n\n\ndef is_palindrome(string) -> bool:\n    \"\"\"\n    Main function that integrates all modular components to solve the problem.\n    Generated by Modular ToT Self-Reflective Architecture.\n    \"\"\"\n    # Module execution chain\n    processed = validate_and_sanitize_input(string)\n    processed = find_shortest_palindrome_core(processed)\n    return format_output_or_handle_error(processed)\n",
          "tests_passed": 5,
          "total_tests": 5,
          "time": 537.3660390377045,
          "iterations_used": 1
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "string_xor",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import Tuple\n\n\ndef validate_binary_strings(a: str, b: str) -> bool:\n    \"\"\"\n    Validate that both inputs are non\u2011empty strings of equal length\n    containing only the characters '0' and '1'.\n    \"\"\"\n    if a is None or b is None:\n        return False\n    if not isinstance(a, str) or not isinstance(b, str):\n        return False\n    if a == \"\" or b == \"\":\n        return False\n    if len(a) != len(b):\n        return False\n    if not all(c in \"01\" for c in a):\n        return False\n    if not all(c in \"01\" for c in b):\n        return False\n    return True\n\n\ndef xor_binary_strings(a: str, b: str) -> str:\n    \"\"\"\n    Perform bitwise XOR on two binary strings of equal length.\n    \"\"\"\n    return \"\".join(\"1\" if ca != cb else \"0\" for ca, cb in zip(a, b))\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\"\n    Return the XOR of two binary strings.\n    Raises ValueError if the inputs are not valid binary strings.\n    \"\"\"\n    if not validate_binary_strings(a, b):\n        raise ValueError(\"Inputs must be non\u2011empty binary strings of equal length\")\n    return xor_binary_strings(a, b)",
          "tests_passed": 3,
          "total_tests": 3,
          "time": 698.6752638816833,
          "iterations_used": 2
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "longest",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import Optional\nfrom typing import List, Any, Optional, Union, Tuple, Dict\nfrom typing import List\n\nimport logging\nfrom typing import List\n\nlogging.basicConfig(level=logging.INFO)\n\ndef validate_strings(strings: List[str]) -> List[str]:\n    # REASONING: Ensure the input is a list; if not, fallback to empty list\n    try:\n        if not isinstance(strings, list):\n            raise TypeError('Input must be a list')\n    except TypeError as e:\n        logging.warning('Input is not a list: %s', e)\n        return []\n\n    # REASONING: Iterate over elements, converting non-string to string and stripping whitespace\n    sanitized = []\n    try:\n        for idx, item in enumerate(strings):\n            try:\n                if not isinstance(item, str):\n                    # Convert non-string to string\n                    item = str(item)\n                # Strip leading/trailing whitespace\n                item = item.strip()\n                sanitized.append(item)\n            except Exception as e:\n                logging.error('Error processing item at index %d: %s', idx, e)\n                # Fallback: skip problematic item\n                continue\n    except Exception as e:\n        logging.error('Unexpected error during sanitization: %s', e)\n        return []\n\n    # REASONING: Assert that all items in sanitized list are strings\n    assert all(isinstance(s, str) for s in sanitized), 'Sanitized list contains non-string elements'\n\n    return sanitized\n\nimport logging\n\n\ndef find_longest_string(validated_strings):\n    # REASONING: Configure logger for debugging\n    logger = logging.getLogger(__name__)\n    # REASONING: Input validation: ensure the input is a list\n    if not isinstance(validated_strings, list):\n        logger.error('Input is not a list')\n        raise TypeError('validated_strings must be a list')\n    # REASONING: Ensure all elements in the list are strings\n    for idx, item in enumerate(validated_strings):\n        if not isinstance(item, str):\n            logger.error(f'Element at index {idx} is not a string')\n            raise TypeError(f'All elements must be strings, element {idx} is {type(item).__name__}')\n    # REASONING: Handle the edge case of an empty list\n    if not validated_strings:\n        logger.info('Empty list provided, returning None')\n        return None\n    # REASONING: Find the longest string, keeping the first in case of ties\n    longest = validated_strings[0]\n    longest_len = len(longest)\n    for s in validated_strings[1:]:\n        try:\n            s_len = len(s)\n        except Exception:\n            logger.exception('Error computing length of string')\n            raise\n        if s_len > longest_len:\n            longest = s\n            longest_len = s_len\n    # REASONING: Postcondition assertion to guarantee the result type\n    assert isinstance(longest, str), 'Result must be a string'\n    return longest\n\ndef format_longest_string(result):\n    # REASONING: Precondition assertion ensures input is either None or string.\n    assert result is None or isinstance(result, str), 'Precondition: result must be string or None'\n    try:\n        if result is None:\n            # REASONING: Return None directly for None input.\n            output = None\n        else:\n            # REASONING: Since result is a string, assign to output.\n            output = result\n        # REASONING: Postcondition assertion ensures output type consistency.\n        assert output is None or isinstance(output, str), 'Postcondition: output must be string or None'\n        return output\n    except AssertionError as ae:\n        # REASONING: Re-raise assertion error to signal precondition failure.\n        raise\n    except Exception as e:\n        # REASONING: Unexpected errors fallback.\n        print(f'Unexpected error in format_longest_string: {e}')\n        return None\n\n\ndef longest(strings) -> Optional[str]:\n    \"\"\"\n    Main function that integrates all modular components to solve the problem.\n    Generated by Modular ToT Self-Reflective Architecture.\n    \"\"\"\n    # Module execution chain\n    processed = validate_strings(strings)\n    processed = find_longest_string(processed)\n    return format_longest_string(processed)\n",
          "tests_passed": 3,
          "total_tests": 3,
          "time": 473.4662010669708,
          "iterations_used": 1
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "greatest_common_divisor",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import Tuple\n\ndef validate_integers(a, b) -> Tuple[int, int]:\n    \"\"\"Validate that a and b are integers (or floats representing integers) and return their absolute values.\"\"\"\n    import math\n    if a is None or b is None:\n        raise ValueError(\"Inputs must not be None\")\n\n    def to_int(x, name):\n        if isinstance(x, int):\n            return x\n        if isinstance(x, float):\n            if not x.is_integer():\n                raise ValueError(f\"{name} float {x} is not an integer value\")\n            if not math.isfinite(x):\n                raise ValueError(f\"{name} float {x} is not finite\")\n            return int(x)\n        raise ValueError(f\"{name} must be an integer or float representing an integer\")\n\n    a_val = to_int(a, \"a\")\n    b_val = to_int(b, \"b\")\n\n    return abs(a_val), abs(b_val)\n\ndef compute_gcd(a: int, b: int) -> int:\n    \"\"\"Compute the greatest common divisor of two non\u2011negative integers using the Euclidean algorithm.\"\"\"\n    if a < 0 or b < 0:\n        raise ValueError(\"Inputs must be non\u2011negative\")\n    if a == 0 and b == 0:\n        return 0\n    while b != 0:\n        a, b = b, a % b\n    return a\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\"Return the greatest common divisor of two integers a and b.\"\"\"\n    a_nonneg, b_nonneg = validate_integers(a, b)\n    return compute_gcd(a_nonneg, b_nonneg)",
          "tests_passed": 4,
          "total_tests": 4,
          "time": 381.46503496170044,
          "iterations_used": 2
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "all_prefixes",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import List, Optional\nimport logging\n\nlogging.basicConfig(level=logging.INFO)\n\ndef validate_and_sanitize_input(raw_input: str) -> str:\n    \"\"\"Validate that raw_input is a string. Empty strings are allowed.\"\"\"\n    if raw_input is None:\n        raise ValueError('Input cannot be None.')\n    if not isinstance(raw_input, str):\n        raise ValueError(f'Input must be a string, got {type(raw_input).__name__}.')\n    return raw_input\n\ndef compute_prefixes(validated_string: str) -> List[str]:\n    \"\"\"Return all prefixes of the validated string.\"\"\"\n    if validated_string == '':\n        return []\n    return [validated_string[:i] for i in range(1, len(validated_string) + 1)]\n\ndef format_output(prefix_list: Optional[List[str]]) -> List[str]:\n    \"\"\"Return a copy of the prefix list, ensuring all elements are strings.\"\"\"\n    if prefix_list is None:\n        return []\n    if not isinstance(prefix_list, list):\n        raise TypeError(\"prefix_list must be a list or None\")\n    for idx, item in enumerate(prefix_list):\n        if not isinstance(item, str):\n            raise ValueError(f\"Element at index {idx} is not a string\")\n    return list(prefix_list)\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\"Return list of all prefixes from shortest to longest of the input string.\"\"\"\n    processed = validate_and_sanitize_input(string)\n    processed = compute_prefixes(processed)\n    return format_output(processed)",
          "tests_passed": 3,
          "total_tests": 3,
          "time": 1374.1876409053802,
          "iterations_used": 2
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "string_sequence",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import List\n\ndef validate_and_sanitize_input(n: int) -> int:\n    \"\"\"Validate that n is a non\u2011negative integer.\"\"\"\n    if not isinstance(n, int) or isinstance(n, bool):\n        raise ValueError(\"Input must be an integer.\")\n    if n < 0:\n        raise ValueError(\"Input must be non\u2011negative.\")\n    return n\n\ndef fallback_function(n: int) -> List[int]:\n    \"\"\"Generate the sequence of integers from 0 to n inclusive.\"\"\"\n    return list(range(n + 1))\n\ndef format_sequence_to_string(sequence: List[int]) -> str:\n    \"\"\"Convert a list of integers into a space\u2011delimited string.\"\"\"\n    if not isinstance(sequence, (list, tuple)):\n        raise TypeError(\"sequence must be a list or tuple\")\n    for idx, item in enumerate(sequence):\n        if not isinstance(item, int):\n            raise TypeError(f\"element at index {idx} is not an int\")\n    if len(sequence) == 0:\n        return \"\"\n    return \" \".join(str(item) for item in sequence)\n\ndef string_sequence(n: int) -> str:\n    \"\"\"Return a string containing space\u2011delimited numbers from 0 to n inclusive.\"\"\"\n    processed = validate_and_sanitize_input(n)\n    sequence = fallback_function(processed)\n    return format_sequence_to_string(sequence)",
          "tests_passed": 3,
          "total_tests": 3,
          "time": 2709.444823026657,
          "iterations_used": 2
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "count_distinct_characters",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import Any\n\ndef validate_and_sanitize_input(raw_input: Any) -> str:\n    \"\"\"Ensure the input is a string.\"\"\"\n    if not isinstance(raw_input, str):\n        raise TypeError(\"Input must be a string\")\n    return raw_input\n\ndef count_distinct_characters_core(sanitized_input: str) -> int:\n    \"\"\"Return the number of distinct characters (case\u2011insensitive) in the string.\"\"\"\n    return len({ch.lower() for ch in sanitized_input})\n\ndef count_distinct_characters(string: Any) -> int:\n    \"\"\"\n    Main function that counts distinct characters in a string, ignoring case.\n    \"\"\"\n    sanitized = validate_and_sanitize_input(string)\n    return count_distinct_characters_core(sanitized)",
          "tests_passed": 5,
          "total_tests": 5,
          "time": 369.5116810798645,
          "iterations_used": 3
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "parse_music",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import List\n\ndef parse_music_notes(sanitized_string: str) -> List[int]:\n    \"\"\"\n    Parse a sanitized string of music notes into a list of beat durations.\n\n    Parameters\n    ----------\n    sanitized_string : str\n        The input string containing music note tokens separated by whitespace.\n\n    Returns\n    -------\n    List[int]\n        A list of integers representing the beat durations for each token.\n    \"\"\"\n    if not isinstance(sanitized_string, str):\n        raise TypeError(\"sanitized_string must be a string\")\n\n    token_map = {\n        'o': 4,     # whole note\n        'o|': 2,    # half note\n        '.|': 1     # quarter note\n    }\n\n    tokens = sanitized_string.split()\n    result: List[int] = []\n\n    for token in tokens:\n        if token not in token_map:\n            raise ValueError(f\"Unknown token: '{token}'\")\n        result.append(token_map[token])\n\n    return result\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\"\n    Main function that parses the music string into beat durations.\n\n    Parameters\n    ----------\n    music_string : str\n        The input string representing musical notes.\n\n    Returns\n    -------\n    List[int]\n        A list of integers corresponding to how many beats each note lasts.\n    \"\"\"\n    return parse_music_notes(music_string)",
          "tests_passed": 5,
          "total_tests": 5,
          "time": 1676.6800668239594,
          "iterations_used": 2
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "how_many_times",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import Any\n\nimport logging\n\nlogger = logging.getLogger(__name__)\nlogging.basicConfig(level=logging.INFO)\n\n\ndef validate_inputs(string: Any, substring: Any) -> None:\n    \"\"\"Validate that both inputs are non\u2011None strings.\"\"\"\n    try:\n        assert string is not None, \"string must not be None\"\n        assert substring is not None, \"substring must not be None\"\n        assert isinstance(string, str), f\"string must be a str, got {type(string).__name__}\"\n        assert isinstance(substring, str), f\"substring must be a str, got {type(substring).__name__}\"\n    except AssertionError as ae:\n        logger.error(\"Input validation failed: %s\", ae)\n        raise TypeError(ae.args[0]) from ae\n\n\ndef count_overlapping_substrings(string: str, substring: str) -> int:\n    \"\"\"Count overlapping occurrences of `substring` in `string`.\"\"\"\n    if substring == \"\":\n        return 0\n    if len(substring) > len(string):\n        return 0\n\n    count = 0\n    start = 0\n    while True:\n        index = string.find(substring, start)\n        if index == -1:\n            break\n        count += 1\n        start = index + 1\n    return count\n\n\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\"Return the number of overlapping occurrences of `substring` in `string`.\"\"\"\n    validate_inputs(string, substring)\n    return count_overlapping_substrings(string, substring)",
          "tests_passed": 4,
          "total_tests": 4,
          "time": 275.89578104019165,
          "iterations_used": 2
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "sort_numbers",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import List\n\nimport logging\n\n# Configure logger\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.DEBUG)\nhandler = logging.StreamHandler()\nformatter = logging.Formatter('%(levelname)s:%(name)s:%(message)s')\nhandler.setFormatter(formatter)\nlogger.addHandler(handler)\n\ndef validate_and_parse_input(input_str: str) -> List[str]:\n    \"\"\"Validate that input is a string and parse it into a list of lowercase number words.\"\"\"\n    if not isinstance(input_str, str):\n        logger.error('Input is not a string')\n        raise TypeError('input_str must be a string')\n    stripped = input_str.strip()\n    if not stripped:\n        return []\n    valid_words = {\n        'zero', 'one', 'two', 'three', 'four',\n        'five', 'six', 'seven', 'eight', 'nine',\n    }\n    words = stripped.split()\n    result = []\n    for w in words:\n        lw = w.lower()\n        if lw not in valid_words:\n            logger.error(f'Invalid word detected: {w}')\n            raise ValueError(f'Invalid word: {w}')\n        result.append(lw)\n    return result\n\ndef sort_numeric_words(words: List[str]) -> List[str]:\n    \"\"\"Sort a list of number words according to their numeric value.\"\"\"\n    number_map = {\n        \"zero\": 0, \"one\": 1, \"two\": 2, \"three\": 3, \"four\": 4,\n        \"five\": 5, \"six\": 6, \"seven\": 7, \"eight\": 8, \"nine\": 9,\n    }\n\n    def word_to_value(word: str) -> int:\n        try:\n            return number_map[word]\n        except KeyError:\n            raise ValueError(f\"Unrecognized number word: {word}\") from None\n\n    sorted_words = sorted(words, key=word_to_value)\n    return sorted_words\n\ndef fallback_function(words: List[str]) -> str:\n    \"\"\"Return the sorted words as a space\u2011delimited string.\"\"\"\n    return ' '.join(words)\n\ndef sort_numbers(numbers: str) -> str:\n    \"\"\"Main function that integrates all modular components to solve the problem.\"\"\"\n    processed = validate_and_parse_input(numbers)\n    processed = sort_numeric_words(processed)\n    return fallback_function(processed)",
          "tests_passed": 5,
          "total_tests": 5,
          "time": 699.9422001838684,
          "iterations_used": 2
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "find_closest_elements",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import List, Any, Optional, Union, Tuple, Dict\nfrom typing import List\nfrom typing import Tuple\n\nimport logging\nlogger = logging.getLogger(__name__)\n\ndef validate_and_sanitize_numbers(numbers):\n    # REASONING: Log the start of the validation process\n    logger.debug('Starting validation and sanitization of numbers list.')\n    # REASONING: Validate that input is a list or tuple\n    if not isinstance(numbers, (list, tuple)):\n        raise TypeError('Input must be a list or tuple of numbers.')\n    # REASONING: Ensure list has at least two elements\n    if len(numbers) < 2:\n        raise ValueError('Input list must contain at least two elements.')\n    sanitized = []\n    # REASONING: Iterate and convert each element to float, handling errors\n    for idx, item in enumerate(numbers):\n        try:\n            # REASONING: Attempt conversion; Decimal, int, float will work\n            sanitized.append(float(item))\n        except (TypeError, ValueError) as e:\n            # REASONING: If conversion fails, raise informative error\n            raise TypeError(f'Element at index {idx} is not a numeric value: {item}') from e\n    # REASONING: Postcondition: ensure at least two numeric values\n    assert len(sanitized) >= 2, 'Sanitized list must contain at least two numeric values.'\n    # REASONING: Log the successful completion of sanitization\n    logger.debug('Sanitization complete: %s', sanitized)\n    return sanitized\n\ndef find_closest_pair(numbers):\n    # REASONING: Validate input type\n    if not isinstance(numbers, (list, tuple)):\n        raise TypeError('Input must be a list or tuple of numbers.')\n    # REASONING: Ensure list is not empty\n    if len(numbers) < 2:\n        raise ValueError('At least two numbers are required to find a pair.')\n    # REASONING: Validate each element is int or float\n    for idx, val in enumerate(numbers):\n        if not isinstance(val, (int, float)):\n            raise TypeError(f'Element at index {idx} is not a number.')\n    # REASONING: Sort numbers to compare adjacent pairs\n    try:\n        sorted_nums = sorted(numbers)\n    except Exception as e:\n        raise ValueError('Failed to sort numbers.') from e\n    # REASONING: Initialize best pair with first two elements\n    best_pair = (sorted_nums[0], sorted_nums[1])\n    best_diff = abs(best_pair[1] - best_pair[0])\n    # REASONING: Iterate through sorted list to find minimal difference\n    for i in range(1, len(sorted_nums) - 1):\n        a, b = sorted_nums[i], sorted_nums[i + 1]\n        diff = abs(b - a)\n        if diff < best_diff:\n            best_diff = diff\n            best_pair = (a, b)\n            # REASONING: Early exit if zero difference found\n            if best_diff == 0:\n                break\n    # REASONING: Postcondition: best_pair contains two numbers from input\n    assert best_pair[0] in numbers and best_pair[1] in numbers, 'Best pair not from input.'\n    return best_pair\n\n\ndef find_closest_elements(numbers) -> Tuple[float, float]:\n    \"\"\"\n    Main function that integrates all modular components to solve the problem.\n    Generated by Modular ToT Self-Reflective Architecture.\n    \"\"\"\n    # Module execution chain\n    processed = validate_and_sanitize_numbers(numbers)\n    return find_closest_pair(processed)\n",
          "tests_passed": 5,
          "total_tests": 5,
          "time": 1444.5297873020172,
          "iterations_used": 1
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "rescale_to_unit",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import List\nfrom typing import List, Any, Optional, Union, Tuple, Dict\n\nimport math\nimport logging\n\nlogging.basicConfig(level=logging.INFO)\n\ndef validate_and_sanitize_numbers(numbers):\n    # REASONING: Ensure input is a list or tuple\n    if not isinstance(numbers, (list, tuple)):\n        raise TypeError('Input must be a list or tuple of numbers.')\n    # REASONING: Remove None values\n    cleaned = []\n    for idx, value in enumerate(numbers):\n        # REASONING: Skip None values\n        if value is None:\n            continue\n        # REASONING: Attempt to convert to float\n        try:\n            num = float(value)\n        except (TypeError, ValueError):\n            raise TypeError(f'Element at index {idx} is not numeric: {value!r}')\n        # REASONING: Check for NaN or Infinity\n        if not math.isfinite(num):\n            raise ValueError(f'Element at index {idx} is NaN or infinite: {value!r}')\n        cleaned.append(num)\n    # REASONING: Ensure at least two numeric elements\n    if len(cleaned) < 2:\n        raise ValueError('Input must contain at least two numeric elements after removing None values.')\n    # REASONING: Postcondition checks\n    assert all(isinstance(x, float) for x in cleaned), 'Postcondition: all elements are float'\n    assert len(cleaned) >= 2, 'Postcondition: at least two elements'\n    # REASONING: Return cleaned list\n    return cleaned\n\ndef compute_rescaled(numbers):\n    # REASONING: Validate that input is a list or tuple\n    if not isinstance(numbers, (list, tuple)):\n        raise TypeError(\"Input must be a list or tuple of numbers.\")\n    # REASONING: Ensure all elements are numeric and not NaN or Infinity\n    for idx, val in enumerate(numbers):\n        if not isinstance(val, (int, float)):\n            raise TypeError(f\"Element at index {idx} is not a number.\")\n        if isinstance(val, float):\n            if val != val or val in (float('inf'), float('-inf')):\n                raise ValueError(f\"Element at index {idx} is NaN or Infinity.\")\n    # REASONING: Handle empty list early\n    if len(numbers) == 0:\n        return []\n    # REASONING: Compute min and max safely\n    try:\n        min_val = min(numbers)\n        max_val = max(numbers)\n    except Exception as e:\n        raise RuntimeError(\"Failed to compute min or max.\") from e\n    # REASONING: If all values are equal, return zeros to avoid division by zero\n    if min_val == max_val:\n        return [0.0 for _ in numbers]\n    # REASONING: Perform linear scaling\n    try:\n        range_val = max_val - min_val\n        rescaled = [(x - min_val) / range_val for x in numbers]\n    except Exception as e:\n        raise RuntimeError(\"Error during scaling.\") from e\n    # REASONING: Postcondition check: all values in [0,1]\n    assert all(0.0 <= v <= 1.0 for v in rescaled), \"Scaled values out of bounds.\"\n    return rescaled\n\ndef format_rescaled_output(rescaled):\n    import logging\n    logger = logging.getLogger(__name__)\n    logger.debug('Starting format_rescaled_output with input: %s', rescaled)\n    # REASONING: Validate that input is a list or tuple\n    if not isinstance(rescaled, (list, tuple)):\n        raise TypeError('Input must be a list or tuple of numeric values.')\n    # REASONING: Ensure list is not None\n    if rescaled is None:\n        raise ValueError('Input cannot be None.')\n    output = []\n    for idx, val in enumerate(rescaled):\n        try:\n            num = float(val)\n        except (TypeError, ValueError) as e:\n            raise ValueError(f'Element at index {idx} is not numeric: {val}') from e\n        else:\n            output.append(num)\n    assert len(output) == len(rescaled), 'Output length mismatch.'\n    logger.debug('Finished format_rescaled_output, output: %s', output)\n    return output\n\n\ndef rescale_to_unit(numbers) -> List[float]:\n    \"\"\"\n    Main function that integrates all modular components to solve the problem.\n    Generated by Modular ToT Self-Reflective Architecture.\n    \"\"\"\n    # Module execution chain\n    processed = validate_and_sanitize_numbers(numbers)\n    processed = compute_rescaled(processed)\n    return format_rescaled_output(processed)\n",
          "tests_passed": 5,
          "total_tests": 5,
          "time": 330.91849088668823,
          "iterations_used": 1
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "filter_integers",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import List, Any\nimport logging\n\nlogger = logging.getLogger(__name__)\n\ndef validate_and_sanitize_input(values: Any) -> List[Any]:\n    \"\"\"\n    Validate that the input is a list. No other checks are performed.\n    \"\"\"\n    if not isinstance(values, list):\n        raise TypeError(f\"Expected a list, got {type(values).__name__}\")\n    return values\n\ndef filter_integers_core(values: List[Any]) -> List[int]:\n    \"\"\"\n    Return a new list containing only the elements of `values` that are\n    of type `int` (excluding bools and subclasses).\n    \"\"\"\n    result: List[int] = []\n    for item in values:\n        if type(item) is int:\n            result.append(item)\n    logger.debug(f\"Filtered {len(result)} integers from {len(values)} items\")\n    return result\n\ndef filter_integers(values: Any) -> List[int]:\n    \"\"\"\n    Main function that integrates validation and filtering.\n    \"\"\"\n    processed = validate_and_sanitize_input(values)\n    return filter_integers_core(processed)",
          "tests_passed": 3,
          "total_tests": 3,
          "time": 309.7781319618225,
          "iterations_used": 2
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "strlen",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import Any\n\ndef validate_input_string(input_value: Any) -> str:\n    \"\"\"Validate that the input is a string (or None).\"\"\"\n    if input_value is None:\n        raise ValueError(\"Input value cannot be None\")\n    if not isinstance(input_value, str):\n        raise TypeError(f\"Expected a string, got {type(input_value).__name__}\")\n    return input_value\n\ndef compute_string_length(validated_str: str) -> int:\n    \"\"\"Return the length of the validated string.\"\"\"\n    length = 0\n    for _ in validated_str:\n        length += 1\n    return length\n\ndef format_length(length: int) -> int:\n    \"\"\"Return a validated, non\u2011negative length.\"\"\"\n    if length < 0:\n        length = 0\n    return length\n\ndef strlen(string: str) -> int:\n    \"\"\"\n    Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\"\n    processed = validate_input_string(string)\n    processed = compute_string_length(processed)\n    return format_length(processed)",
          "tests_passed": 3,
          "total_tests": 3,
          "time": 274.69016122817993,
          "iterations_used": 2
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "largest_divisor",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from math import isqrt\n\ndef validate_input(n: int) -> int:\n    \"\"\"Validate that n is an integer greater than 1.\"\"\"\n    if not isinstance(n, int):\n        raise TypeError(\"Input must be an integer.\")\n    if n <= 1:\n        raise ValueError(\"Input must be greater than 1.\")\n    return n\n\ndef compute_largest_divisor(n: int) -> int:\n    \"\"\"Return the largest proper divisor of n.\"\"\"\n    # Find the smallest divisor greater than 1\n    if n % 2 == 0:\n        smallest = 2\n    else:\n        smallest = None\n        limit = isqrt(n)\n        for d in range(3, limit + 1, 2):\n            if n % d == 0:\n                smallest = d\n                break\n    # If no divisor found, n is prime\n    if smallest is None:\n        return 1\n    return n // smallest\n\ndef largest_divisor(n: int) -> int:\n    \"\"\"For a given number n, find the largest number that divides n evenly, smaller than n.\"\"\"\n    validated = validate_input(n)\n    return compute_largest_divisor(validated)",
          "tests_passed": 5,
          "total_tests": 5,
          "time": 356.223916053772,
          "iterations_used": 2
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "factorize",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import List\nfrom typing import List, Any, Optional, Union, Tuple, Dict\n\ndef validate_and_sanitize_input(n):\n    # REASONING: Import logging for optional debug output\n    import logging\n    logger = logging.getLogger(__name__)\n    logger.debug('Starting validation for input: %s', n)\n    # REASONING: Start a try block to catch unexpected errors\n    try:\n        # REASONING: Ensure n is not None\n        assert n is not None, 'Input cannot be None'\n        # REASONING: Check that n is an integer\n        if not isinstance(n, int):\n            raise TypeError(f'Input must be an integer, got {type(n).__name__}')\n        # REASONING: Ensure n is greater than 1\n        if n <= 1:\n            raise ValueError(f'Input must be greater than 1, got {n}')\n        # REASONING: Postcondition: return validated integer\n        return n\n    except (TypeError, ValueError) as e:\n        # REASONING: Re-raise known validation errors\n        raise\n    except Exception as e:\n        # REASONING: Fallback for unexpected errors\n        raise RuntimeError('Unexpected error during input validation') from e\n\nimport logging\n\nlogging.basicConfig(level=logging.DEBUG)\n\n\ndef prime_factorization(n):\n    # REASONING: Validate that the input is an integer and positive.\n    if not isinstance(n, int):\n        raise TypeError(\"Input must be an integer.\")\n    if n < 1:\n        raise ValueError(\"Input must be a positive integer.\")\n    # REASONING: 1 has no prime factors; return an empty list.\n    if n == 1:\n        return []\n    factors = []\n    # REASONING: Use trial division starting with the smallest prime 2.\n    try:\n        # Count all factors of 2.\n        while n % 2 == 0:\n            factors.append(2)\n            n //= 2\n        # REASONING: Check odd divisors up to sqrt(n).\n        divisor = 3\n        max_divisor = int(n ** 0.5) + 1\n        while divisor <= max_divisor and n > 1:\n            while n % divisor == 0:\n                factors.append(divisor)\n                n //= divisor\n                # REASONING: Update the upper bound after reducing n.\n                max_divisor = int(n ** 0.5) + 1\n            divisor += 2\n        # REASONING: If n > 1 here, it is a prime factor.\n        if n > 1:\n            factors.append(n)\n    except Exception as e:\n        # REASONING: Catch any unexpected errors during factorization.\n        raise RuntimeError(\"An error occurred during prime factorization.\") from e\n    # REASONING: Postcondition: factors must be sorted in ascending order.\n    assert all(factors[i] <= factors[i + 1] for i in range(len(factors) - 1)), \"Factors not sorted.\"\n    return factors\n\ndef format_factors(factors):\n\timport logging\n\tlogger = logging.getLogger(__name__)\n\ttry:\n\t\t# REASONING: Precondition: factors must be a list\n\t\tassert isinstance(factors, list), \"factors must be a list\"\n\t\t# REASONING: Precondition: all elements are integers\n\t\tassert all(isinstance(x, int) for x in factors), \"all elements must be integers\"\n\t\t# REASONING: Edge case: empty list\n\t\tif len(factors) == 0:\n\t\t\tresult = []\n\t\telse:\n\t\t\tresult = factors\n\t\t# REASONING: Postcondition: result is a list\n\t\tassert isinstance(result, list), \"output must be a list\"\n\t\treturn result\n\texcept AssertionError as ae:\n\t\tlogger.error(f\"Assertion failed: {ae}\")\n\t\traise\n\tfinally:\n\t\tlogger.debug(\"Exiting format_factors\")\n\n\ndef factorize(n) -> List[int]:\n    \"\"\"\n    Main function that integrates all modular components to solve the problem.\n    Generated by Modular ToT Self-Reflective Architecture.\n    \"\"\"\n    # Module execution chain\n    processed = validate_and_sanitize_input(n)\n    processed = prime_factorization(processed)\n    return format_factors(processed)\n",
          "tests_passed": 8,
          "total_tests": 8,
          "time": 751.0408270359039,
          "iterations_used": 1
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "remove_duplicates",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import List\nfrom typing import List, Any, Optional, Union, Tuple, Dict\n\ndef validate_and_sanitize_numbers(numbers):\n    # REASONING: Ensure the function receives a list; if None or other type, raise TypeError\n    if numbers is None:\n        raise TypeError('Input \"numbers\" cannot be None.')\n    if not isinstance(numbers, list):\n        raise TypeError(f'Expected a list, got {type(numbers).__name__}.')\n    # REASONING: Empty list is a valid input; return it unchanged\n    if len(numbers) == 0:\n        return []\n    # REASONING: Validate each element is an integer; collect sanitized list\n    sanitized = []\n    try:\n        for idx, item in enumerate(numbers):\n            if not isinstance(item, int):\n                raise ValueError(f'Element at index {idx} is not an integer: {item!r}')\n            sanitized.append(item)\n    except Exception as e:\n        # REASONING: Re-raise with context\n        raise ValueError(f'Invalid input list: {e}') from e\n    # REASONING: Postcondition: return list of ints\n    assert all(isinstance(x, int) for x in sanitized), 'Sanitized list contains non-integer.'\n    return sanitized\n\nimport logging\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\ndef filter_unique_numbers(numbers):\n    '''Return a new list containing only those integers that occur exactly once, preserving order.'''\n    # REASONING: Validate input type\n    if not isinstance(numbers, list):\n        raise TypeError('Input must be a list.')\n    # REASONING: Validate elements are integers\n    for idx, item in enumerate(numbers):\n        if not isinstance(item, int):\n            raise ValueError(f'All elements must be integers. Element at index {idx} is {type(item).__name__}.')\n    # REASONING: Use Counter to count occurrences\n    try:\n        from collections import Counter\n        counts = Counter(numbers)\n    except Exception as e:\n        logger.error('Failed to import Counter: %s', e)\n        # Fallback: manual counting\n        counts = {}\n        for num in numbers:\n            counts[num] = counts.get(num, 0) + 1\n    # REASONING: Build result preserving order\n    result = []\n    for num in numbers:\n        if counts.get(num, 0) == 1:\n            result.append(num)\n    # REASONING: Postcondition assertion\n    assert all(isinstance(x, int) for x in result), 'Result contains non-integer values.'\n    return result\n\n\ndef remove_duplicates(numbers) -> List[int]:\n    \"\"\"\n    Main function that integrates all modular components to solve the problem.\n    Generated by Modular ToT Self-Reflective Architecture.\n    \"\"\"\n    # Module execution chain\n    processed = validate_and_sanitize_numbers(numbers)\n    return filter_unique_numbers(processed)\n",
          "tests_passed": 3,
          "total_tests": 3,
          "time": 243.68881678581238,
          "iterations_used": 1
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "flip_case",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import List, Any, Optional, Union, Tuple, Dict\n\nimport logging\n\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.DEBUG)\nhandler = logging.StreamHandler()\nformatter = logging.Formatter(\"%(levelname)s:%(name)s:%(message)s\")\nhandler.setFormatter(formatter)\nlogger.addHandler(handler)\n\ndef validate_input_string(input_value):\n    # REASONING: Ensure input is not None and is a string; handle edge cases\n    try:\n        if input_value is None:\n            # REASONING: None is treated as empty string\n            logger.debug(\"Input is None, returning empty string.\")\n            return \"\"\n        if not isinstance(input_value, str):\n            # REASONING: Non-string input is invalid; raise TypeError\n            raise TypeError(f\"Expected a string, got {type(input_value).__name__}\")\n        # REASONING: Strip leading/trailing whitespace for basic sanitization\n        sanitized = input_value.strip()\n        # REASONING: Ensure result is a string\n        assert isinstance(sanitized, str), \"Sanitized output is not a string\"\n        logger.debug(f\"Sanitized input: '{sanitized}'\")\n        return sanitized\n    except TypeError as te:\n        logger.error(f\"TypeError: {te}\")\n        raise\n    except Exception as e:\n        logger.exception(\"Unexpected error during input validation\")\n        raise\n\nimport logging\n\ndef flip_case_core(s):\n    # REASONING: Validate input type to avoid unexpected errors\n    if not isinstance(s, str):\n        raise TypeError(\"Input must be a string\")\n    # REASONING: Assert precondition that input is a string\n    assert isinstance(s, str), \"Precondition failed: s is not a string\"\n    try:\n        # REASONING: Build result list for performance and to handle Unicode\n        result = []\n        for ch in s:\n            # REASONING: Only flip case for alphabetic characters\n            if ch.isalpha():\n                result.append(ch.swapcase())\n            else:\n                result.append(ch)\n        output = ''.join(result)\n        # REASONING: Assert postcondition that output length matches input\n        assert len(output) == len(s), \"Postcondition failed: output length mismatch\"\n        return output\n    except Exception as e:\n        # REASONING: Log the exception for debugging purposes\n        logging.exception(\"Error in flip_case_core\")\n        # REASONING: Fallback to original string if unexpected error occurs\n        return s\n\nimport logging\n\nlogging.basicConfig(level=logging.DEBUG)\n\ndef format_output(result):\n    # REASONING: Validate input type and handle None\n    if result is None:\n        # REASONING: Edge case: None input, return empty string\n        return ''\n    # REASONING: Ensure result can be converted to string\n    try:\n        output = str(result)\n    except Exception as e:\n        # REASONING: If conversion fails, log and return placeholder\n        logging.error('Failed to convert result to string: %s', e)\n        return '<conversion_error>'\n    # REASONING: Trim whitespace and enforce length limit\n    output = output.strip()\n    MAX_LENGTH = 1000\n    if len(output) > MAX_LENGTH:\n        # REASONING: Truncate long strings to avoid overflow\n        output = output[:MAX_LENGTH]\n    # REASONING: Assert output is string and not None\n    assert isinstance(output, str), 'Output is not a string'\n    assert output is not None, 'Output is None'\n    return output\n\n\ndef flip_case(string) -> str:\n    \"\"\"\n    Main function that integrates all modular components to solve the problem.\n    Generated by Modular ToT Self-Reflective Architecture.\n    \"\"\"\n    # Module execution chain\n    processed = validate_input_string(string)\n    processed = flip_case_core(processed)\n    return format_output(processed)\n",
          "tests_passed": 3,
          "total_tests": 3,
          "time": 338.9490170478821,
          "iterations_used": 1
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "concatenate",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import List\nfrom typing import List, Any, Optional, Union, Tuple, Dict\n\nimport logging\n\n# REASONING: Set up a logger for optional debugging and warning messages\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.DEBUG)\n\n\ndef validate_and_sanitize_strings(input_strings):\n    # REASONING: Ensure the input is a list; otherwise raise a clear error\n    if not isinstance(input_strings, list):\n        raise TypeError('input_strings must be a list')\n\n    # REASONING: Prepare a list to hold sanitized string elements\n    sanitized = []\n\n    # REASONING: Iterate over each element with its index for precise logging\n    for idx, elem in enumerate(input_strings):\n        try:\n            # REASONING: Convert None to an empty string to avoid None values in output\n            if elem is None:\n                sanitized.append('')\n                continue\n            # REASONING: If the element is already a string, keep it unchanged\n            if isinstance(elem, str):\n                sanitized.append(elem)\n                continue\n            # REASONING: For any other type, convert it to its string representation\n            sanitized.append(str(elem))\n        except Exception as e:\n            # REASONING: If conversion fails, log the issue and append an empty string as a fallback\n            logger.warning('Failed to sanitize element at index %s: %s', idx, e)\n            sanitized.append('')\n\n    # REASONING: Assert that all elements in the result are strings\n    assert all(isinstance(s, str) for s in sanitized), 'All sanitized elements must be strings'\n    return sanitized\n\ndef concatenate_strings(valid_strings):\n    # REASONING: Validate input type and contents\n    if not isinstance(valid_strings, list):\n        raise TypeError('valid_strings must be a list')\n    for idx, item in enumerate(valid_strings):\n        if not isinstance(item, str):\n            raise TypeError(f'Element at index {idx} is not a string')\n    if len(valid_strings) == 0:\n        return ''\n    result = ''\n    try:\n        result = ''.join(valid_strings)\n    except Exception as e:\n        raise ValueError('Failed to concatenate strings') from e\n    finally:\n        import logging\n        logging.debug(f'Concatenated result: {result}')\n    assert isinstance(result, str), 'Result is not a string'\n    return result\n\n\ndef concatenate(strings) -> str:\n    \"\"\"\n    Main function that integrates all modular components to solve the problem.\n    Generated by Modular ToT Self-Reflective Architecture.\n    \"\"\"\n    # Module execution chain\n    processed = validate_and_sanitize_strings(strings)\n    return concatenate_strings(processed)\n",
          "tests_passed": 3,
          "total_tests": 3,
          "time": 193.64159893989563,
          "iterations_used": 1
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "filter_by_prefix",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import List, Any\nimport logging\n\nlogging.basicConfig(level=logging.INFO)\n\n\ndef validate_and_sanitize_input(strings: List[Any], prefix: Any) -> tuple[List[str], str]:\n    if not isinstance(strings, list):\n        raise TypeError(\"strings must be a list\")\n    if prefix is not None and not isinstance(prefix, str):\n        raise TypeError(\"prefix must be a string or None\")\n    if prefix is None:\n        prefix = \"\"\n\n    sanitized: List[str] = []\n    for idx, item in enumerate(strings):\n        try:\n            if item is None:\n                s = \"None\"\n            else:\n                s = str(item)\n            if isinstance(s, str):\n                s = s.strip()\n            sanitized.append(s)\n        except Exception:\n            logging.exception(f\"Failed to sanitize item at index {idx}: {item}\")\n            sanitized.append(\"None\")\n\n    assert all(isinstance(x, str) for x in sanitized), \"sanitized list contains non-string\"\n    assert isinstance(prefix, str), \"prefix is not string after fallback\"\n    return sanitized, prefix\n\n\ndef filter_strings_by_prefix(validated_strings: List[str], validated_prefix: str) -> List[str]:\n    if not isinstance(validated_strings, list):\n        raise TypeError(\"validated_strings must be a list\")\n    if not isinstance(validated_prefix, str):\n        raise TypeError(\"validated_prefix must be a string\")\n\n    if not validated_strings:\n        return []\n\n    if validated_prefix == \"\":\n        return validated_strings.copy()\n\n    result: List[str] = []\n    for s in validated_strings:\n        if not isinstance(s, str):\n            logging.warning(\"Non-string element encountered and skipped: %s\", s)\n            continue\n        if s.startswith(validated_prefix):\n            result.append(s)\n\n    assert all(isinstance(item, str) for item in result), \"Result contains non-string items\"\n    return result\n\n\ndef format_filtered_output(filtered_strings: List[str]) -> List[str]:\n    if not isinstance(filtered_strings, list):\n        raise TypeError(\"filtered_strings must be a list\")\n    if not all(isinstance(item, str) for item in filtered_strings):\n        raise ValueError(\"All items in filtered_strings must be strings\")\n\n    if not filtered_strings:\n        return []\n\n    return list(filtered_strings)\n\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    sanitized_strings, sanitized_prefix = validate_and_sanitize_input(strings, prefix)\n    filtered = filter_strings_by_prefix(sanitized_strings, sanitized_prefix)\n    return format_filtered_output(filtered)",
          "tests_passed": 2,
          "total_tests": 2,
          "time": 406.72390818595886,
          "iterations_used": 2
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "get_positive",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import List, Any, Optional, Union, Tuple, Dict\n\ndef sanitize_input(input_list):\n    \"\"\"Validate that input_list is a list of numeric values and return a sanitized list.\n    Raises ValueError for invalid inputs.\n    \"\"\"\n    # REASONING: Validate that input_list is not None and is a list\n    if input_list is None:\n        raise ValueError('input_list cannot be None')\n    if not isinstance(input_list, list):\n        raise ValueError('input_list must be a list')\n    # REASONING: Handle empty list case\n    if len(input_list) == 0:\n        return []\n    sanitized = []\n    # REASONING: Iterate over elements with try/except to catch non-numeric types\n    for idx, item in enumerate(input_list):\n        try:\n            # REASONING: bool is subclass of int, but we treat bool as numeric\n            if isinstance(item, (int, float, bool)):\n                sanitized.append(item)\n            else:\n                raise TypeError\n        except TypeError:\n            raise ValueError(f'Element at index {idx} is not numeric: {item!r}')\n    # REASONING: Postcondition: sanitized list contains only numeric types\n    return sanitized\n\ndef filter_positive_numbers(numbers):\n    # REASONING: Validate that numbers is an iterable\n    if not hasattr(numbers, '__iter__'):\n        raise TypeError('numbers must be an iterable of int or float')\n    positives = []\n    try:\n        for idx, num in enumerate(numbers):\n            # REASONING: Ensure each element is numeric\n            if not isinstance(num, (int, float)):\n                raise TypeError(f'Element at index {idx} is not numeric')\n            # REASONING: Filter positive numbers\n            if num > 0:\n                positives.append(num)\n    except TypeError as e:\n        # REASONING: Re-raise TypeError with context\n        raise\n    except Exception as e:\n        # REASONING: Log unexpected errors and re-raise\n        import logging\n        logging.exception('Unexpected error while filtering positive numbers')\n        raise\n    # REASONING: Assert postcondition that all elements are positive\n    assert all(isinstance(x, (int, float)) and x > 0 for x in positives), 'Postcondition failed: non-positive value in result'\n    return positives\n\nimport logging\n\n# Configure a basic logger for optional debugging\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\ndef format_output(positives):\n    # REASONING: Validate that the input is a list to avoid attribute errors later\n    if not isinstance(positives, list):\n        raise TypeError(\"positives must be a list\")\n\n    # REASONING: Ensure every element is numeric; this prevents type errors during filtering\n    for idx, val in enumerate(positives):\n        if not isinstance(val, (int, float)):\n            raise ValueError(f\"Element at index {idx} is not a number\")\n\n    # REASONING: Handle the edge case where the list is empty; return an empty list immediately\n    if not positives:\n        logger.info(\"Received an empty list; returning empty output.\")\n        return []\n\n    # REASONING: Attempt to filter positives; wrap in try/except to catch unforeseen errors\n    try:\n        result = [v for v in positives if v > 0]\n    except Exception as e:\n        # REASONING: If filtering fails, raise a runtime error with context\n        raise RuntimeError(\"Error processing positives\") from e\n\n    # REASONING: Postcondition assertion ensures the function returns a list\n    assert isinstance(result, list), \"Result is not a list\"\n    return result\n\n\ndef get_positive(l) -> Any:\n    \"\"\"\n    Main function that integrates all modular components to solve the problem.\n    Generated by Modular ToT Self-Reflective Architecture.\n    \"\"\"\n    # Module execution chain\n    processed = sanitize_input(l)\n    processed = filter_positive_numbers(processed)\n    return format_output(processed)\n",
          "tests_passed": 4,
          "total_tests": 4,
          "time": 1797.3382773399353,
          "iterations_used": 1
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "is_prime",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import Any\n\ndef validate_input_is_integer_and_positive(n: Any) -> int:\n    \"\"\"Validate that n is an integer greater than or equal to 1.\"\"\"\n    if not isinstance(n, int):\n        raise ValueError(f\"Input must be an integer, got {type(n).__name__}\")\n    if n < 1:\n        raise ValueError(f\"Input must be >= 1, got {n}\")\n    return n\n\ndef is_prime_core(n: int) -> bool:\n    \"\"\"Return True if n is prime, False otherwise.\"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0:\n        return False\n    limit = int(n**0.5) + 1\n    i = 3\n    while i <= limit:\n        if n % i == 0:\n            return False\n        i += 2\n    return True\n\ndef is_prime(n: Any) -> bool:\n    \"\"\"Main function that integrates validation and core logic.\"\"\"\n    n = validate_input_is_integer_and_positive(n)\n    return is_prime_core(n)",
          "tests_passed": 13,
          "total_tests": 13,
          "time": 295.0250060558319,
          "iterations_used": 2
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "poly",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import List, Any, Optional, Union, Tuple, Dict\n\ndef validate_coefficients(coeffs):\n    import logging\n    logger = logging.getLogger(__name__)\n    # REASONING: Assert that coeffs is a list or tuple\n    assert isinstance(coeffs, (list, tuple)), 'coeffs must be a list or tuple'\n    # REASONING: Check for empty list\n    if len(coeffs) == 0:\n        logger.debug('coeffs is empty')\n        return False\n    # REASONING: Check for even length\n    if len(coeffs) % 2 != 0:\n        logger.debug('coeffs length is odd')\n        return False\n    # REASONING: Validate each coefficient\n    try:\n        for idx, c in enumerate(coeffs):\n            # REASONING: Ensure numeric type\n            if not isinstance(c, (int, float)):\n                logger.debug(f'non-numeric element at index {idx}: {c}')\n                return False\n            # REASONING: Check for NaN or infinite values\n            if isinstance(c, float):\n                if c != c or c == float('inf') or c == float('-inf'):\n                    logger.debug(f'invalid float at index {idx}: {c}')\n                    return False\n    except Exception as e:\n        # REASONING: Any exception during iteration invalidates the list\n        logger.exception('Exception during coefficient validation')\n        return False\n    # REASONING: Ensure at least one non-zero coefficient\n    if all(c == 0 for c in coeffs):\n        logger.debug('all coefficients are zero')\n        return False\n    # REASONING: All checks passed\n    return True\n\ndef find_real_root(coeffs):\n    # REASONING: Validate that coeffs is a non-empty list or tuple of numeric types\n    if not isinstance(coeffs, (list, tuple)):\n        raise TypeError(\"coeffs must be a list or tuple of numbers\")\n    if len(coeffs) == 0:\n        raise ValueError(\"coeffs cannot be empty\")\n    for i, c in enumerate(coeffs):\n        if not isinstance(c, (int, float, complex)):\n            raise TypeError(f\"Coefficient at index {i} is not numeric\")\n    # REASONING: Handle constant polynomial cases explicitly\n    if len(coeffs) == 1:\n        if coeffs[0] == 0:\n            raise ValueError(\"Zero polynomial has infinitely many roots\")\n        else:\n            raise ValueError(\"Constant polynomial has no roots\")\n    # REASONING: Compute polynomial roots using numpy.roots with error handling\n    try:\n        import numpy as np\n        roots = np.roots(coeffs)\n    except Exception as e:\n        raise RuntimeError(f\"Failed to compute roots: {e}\") from e\n    # REASONING: Filter roots that are effectively real within a tolerance\n    real_roots = [r.real for r in roots if abs(r.imag) < 1e-8]\n    if not real_roots:\n        raise ValueError(\"No real roots found\")\n    # REASONING: Return the first real root as a float\n    return float(real_roots[0])\n\ndef format_root(root, precision):\n    '''\n    Round the root to the specified precision and return as float.\n    Handles formatting errors and edge cases.\n    '''\n    # REASONING: Set up logger for debugging\n    import logging\n    logger = logging.getLogger(__name__)\n\n    # REASONING: Validate root type\n    if not isinstance(root, (int, float)):\n        logger.error('root is not a number: %r', root)\n        raise TypeError('root must be an int or float')\n\n    # REASONING: Validate precision type\n    if not isinstance(precision, int):\n        logger.error('precision is not an integer: %r', precision)\n        raise TypeError('precision must be an integer')\n\n    # REASONING: Validate precision non-negative\n    if precision < 0:\n        logger.error('precision is negative: %d', precision)\n        raise ValueError('precision must be non-negative')\n\n    # REASONING: Check for NaN or infinite root\n    import math\n    if math.isnan(root) or math.isinf(root):\n        logger.error('root is NaN or infinite: %r', root)\n        raise ValueError('root cannot be NaN or infinite')\n\n    # REASONING: Perform rounding with error handling\n    try:\n        result = round(root, precision)\n    except Exception as e:\n        logger.exception('Error rounding root')\n        raise ValueError('Error rounding root') from e\n\n    # REASONING: Ensure result is float\n    assert isinstance(result, float), 'result is not a float'\n\n    return result\n\n\ndef poly(xs, x) -> Any:\n    \"\"\"\n    Main function that integrates all modular components to solve the problem.\n    Generated by Modular ToT Self-Reflective Architecture.\n    \"\"\"\n    # Module execution chain\n    processed = validate_coefficients(xs)\n    processed = find_real_root(processed)\n    return format_root(processed)\n",
          "tests_passed": 0,
          "total_tests": 0,
          "time": 341.9244213104248,
          "iterations_used": 1
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "sort_third",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import List, Any, Optional, Union, Tuple, Dict\n\nimport logging\n\nlogging.basicConfig(level=logging.INFO)\n\n\ndef validate_input(input_list):\n    # REASONING: Assert precondition that input must be a list.\n    assert isinstance(input_list, list), \"input_list must be a list\"\n    # REASONING: Explicit type check to provide a clear error message.\n    if not isinstance(input_list, list):\n        raise TypeError('input_list must be a list')\n    try:\n        # REASONING: Create a shallow copy to avoid mutating the original list.\n        sanitized = list(input_list)\n        # REASONING: If the list is empty, return it immediately (fallback logic).\n        if not sanitized:\n            return sanitized\n        # REASONING: Basic sanitization: remove None values to prevent downstream errors.\n        sanitized = [item for item in sanitized if item is not None]\n        # REASONING: Assert postcondition that the result is a list.\n        assert isinstance(sanitized, list), 'sanitized output must be a list'\n        return sanitized\n    except Exception as e:\n        # REASONING: Catch unexpected errors and raise a ValueError with context.\n        raise ValueError('An error occurred while sanitizing the input list') from e\n\nimport logging\n\nlogging.basicConfig(level=logging.WARNING)\n\ndef sort_third_core(input_list):\n    # REASONING: Validate that the input is a list to avoid attribute errors later.\n    if not isinstance(input_list, list):\n        raise TypeError('input_list must be a list')\n    # REASONING: If the list is empty, nothing to sort; return it as is.\n    if len(input_list) == 0:\n        return []\n    # REASONING: Determine indices divisible by three.\n    indices = [i for i in range(len(input_list)) if i % 3 == 0]\n    # REASONING: Extract elements at those indices.\n    elements_to_sort = [input_list[i] for i in indices]\n    # REASONING: Attempt to sort the extracted elements, handling non-comparable types.\n    try:\n        sorted_elements = sorted(elements_to_sort)\n    except TypeError as e:\n        # REASONING: Sorting failed due to non-comparable elements; fallback to original list.\n        logging.warning('Sorting failed due to non-comparable elements: %s', e)\n        return input_list[:]\n    # REASONING: Reconstruct the list with sorted elements at the correct positions.\n    result = input_list[:]\n    for idx, val in zip(indices, sorted_elements):\n        result[idx] = val\n    # REASONING: Postcondition: length preserved and sorted elements at indices divisible by three.\n    assert len(result) == len(input_list), 'Output length mismatch'\n    return result\n\ndef format_output(result):\n    # REASONING: Validate that result is a list\n    if not isinstance(result, list):\n        raise TypeError('result must be a list')\n    # REASONING: If result is an exception instance, propagate it\n    if isinstance(result, Exception):\n        raise result\n    # REASONING: Attempt to sort the list, handling non-comparable elements\n    try:\n        sorted_result = sorted(result)\n    except TypeError as e:\n        raise ValueError('Elements in result are not comparable') from e\n    finally:\n        # Optional logging could be added here\n        pass\n    # REASONING: Assert that the output is a list and sorted\n    assert isinstance(sorted_result, list)\n    assert sorted_result == sorted(sorted_result)\n    return sorted_result\n\n\ndef sort_third(l) -> Any:\n    \"\"\"\n    Main function that integrates all modular components to solve the problem.\n    Generated by Modular ToT Self-Reflective Architecture.\n    \"\"\"\n    # Module execution chain\n    processed = validate_input(l)\n    processed = sort_third_core(processed)\n    return format_output(processed)\n",
          "tests_passed": 0,
          "total_tests": 0,
          "time": 1223.2101781368256,
          "iterations_used": 1
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "unique",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import List, Any, Optional, Union, Tuple, Dict\n\nimport logging\n\n\ndef validate_and_sanitize_input(input_list):\n    # REASONING: Configure logger for debugging and tracing\n    logger = logging.getLogger(__name__)\n    # REASONING: Handle None input by returning an empty list as a graceful fallback\n    if input_list is None:\n        logger.debug(\"Input is None, returning empty list.\")\n        return []\n    # REASONING: Ensure the input is a list; otherwise raise a TypeError to signal misuse\n    if not isinstance(input_list, list):\n        logger.error(f\"Expected list, got {type(input_list).__name__}\")\n        raise TypeError(\"input_list must be a list\")\n    # REASONING: Verify that every element in the list is hashable\n    try:\n        for idx, item in enumerate(input_list):\n            # REASONING: Attempt to hash each item; a TypeError indicates non-hashability\n            hash(item)\n    except TypeError as e:\n        logger.error(f\"Non-hashable element at index {idx}: {item!r}\")\n        raise TypeError(f\"All elements must be hashable. Problem at index {idx}\") from e\n    # REASONING: All checks passed; return the original list unchanged\n    assert isinstance(input_list, list), \"Postcondition: output is a list\"\n    assert len(input_list) == len(input_list), \"Invariant: length preserved\"\n    return input_list\n\nimport logging\nlogging.basicConfig(level=logging.DEBUG)\n\ndef compute_unique_sorted(elements):\n    # REASONING: Validate that the input is a list to satisfy precondition.\n    if not isinstance(elements, list):\n        raise TypeError(\"Input must be a list.\")\n    # REASONING: Handle empty list early to avoid unnecessary processing.\n    if len(elements) == 0:\n        return []\n    # REASONING: Ensure all elements are hashable before adding to a set.\n    try:\n        hashable_elements = [e for e in elements]\n    except TypeError as e:\n        raise TypeError(\"All elements must be hashable.\") from e\n    # REASONING: Use a set to deduplicate elements.\n    try:\n        unique_set = set(hashable_elements)\n    except Exception as e:\n        raise RuntimeError(\"Failed to create set of elements.\") from e\n    # REASONING: Sort the unique elements to produce deterministic order.\n    try:\n        sorted_list = sorted(unique_set)\n    except Exception as e:\n        raise RuntimeError(\"Failed to sort elements.\") from e\n    # REASONING: Assert that the output is sorted and contains unique items.\n    assert sorted_list == sorted(set(sorted_list)), \"Output is not sorted or contains duplicates.\"\n    return sorted_list\n\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n\ndef format_unique_output(unique_elements):\n    \"\"\"Return a sorted list of unique elements from the input iterable.\n\n    The function performs extensive defensive checks to ensure robustness in\n    production environments. It handles None input, non-iterable values,\n    unhashable elements, and incomparable types gracefully.\n    \"\"\"\n    # REASONING: Handle None as an empty input.\n    if unique_elements is None:\n        logger.debug(\"Input is None; returning empty list.\")\n        return []\n\n    # REASONING: Validate that the input is iterable.\n    try:\n        iterator = iter(unique_elements)\n    except TypeError:\n        raise TypeError(\"unique_elements must be an iterable or None\") from None\n\n    # REASONING: Convert to list to allow multiple passes and to capture\n    # any lazy evaluation side effects.\n    try:\n        elements_list = list(unique_elements)\n    except Exception as e:\n        raise ValueError(\"Failed to convert unique_elements to list\") from e\n\n    # REASONING: Deduplicate using a set; this requires elements to be hashable.\n    try:\n        unique_set = set(elements_list)\n    except TypeError as e:\n        raise TypeError(\"Elements must be hashable to deduplicate\") from e\n\n    # REASONING: Sort the unique elements; this requires elements to be comparable.\n    try:\n        sorted_unique = sorted(unique_set)\n    except TypeError as e:\n        raise TypeError(\"Elements must be comparable to sort\") from e\n\n    # REASONING: Assert that the output is a list.\n    assert isinstance(sorted_unique, list), \"Output is not a list\"\n\n    # REASONING: Assert that the list is sorted in ascending order.\n    for i in range(len(sorted_unique) - 1):\n        assert sorted_unique[i] <= sorted_unique[i + 1], \"Output is not sorted\"\n\n    logger.debug(\"Successfully formatted unique output: %s\", sorted_unique)\n    return sorted_unique\n\n\ndef unique(l) -> Any:\n    \"\"\"\n    Main function that integrates all modular components to solve the problem.\n    Generated by Modular ToT Self-Reflective Architecture.\n    \"\"\"\n    # Module execution chain\n    processed = validate_and_sanitize_input(l)\n    processed = compute_unique_sorted(processed)\n    return format_unique_output(processed)\n",
          "tests_passed": 1,
          "total_tests": 1,
          "time": 299.1014127731323,
          "iterations_used": 1
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "max_element",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import List, Any, Optional, Union, Tuple, Dict\n\ndef validate_and_sanitize_input(raw_list):\n    '''\n    Validate that raw_list is a non-empty list of numeric values.\n    Flatten nested lists, remove None, and ensure all elements are numeric.\n    Returns a sanitized list of numeric values.\n    '''\n    import logging\n    logging.basicConfig(level=logging.DEBUG)\n    # REASONING: Ensure raw_list is a list\n    if not isinstance(raw_list, list):\n        logging.error('Input is not a list')\n        raise TypeError('Input must be a list')\n    # REASONING: Input must not be empty\n    if len(raw_list) == 0:\n        logging.error('Input list is empty')\n        raise ValueError('Input list must not be empty')\n    # REASONING: Flatten nested lists\n    def _flatten(lst):\n        flat = []\n        for item in lst:\n            if isinstance(item, list):\n                flat.extend(_flatten(item))\n            else:\n                flat.append(item)\n        return flat\n    try:\n        flat_list = _flatten(raw_list)\n    except Exception as e:\n        logging.exception('Error during flattening')\n        raise ValueError('Error processing input list') from e\n    # REASONING: Validate each element\n    sanitized = []\n    for elem in flat_list:\n        if elem is None:\n            logging.warning('Found None value, skipping')\n            continue\n        if isinstance(elem, (int, float)) and not isinstance(elem, bool):\n            sanitized.append(elem)\n        else:\n            logging.error(f'Non-numeric element encountered: {elem}')\n            raise ValueError(f'Non-numeric element encountered: {elem}')\n    # REASONING: Ensure sanitized list is not empty after filtering\n    if not sanitized:\n        logging.error('No numeric values found after sanitization')\n        raise ValueError('No numeric values found in input')\n    # REASONING: Postcondition: return list of numeric values\n    assert isinstance(sanitized, list), 'Output is not a list'\n    assert all(isinstance(x, (int, float)) for x in sanitized), 'Output contains non-numeric'\n    return sanitized\n\ndef find_maximum(numbers):\n    # REASONING: Validate input type and content\n    if not isinstance(numbers, (list, tuple)):\n        raise TypeError('Input must be a list or tuple of numbers.')\n    if len(numbers) == 0:\n        raise ValueError('Input list cannot be empty.')\n    # REASONING: Ensure all elements are numeric\n    for idx, num in enumerate(numbers):\n        if not isinstance(num, (int, float)):\n            raise TypeError(f'Element at index {idx} is not numeric.')\n    # REASONING: Use try/except to catch unexpected errors during max calculation\n    try:\n        max_value = numbers[0]\n        for num in numbers[1:]:\n            if num > max_value:\n                max_value = num\n    except Exception as e:\n        # Fallback: use built-in max if custom logic fails\n        try:\n            max_value = max(numbers)\n        except Exception as inner_e:\n            raise RuntimeError('Failed to compute maximum.') from inner_e\n    # REASONING: Postcondition: max_value is numeric and in the original list\n    assert isinstance(max_value, (int, float)), 'Result is not numeric.'\n    assert max_value in numbers, 'Result not in input list.'\n    return max_value\n\nimport logging\n\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.DEBUG)\n\n\ndef format_output(max_value):\n    \"\"\"Return the maximum value or an error message if computation failed.\"\"\"\n    # REASONING: Validate that max_value is not None\n    if max_value is None:\n        logger.debug(\"max_value is None\")\n        return \"Error: max_value is None\"\n    # REASONING: Validate that max_value is a numeric type\n    if not isinstance(max_value, (int, float)):\n        logger.debug(\"max_value is not a number: %s\", max_value)\n        return \"Error: max_value is not a number\"\n    try:\n        # REASONING: Assert that max_value is numeric (redundant but defensive)\n        assert isinstance(max_value, (int, float)), \"max_value must be numeric\"\n        # REASONING: Compute the maximum value (trivial in this context)\n        result = max_value\n        # REASONING: Assert that the result is numeric\n        assert isinstance(result, (int, float)), \"Result must be numeric\"\n        return result\n    except AssertionError as ae:\n        # REASONING: Handle assertion failures gracefully\n        logger.error(\"AssertionError: %s\", ae)\n        return f\"Error: {ae}\"\n    except Exception as e:\n        # REASONING: Handle unexpected errors\n        logger.error(\"Unexpected error: %s\", e)\n        return f\"Error: {e}\"\n\n\ndef max_element(l) -> Any:\n    \"\"\"\n    Main function that integrates all modular components to solve the problem.\n    Generated by Modular ToT Self-Reflective Architecture.\n    \"\"\"\n    # Module execution chain\n    processed = validate_and_sanitize_input(l)\n    processed = find_maximum(processed)\n    return format_output(processed)\n",
          "tests_passed": 2,
          "total_tests": 2,
          "time": 341.57493805885315,
          "iterations_used": 1
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "fizz_buzz",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import List, Any, Optional, Union, Tuple, Dict\n\nimport logging\n\nlogging.basicConfig(level=logging.DEBUG)\nlogger = logging.getLogger(__name__)\n\ndef validate_n_input(n):\n    # REASONING: Wrap validation logic in a try block to catch unexpected errors\n    try:\n        logger.debug('Starting validation for n=%s', n)\n        # REASONING: Assert that n is an integer (precondition)\n        assert isinstance(n, int), 'Precondition: n must be an integer'\n        # REASONING: Check that n is non-negative\n        if n < 0:\n            raise ValueError('n must be non-negative')\n        # REASONING: Postcondition: n is an integer and >= 0\n        assert n >= 0, 'Postcondition: n must be non-negative'\n        logger.debug('Validation successful, returning %s', n)\n        return n\n    except AssertionError as e:\n        # REASONING: Convert assertion failures to ValueError for consistency\n        logger.error('AssertionError: %s', e)\n        raise ValueError(str(e)) from e\n    except Exception as e:\n        # REASONING: Handle any other unexpected exceptions\n        logger.exception('Unexpected error during validation')\n        raise RuntimeError('Unexpected error during validation') from e\n\nimport logging\n\nlogging.basicConfig(level=logging.INFO)\n\ndef count_sevens_in_divisible_numbers(n):\n    # REASONING: Validate that the input is an integer and non-negative\n    if not isinstance(n, int):\n        raise TypeError('n must be an integer')\n    assert n >= 0, 'n must be non-negative'\n    # REASONING: If n is 0 or 1, there are no numbers to evaluate\n    if n <= 1:\n        return 0\n    total_sevens = 0\n    try:\n        # REASONING: Iterate over each candidate number\n        for i in range(1, n):\n            # REASONING: Only consider numbers divisible by 11 or 13\n            if i % 11 == 0 or i % 13 == 0:\n                # REASONING: Count occurrences of the digit '7' in the decimal representation\n                total_sevens += str(i).count('7')\n    except Exception as e:\n        # REASONING: Log the exception for debugging and re-raise a more specific error\n        logging.exception('Unexpected error during counting')\n        raise RuntimeError('Failed to count sevens') from e\n    # REASONING: Ensure the result is a non-negative integer\n    assert isinstance(total_sevens, int) and total_sevens >= 0\n    return total_sevens\n\nimport logging\n\n\ndef format_fizz_buzz_result(count):\n    # REASONING: Validate that the input is an integer\n    if not isinstance(count, int):\n        raise TypeError('count must be an integer')\n    # REASONING: Ensure the count is non-negative\n    if count < 0:\n        raise ValueError('count must be non-negative')\n    # REASONING: Handle the zero edge case explicitly\n    if count == 0:\n        return 0\n    # REASONING: Log a warning if the integer is extremely large\n    if count > 10**18:\n        logging.warning('count is a very large integer')\n    # REASONING: Main logic wrapped in try/except to catch unforeseen errors\n    try:\n        result = count\n        # REASONING: Assert that the result is an integer and matches the input\n        assert isinstance(result, int), 'Result is not an integer'\n        assert result == count, 'Result does not match input'\n        return result\n    except Exception as e:\n        # REASONING: Log the exception and provide a safe fallback value\n        logging.exception('Unexpected error in format_fizz_buzz_result')\n        return 0\n\n\ndef fizz_buzz(n) -> Any:\n    \"\"\"\n    Main function that integrates all modular components to solve the problem.\n    Generated by Modular ToT Self-Reflective Architecture.\n    \"\"\"\n    # Module execution chain\n    processed = validate_n_input(n)\n    processed = count_sevens_in_divisible_numbers(processed)\n    return format_fizz_buzz_result(processed)\n",
          "tests_passed": 8,
          "total_tests": 8,
          "time": 691.9101157188416,
          "iterations_used": 1
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "sort_even",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import List, Any, Optional, Union, Tuple, Dict\n\ndef validate_and_sanitize_input(input_list):\n    \"\"\"\n    Validates that input_list is a list of comparable elements and returns a clean copy.\n    \"\"\"\n    # REASONING: Ensure input is a list\n    assert isinstance(input_list, list), \"input_list must be a list\"\n    # REASONING: Handle empty list early\n    if len(input_list) == 0:\n        return []\n    # REASONING: Check comparability by attempting to sort\n    try:\n        _ = sorted(input_list)\n    except TypeError as e:\n        # REASONING: Elements are not comparable\n        raise ValueError(\"All elements in input_list must be comparable\") from e\n    # REASONING: Return a shallow copy to avoid side effects\n    result = input_list.copy()\n    # REASONING: Postcondition: result is a list and same length as input\n    assert isinstance(result, list), \"Result must be a list\"\n    assert len(result) == len(input_list), \"Result length must match input\"\n    return result\n\nimport logging\n\n# Configure basic logging for debugging purposes\nlogging.basicConfig(level=logging.INFO)\n\n\ndef sort_even_indices(clean_list):\n    \"\"\"Return a new list where elements at even indices are sorted.\n\n    Parameters:\n        clean_list (list): The input list to process.\n\n    Returns:\n        list: A new list with even-indexed elements sorted.\n    \"\"\"\n    # REASONING: Validate that the input is a list to avoid attribute errors.\n    if not isinstance(clean_list, list):\n        raise TypeError(\"Input must be a list\")\n\n    # REASONING: Handle trivial cases early to avoid unnecessary work.\n    if len(clean_list) <= 1:\n        return clean_list.copy()\n\n    try:\n        # REASONING: Extract even-indexed elements for sorting.\n        even_elements = [clean_list[i] for i in range(0, len(clean_list), 2)]\n        # REASONING: Sort the extracted elements; this may raise TypeError if elements are not comparable.\n        sorted_even = sorted(even_elements)\n    except TypeError as e:\n        # REASONING: Provide a clear error message and log the exception for debugging.\n        logging.exception(\"Elements in the list are not comparable for sorting\")\n        raise ValueError(\"All elements must be comparable for sorting\") from e\n\n    # REASONING: Build the result list by copying the original to preserve odd indices.\n    result = clean_list.copy()\n    for idx, val in zip(range(0, len(clean_list), 2), sorted_even):\n        result[idx] = val\n\n    # REASONING: Assertions to ensure postconditions are met.\n    assert len(result) == len(clean_list), \"Length of result differs from input\"\n    for i in range(1, len(clean_list), 2):\n        assert result[i] == clean_list[i], f\"Odd index {i} was altered\"\n    even_vals = [result[i] for i in range(0, len(result), 2)]\n    assert even_vals == sorted(even_vals), \"Even indices are not sorted\"\n\n    return result\n\nimport logging\n\n# Configure a module-level logger\nlogger = logging.getLogger(__name__)\n\n\ndef format_output(result_list):\n    \"\"\"Wraps the result for consistency and handles unexpected errors.\n\n    Parameters:\n        result_list (list): The list to process.\n\n    Returns:\n        list: A list of strings representing the processed items or an error message.\n    \"\"\"\n    # REASONING: Validate that the input is a list to avoid type errors later.\n    if not isinstance(result_list, list):\n        # REASONING: Return a clear error message instead of raising an exception.\n        error_msg = f\"Input must be a list, got {type(result_list).__name__}\"\n        logger.error(error_msg)\n        return [error_msg]\n\n    # REASONING: Handle the trivial case of an empty list early.\n    if len(result_list) == 0:\n        return []\n\n    # REASONING: Prepare the output list and process each element.\n    output = []\n    try:\n        for idx, item in enumerate(result_list):\n            try:\n                # REASONING: Convert each item to string; this is safe for most types.\n                output.append(str(item))\n            except Exception as conv_err:\n                # REASONING: If conversion fails, capture the error context.\n                err_msg = f\"Error converting item at index {idx}: {conv_err}\"\n                logger.exception(err_msg)\n                output.append(err_msg)\n        # REASONING: Assert that all output items are strings to satisfy postcondition.\n        assert all(isinstance(x, str) for x in output), \"All output items must be strings\"\n        return output\n    except Exception as e:\n        # REASONING: Catch any unexpected errors and return a descriptive message.\n        err_msg = f\"Unexpected error: {e}\"\n        logger.exception(err_msg)\n        return [err_msg]\n\n\n\ndef sort_even(l) -> Any:\n    \"\"\"\n    Main function that integrates all modular components to solve the problem.\n    Generated by Modular ToT Self-Reflective Architecture.\n    \"\"\"\n    # Module execution chain\n    processed = validate_and_sanitize_input(l)\n    processed = sort_even_indices(processed)\n    return format_output(processed)\n",
          "tests_passed": 0,
          "total_tests": 0,
          "time": 566.6130127906799,
          "iterations_used": 1
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "encode_cyclic",
      "samples": [
        {
          "sample_id": 1,
          "passed": false,
          "solution": "def encode_cyclic(s: str) -> str:\n    \"\"\"\n    Encode the input string by splitting it into groups of three characters\n    and rotating each group to the left by one position. Groups with fewer\n    than three characters are left unchanged.\n    \"\"\"\n    if not isinstance(s, str):\n        raise TypeError(\"Input must be a string\")\n    if len(s) < 3:\n        return s\n    encoded_parts = []\n    for i in range(0, len(s) - len(s) % 3, 3):\n        group = s[i:i+3]\n        encoded_parts.append(group[1:] + group[0])\n    # Append any remaining characters that don't form a full group\n    if len(s) % 3:\n        encoded_parts.append(s[-(len(s) % 3):])\n    return \"\".join(encoded_parts)\n\ndef decode_cyclic(s: str) -> str:\n    \"\"\"\n    Decode a string that was encoded with `encode_cyclic`. The decoding\n    process reverses the left rotation of each three\u2011character group.\n    Groups with fewer than three characters are left unchanged.\n    \"\"\"\n    if not isinstance(s, str):\n        raise TypeError(\"Input must be a string\")\n    if len(s) < 3:\n        return s\n    decoded_parts = []\n    for i in range(0, len(s) - len(s) % 3, 3):\n        group = s[i:i+3]\n        decoded_parts.append(group[2] + group[:2])\n    # Append any remaining characters that don't form a full group\n    if len(s) % 3:\n        decoded_parts.append(s[-(len(s) % 3):])\n    return \"\".join(decoded_parts)",
          "tests_passed": 0,
          "total_tests": 1,
          "time": 791.4568600654602,
          "iterations_used": 3
        }
      ],
      "num_passed": 0,
      "num_samples": 1
    },
    {
      "problem": "prime_fib",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import List, Any, Optional, Union, Tuple, Dict\n\ndef validate_and_sanitize_input(n):\n    \"\"\"\n    Validates that n is a positive integer.\n    Raises ValueError or TypeError if validation fails.\n    Returns the integer n if valid.\n    \"\"\"\n    # REASONING: Use try block to catch unexpected errors\n    try:\n        # REASONING: Check for None explicitly\n        if n is None:\n            raise ValueError(\"Input cannot be None.\")\n        # REASONING: Ensure type is int\n        if not isinstance(n, int):\n            raise TypeError(f\"Input must be an integer, got {type(n).__name__}.\")\n        # REASONING: Ensure positive\n        if n <= 0:\n            raise ValueError(\"Input must be a positive integer.\")\n        # REASONING: Assertion for precondition\n        assert isinstance(n, int), \"Precondition failed: n is not int\"\n        assert n > 0, \"Precondition failed: n is not positive\"\n        # REASONING: Postcondition assertion\n        result = n\n        assert isinstance(result, int) and result > 0, \"Postcondition failed\"\n        return result\n    except (ValueError, TypeError) as e:\n        # REASONING: Re-raise with context\n        raise\n    except Exception as e:\n        # REASONING: Catch-all for unforeseen errors\n        raise RuntimeError(\"Unexpected error during validation.\") from e\n\ndef find_nth_prime_fibonacci(n):\n    # REASONING: Validate input type and value\n    if not isinstance(n, int):\n        raise TypeError('n must be an integer')\n    if n < 1:\n        raise ValueError('n must be >= 1')\n    # REASONING: Assert precondition\n    assert n >= 1, 'Precondition failed: n must be >= 1'\n    # REASONING: Setup logging\n    import logging\n    logger = logging.getLogger(__name__)\n    logger.setLevel(logging.INFO)\n    # REASONING: Define deterministic Miller-Rabin for 64-bit integers\n    def is_prime(num):\n        # REASONING: Handle small numbers\n        if num < 2:\n            return False\n        small_primes = [2,3,5,7,11,13,17,19,23,29]\n        for p in small_primes:\n            if num % p == 0:\n                return num == p\n        # REASONING: Miller-Rabin bases for 64-bit\n        d = num - 1\n        s = 0\n        while d % 2 == 0:\n            d //= 2\n            s += 1\n        # bases chosen for deterministic test up to 2^64\n        for a in [2, 325, 9375, 28178, 450775, 9780504, 1795265022]:\n            if a % num == 0:\n                continue\n            x = pow(a, d, num)\n            if x == 1 or x == num - 1:\n                continue\n            for _ in range(s - 1):\n                x = pow(x, 2, num)\n                if x == num - 1:\n                    break\n            else:\n                return False\n        return True\n    # REASONING: Generate Fibonacci numbers iteratively\n    a, b = 0, 1\n    count = 0\n    max_iterations = 1000000\n    iterations = 0\n    try:\n        while count < n:\n            a, b = b, a + b\n            iterations += 1\n            if iterations > max_iterations:\n                raise RuntimeError('Exceeded maximum iterations while searching for prime Fibonacci numbers')\n            if is_prime(a):\n                count += 1\n                logger.info(f'Found {count}th prime Fibonacci: {a}')\n        # REASONING: Postcondition: result is prime\n        assert is_prime(a), 'Postcondition failed: result is not prime'\n        return a\n    except Exception as e:\n        # REASONING: Wrap any exception into RuntimeError with context\n        raise RuntimeError('Failed to find the nth prime Fibonacci number') from e\n\ndef format_prime_fibonacci_result(result):\n    try:\n        # REASONING: Handle None input by returning a safe default\n        if result is None:\n            return 0\n        # REASONING: Ensure the input is an integer\n        if not isinstance(result, int):\n            raise TypeError('result must be an integer')\n        # REASONING: Negative values are unexpected; return 0 as fallback\n        if result < 0:\n            return 0\n        # REASONING: Postcondition: result is a non-negative integer\n        assert isinstance(result, int)\n        assert result >= 0\n        return result\n    except Exception:\n        # REASONING: Catch any unforeseen errors and return a safe default\n        return 0\n\n\ndef prime_fib(n) -> Any:\n    \"\"\"\n    Main function that integrates all modular components to solve the problem.\n    Generated by Modular ToT Self-Reflective Architecture.\n    \"\"\"\n    # Module execution chain\n    processed = validate_and_sanitize_input(n)\n    processed = find_nth_prime_fibonacci(processed)\n    return format_prime_fibonacci_result(processed)\n",
          "tests_passed": 10,
          "total_tests": 10,
          "time": 2407.799614906311,
          "iterations_used": 1
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "triples_sum_to_zero",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import List\n\ndef validate_input(l: List[int]) -> List[int]:\n    \"\"\"\n    Validate that the input is a list of integers.\n    Raises a TypeError if the input is not a list,\n    or a ValueError if any element is not an integer.\n    \"\"\"\n    if not isinstance(l, list):\n        raise TypeError(\"Input must be a list.\")\n    if not all(isinstance(x, int) for x in l):\n        raise ValueError(\"All elements must be integers.\")\n    return l\n\ndef find_triplet_sum_to_zero(l: List[int]) -> bool:\n    \"\"\"\n    Return True if there exist three distinct elements in the list that sum to zero.\n    Uses a sorted two\u2011pointer approach for O(n\u00b2) time complexity.\n    \"\"\"\n    if len(l) < 3:\n        return False\n    sorted_l = sorted(l)\n    n = len(sorted_l)\n    for i in range(n - 2):\n        left, right = i + 1, n - 1\n        while left < right:\n            s = sorted_l[i] + sorted_l[left] + sorted_l[right]\n            if s == 0:\n                return True\n            elif s < 0:\n                left += 1\n            else:\n                right -= 1\n    return False\n\ndef triples_sum_to_zero(l: List[int]) -> bool:\n    \"\"\"\n    triples_sum_to_zero takes a list of integers as an input.\n    It returns True if there are three distinct elements in the list that\n    sum to zero, and False otherwise.\n\n    >>> triples_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> triples_sum_to_zero([1, 3, -2, 1])\n    True\n    >>> triples_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n    True\n    >>> triples_sum_to_zero([1])\n    False\n    \"\"\"\n    try:\n        processed = validate_input(l)\n    except Exception:\n        return False\n    return find_triplet_sum_to_zero(processed)",
          "tests_passed": 9,
          "total_tests": 9,
          "time": 6010.805943965912,
          "iterations_used": 2
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "car_race_collision",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import Any\n\ndef validate_and_sanitize_input(n):\n    \"\"\"\n    Validate that `n` is a non\u2011negative integer.\n    \"\"\"\n    if n is None:\n        raise TypeError(\"Input cannot be None\")\n    if isinstance(n, bool):\n        raise TypeError(\"Boolean input not allowed\")\n    if isinstance(n, int):\n        n_int = n\n    elif isinstance(n, float):\n        if not n.is_integer():\n            raise ValueError(\"Float input must represent an integer\")\n        n_int = int(n)\n    elif isinstance(n, str):\n        if not n.strip().isdigit():\n            raise ValueError(\"String input must represent a non\u2011negative integer\")\n        n_int = int(n)\n    else:\n        raise TypeError(\"Unsupported type\")\n\n    if n_int < 0:\n        raise ValueError(\"Input must be non\u2011negative\")\n    return n_int\n\ndef compute_collisions(n: int) -> int:\n    \"\"\"\n    Compute the number of collisions between two sets of `n` cars moving in opposite directions.\n    Each left\u2011to\u2011right car collides with each right\u2011to\u2011left car exactly once.\n    \"\"\"\n    return n * n\n\ndef car_race_collision(n: Any) -> int:\n    \"\"\"\n    Main function that validates input and returns the number of collisions.\n    \"\"\"\n    n_int = validate_and_sanitize_input(n)\n    return compute_collisions(n_int)",
          "tests_passed": 5,
          "total_tests": 5,
          "time": 4062.761463880539,
          "iterations_used": 2
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "incr_list",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import List, Any, Optional, Union, Tuple, Dict\n\nimport logging\n\nlogger = logging.getLogger(__name__)\n\ndef validate_and_sanitize_input(raw_input):\n    '''Validate that raw_input is a list of integers and return a sanitized copy.'''\n    # REASONING: Use try block to catch unexpected errors and log them\n    try:\n        # REASONING: Ensure the input is a list\n        if not isinstance(raw_input, list):\n            raise TypeError('Input must be a list')\n        # REASONING: Empty list is a valid input; return empty list\n        if len(raw_input) == 0:\n            return []\n        # REASONING: Validate each element is an integer\n        for idx, item in enumerate(raw_input):\n            if not isinstance(item, int):\n                raise ValueError(f'Element at index {idx} is not an integer: {item!r}')\n        # REASONING: All elements are integers; create a shallow copy\n        result = list(raw_input)\n        # REASONING: Postcondition: result contains only integers\n        assert all(isinstance(x, int) for x in result), 'Result contains non-integer'\n        # REASONING: Invariant: length preserved\n        assert len(result) == len(raw_input), 'Length mismatch after sanitization'\n        return result\n    except TypeError as te:\n        logger.error('TypeError: %s', te)\n        raise\n    except ValueError as ve:\n        logger.error('ValueError: %s', ve)\n        raise\n    except Exception as e:\n        logger.exception('Unexpected error: %s', e)\n        raise\n\nimport logging\n\nlogging.basicConfig(level=logging.INFO)\n\ndef increment_elements(numbers):\n    # REASONING: Validate that input is a list\n    assert isinstance(numbers, list), 'Input must be a list'\n    # REASONING: Validate that all elements are integers\n    for idx, item in enumerate(numbers):\n        if not isinstance(item, int):\n            raise TypeError(f'Element at index {idx} is not an integer')\n    # REASONING: Handle empty list early\n    if not numbers:\n        return []\n    try:\n        # REASONING: Increment each element\n        incremented = [n + 1 for n in numbers]\n        # REASONING: Postcondition check: length preserved\n        assert len(incremented) == len(numbers), 'Output length mismatch'\n        # REASONING: Postcondition check: each element incremented by 1\n        for orig, inc in zip(numbers, incremented):\n            assert inc == orig + 1, 'Element not incremented correctly'\n        return incremented\n    except Exception as e:\n        # REASONING: Log the error and re-raise\n        logging.error('Error incrementing elements: %s', e)\n        raise\n\nimport logging\n\nlogger = logging.getLogger(__name__)\n\ndef format_output(incremented_list):\n    # REASONING: Validate that the input is a list to prevent type errors later\n    if not isinstance(incremented_list, list):\n        raise TypeError(\"incremented_list must be a list\")\n    # REASONING: Ensure each element is an integer to satisfy function contract\n    for idx, item in enumerate(incremented_list):\n        if not isinstance(item, int):\n            raise ValueError(f\"Element at index {idx} is not an int\")\n    # REASONING: Use a try block to catch unexpected errors during processing\n    try:\n        # Create a new list to avoid mutating the original\n        result = [int(x) for x in incremented_list]\n    except Exception as e:\n        # Fallback: log the exception and return an empty list\n        logger.exception(\"Failed to process incremented_list\")\n        return []\n    # REASONING: Assert that the result meets postconditions\n    assert isinstance(result, list), \"Result is not a list\"\n    assert all(isinstance(x, int) for x in result), \"Result contains non-int\"\n    return result\n\n\ndef incr_list(l) -> Any:\n    \"\"\"\n    Main function that integrates all modular components to solve the problem.\n    Generated by Modular ToT Self-Reflective Architecture.\n    \"\"\"\n    # Module execution chain\n    processed = validate_and_sanitize_input(l)\n    processed = increment_elements(processed)\n    return format_output(processed)\n",
          "tests_passed": 3,
          "total_tests": 3,
          "time": 4153.250627040863,
          "iterations_used": 1
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "pairs_sum_to_zero",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import List, Any\n\ndef validate_input(input_list: List[Any]) -> List[int]:\n    \"\"\"Ensure the input is a list of integers.\"\"\"\n    if not isinstance(input_list, list):\n        raise ValueError(\"Input must be a list\")\n    sanitized: List[int] = []\n    for idx, item in enumerate(input_list):\n        if not isinstance(item, int):\n            raise ValueError(f\"Element at index {idx} is not an integer: {item}\")\n        sanitized.append(item)\n    return sanitized\n\ndef has_pair_sum_zero(nums: List[int]) -> bool:\n    \"\"\"Return True if any two distinct elements in nums sum to zero.\"\"\"\n    if len(nums) < 2:\n        return False\n    seen = set()\n    for num in nums:\n        if -num in seen:\n            return True\n        seen.add(num)\n    return False\n\ndef pairs_sum_to_zero(l: List[Any]) -> bool:\n    \"\"\"Main function that validates input and checks for a zero-sum pair.\"\"\"\n    processed = validate_input(l)\n    return has_pair_sum_zero(processed)",
          "tests_passed": 9,
          "total_tests": 9,
          "time": 502.3887469768524,
          "iterations_used": 2
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "change_base",
      "samples": [
        {
          "sample_id": 1,
          "passed": false,
          "solution": "import logging\n\nlogger = logging.getLogger(__name__)\nlogging.basicConfig(level=logging.INFO)\n\n\ndef validate_and_sanitize_input(x, base):\n    \"\"\"\n    Validate and convert the inputs to integers.\n    Raises ValueError if the inputs are not valid.\n    Returns a tuple (x, base) of validated integers.\n    \"\"\"\n    try:\n        x_val = int(x)\n    except (TypeError, ValueError):\n        raise ValueError(\"x must be an integer\") from None\n\n    if x_val < 0:\n        raise ValueError(\"x must be non-negative\")\n\n    try:\n        base_val = int(base)\n    except (TypeError, ValueError):\n        raise ValueError(\"base must be an integer\") from None\n\n    if not (2 <= base_val <= 9):\n        raise ValueError(\"base must be between 2 and 9 inclusive\")\n\n    logger.debug(\"Validated x=%s, base=%s\", x_val, base_val)\n    return x_val, base_val\n\n\ndef convert_to_base(x, base):\n    \"\"\"\n    Convert a non\u2011negative integer x to a string representation in the given base.\n    Base must be between 2 and 36 inclusive.\n    \"\"\"\n    if not isinstance(x, int):\n        raise TypeError(\"x must be an integer\")\n    if not isinstance(base, int):\n        raise TypeError(\"base must be an integer\")\n    if base < 2 or base > 36:\n        raise ValueError(\"base must be between 2 and 36 inclusive\")\n\n    if x == 0:\n        return \"0\"\n\n    digits = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    result = []\n    while x > 0:\n        x, rem = divmod(x, base)\n        result.append(digits[rem])\n\n    return \"\".join(reversed(result))\n\n\ndef format_conversion_result(result):\n    \"\"\"\n    Return the conversion result unchanged.\n    \"\"\"\n    if not isinstance(result, str):\n        raise TypeError(f\"Expected result to be a str, got {type(result).__name__}\")\n    return result\n\n\ndef change_base(x, base):\n    \"\"\"\n    Change numerical base of input number x to base.\n    Return string representation after the conversion.\n    Base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\"\n    x_val, base_val = validate_and_sanitize_input(x, base)\n    result = convert_to_base(x_val, base_val)\n    return format_conversion_result(result)",
          "tests_passed": 6,
          "total_tests": 7,
          "time": 3277.3589231967926,
          "iterations_used": 3
        }
      ],
      "num_passed": 0,
      "num_samples": 1
    },
    {
      "problem": "triangle_area",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import Tuple, Any\n\ndef validate_triangle_inputs(a: float, h: float) -> Tuple[float, float]:\n    \"\"\"Validate that side length and height are positive real numbers.\"\"\"\n    if a is None or h is None:\n        raise ValueError(\"Side length and height must not be None.\")\n    if not isinstance(a, (int, float)) or isinstance(a, bool):\n        raise TypeError(f\"Side length must be a numeric type, got {type(a).__name__}.\")\n    if not isinstance(h, (int, float)) or isinstance(h, bool):\n        raise TypeError(f\"Height must be a numeric type, got {type(h).__name__}.\")\n    if a <= 0 or h <= 0:\n        raise ValueError(\"Side length and height must be positive and non-zero.\")\n    return float(a), float(h)\n\ndef calculate_triangle_area(a: float, h: float) -> float:\n    \"\"\"Calculate the area of a triangle given side length and height.\"\"\"\n    return (a * h) / 2.0\n\ndef triangle_area(a: Any, h: Any) -> float:\n    \"\"\"\n    Compute the area of a triangle given side length and height.\n    >>> triangle_area(5, 3)\n    7.5\n    \"\"\"\n    a_val, h_val = validate_triangle_inputs(a, h)\n    return calculate_triangle_area(a_val, h_val)",
          "tests_passed": 3,
          "total_tests": 3,
          "time": 1753.6878669261932,
          "iterations_used": 2
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "fib4",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import Any\n\ndef validate_fib4_input(n: Any) -> int:\n    \"\"\"\n    Validate that the input is a non\u2011negative integer.\n    If validation fails, raise an appropriate exception.\n    \"\"\"\n    if n is None:\n        raise ValueError(\"Input cannot be None\")\n    if not isinstance(n, int):\n        raise TypeError(f\"Input must be an integer, got {type(n).__name__}\")\n    if n < 0:\n        raise ValueError(\"Input cannot be negative\")\n    return n\n\ndef compute_fib4(n: int) -> int:\n    \"\"\"\n    Compute the n-th element of the fib4 sequence without recursion.\n    \"\"\"\n    # Base cases according to the problem statement\n    if n == 0:\n        return 0\n    if n == 1:\n        return 0\n    if n == 2:\n        return 2\n    if n == 3:\n        return 0\n\n    # Sliding window for the last four values\n    window = [0, 0, 2, 0]\n    for _ in range(4, n + 1):\n        next_val = sum(window)\n        window.pop(0)\n        window.append(next_val)\n    return window[-1]\n\ndef fib4(n: int) -> int:\n    \"\"\"\n    Main function that validates input and returns the n-th fib4 number.\n    \"\"\"\n    validated_n = validate_fib4_input(n)\n    return compute_fib4(validated_n)",
          "tests_passed": 4,
          "total_tests": 4,
          "time": 275.26852202415466,
          "iterations_used": 2
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "median",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "import sys\n\ndef median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n    if not l:\n        raise ValueError(\"median requires a non-empty list\")\n    sorted_l = sorted(l)\n    n = len(sorted_l)\n    mid = n // 2\n    if n % 2 == 1:\n        return sorted_l[mid]\n    else:\n        return (sorted_l[mid - 1] + sorted_l[mid]) / 2.0\n\ndef solve() -> None:\n    data = list(map(int, sys.stdin.read().strip().split()))\n    if not data:\n        return\n    t = data[0]\n    idx = 1\n    out_lines = []\n    for case in range(1, t + 1):\n        n = data[idx]\n        idx += 1\n        arr = data[idx:idx + n]\n        idx += n\n        out_lines.append(f\"Case #{case}: {median(arr)}\")\n    sys.stdout.write(\"\\n\".join(out_lines))\n\nif __name__ == \"__main__\":\n    solve()",
          "tests_passed": 5,
          "total_tests": 5,
          "time": 586.7634689807892,
          "iterations_used": 3
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "modp",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import Any\n\ndef validate_inputs(n: int, p: int) -> tuple[int, int]:\n    \"\"\"Validate that n and p are integers with n >= 0 and p > 0.\"\"\"\n    if not isinstance(n, int):\n        raise ValueError(\"n must be an integer\")\n    if not isinstance(p, int):\n        raise ValueError(\"p must be an integer\")\n    if n < 0:\n        raise ValueError(f\"n must be >= 0, got {n}\")\n    if p <= 0:\n        raise ValueError(f\"p must be > 0, got {p}\")\n    return n, p\n\ndef modular_pow(base: int, exponent: int, modulus: int) -> int:\n    \"\"\"Compute (base ** exponent) % modulus using binary exponentiation.\"\"\"\n    if modulus == 1:\n        return 0\n    if exponent == 0:\n        return 1 % modulus\n    result = 1\n    base %= modulus\n    exp = exponent\n    while exp > 0:\n        if exp & 1:\n            result = (result * base) % modulus\n        base = (base * base) % modulus\n        exp >>= 1\n    return result\n\ndef format_result(result: int) -> int:\n    \"\"\"Ensure the result is an integer within 32\u2011bit signed range.\"\"\"\n    if not isinstance(result, int):\n        raise TypeError(\"Result must be an integer\")\n    min_int32 = -2147483648\n    max_int32 = 2147483647\n    if result < min_int32 or result > max_int32:\n        result = max(min_int32, min(max_int32, result))\n    return result\n\ndef modp(n: int, p: int) -> int:\n    \"\"\"\n    Return 2^n modulo p.\n    \"\"\"\n    n, p = validate_inputs(n, p)\n    result = modular_pow(2, n, p)\n    return format_result(result)",
          "tests_passed": 7,
          "total_tests": 7,
          "time": 497.6722891330719,
          "iterations_used": 2
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "encode_shift",
      "samples": [
        {
          "sample_id": 1,
          "passed": false,
          "solution": "import copy as _copy\n\n# Expose the copy module under the name 'copy' for compatibility with tests\ncopy = _copy\n\n\ndef _shift_char(ch: str, shift: int) -> str:\n    if 'a' <= ch <= 'z':\n        base = ord('a')\n    elif 'A' <= ch <= 'Z':\n        base = ord('A')\n    else:\n        return ch\n    return chr((ord(ch) - base + shift) % 26 + base)\n\n\ndef encode_shift(s: str) -> str:\n    \"\"\"\n    Returns the string encoded by shifting every alphabetic character by +5.\n    Non\u2011alphabetic characters are left unchanged.\n    \"\"\"\n    if not isinstance(s, str):\n        raise TypeError(\"Input must be a string\")\n    return ''.join(_shift_char(ch, 5) for ch in s)\n\n\ndef decode_shift(s: str) -> str:\n    \"\"\"\n    Returns the string decoded by shifting every alphabetic character by -5.\n    Non\u2011alphabetic characters are left unchanged.\n    \"\"\"\n    if not isinstance(s, str):\n        raise TypeError(\"Input must be a string\")\n    return ''.join(_shift_char(ch, -5) for ch in s)",
          "tests_passed": 0,
          "total_tests": 1,
          "time": 1749.0321099758148,
          "iterations_used": 3
        }
      ],
      "num_passed": 0,
      "num_samples": 1
    },
    {
      "problem": "remove_vowels",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import Any\n\ndef fallback_function(text: str) -> str:\n    \"\"\"Identity fallback that simply returns the input unchanged.\"\"\"\n    return text\n\ndef remove_vowels_core(text: str) -> str:\n    \"\"\"\n    Removes all vowels (a, e, i, o, u) from the input string, case\u2011insensitively.\n    \"\"\"\n    if not isinstance(text, str):\n        raise TypeError(f'Input must be a string, got {type(text).__name__}')\n\n    vowels = set('aeiouAEIOU')\n    result = ''.join(ch for ch in text if ch not in vowels)\n\n    # Postcondition: no vowels remain\n    assert all(ch.lower() not in 'aeiou' for ch in result), 'Result contains vowels'\n    return result\n\ndef format_output(result: Any) -> str:\n    \"\"\"\n    Convert the result to a string. Accepts None, str, list, or tuple.\n    \"\"\"\n    if result is None:\n        return ''\n    if isinstance(result, str):\n        return result\n    if isinstance(result, (list, tuple)):\n        return ', '.join(map(str, result))\n    raise TypeError('Unsupported result type')\n\ndef remove_vowels(text: str) -> str:\n    \"\"\"\n    Main function that removes vowels from the given text.\n    \"\"\"\n    processed = fallback_function(text)\n    processed = remove_vowels_core(processed)\n    return format_output(processed)",
          "tests_passed": 7,
          "total_tests": 7,
          "time": 2286.770456790924,
          "iterations_used": 2
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "below_threshold",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import List, Any\n\ndef validate_inputs(l: List[Any], t: int) -> tuple:\n    \"\"\"\n    Validate that l is a list of numeric values and t is an integer.\n    Returns a tuple (l, t) if validation passes.\n    Raises ValueError with a descriptive message otherwise.\n    \"\"\"\n    if l is None:\n        raise ValueError(\"l cannot be None\")\n    if t is None:\n        raise ValueError(\"t cannot be None\")\n    if not isinstance(l, list):\n        raise ValueError(\"l must be a list\")\n    if not isinstance(t, int):\n        raise ValueError(\"t must be an int\")\n    for idx, item in enumerate(l):\n        if item is None:\n            raise ValueError(f\"l contains None at index {idx}\")\n        if not isinstance(item, (int, float)):\n            raise ValueError(f\"l contains non-numeric element at index {idx}\")\n    return l, t\n\ndef check_below_threshold(numbers: List[Any], threshold: int) -> bool:\n    \"\"\"\n    Return True if all numbers in the list are strictly less than the threshold.\n    \"\"\"\n    if not isinstance(numbers, (list, tuple)):\n        raise ValueError(\"numbers must be a list or tuple\")\n    if not isinstance(threshold, (int, float)):\n        raise ValueError(\"threshold must be numeric\")\n\n    if len(numbers) == 0:\n        return True\n\n    for idx, num in enumerate(numbers):\n        if not isinstance(num, (int, float)):\n            raise TypeError(f\"Element at index {idx} is not numeric\")\n        if num >= threshold:\n            return False\n    return True\n\ndef below_threshold(l: List[Any], t: int) -> bool:\n    \"\"\"\n    Main function that validates inputs and checks if all elements are below the threshold.\n    \"\"\"\n    validated_l, validated_t = validate_inputs(l, t)\n    return check_below_threshold(validated_l, validated_t)",
          "tests_passed": 4,
          "total_tests": 4,
          "time": 2374.1743083000183,
          "iterations_used": 2
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "add",
      "samples": [
        {
          "sample_id": 1,
          "passed": false,
          "solution": "import logging\nfrom typing import Tuple, Any\n\nlogger = logging.getLogger(__name__)\nlogging.basicConfig(level=logging.DEBUG)\n\n\ndef validate_and_sanitize_input(x: Any, y: Any) -> Tuple[int, int]:\n    \"\"\"\n    Validate that x and y can be converted to integers.\n    Returns a tuple of two integers.\n    Raises ValueError if validation fails.\n    \"\"\"\n    def _convert(value: Any, name: str) -> int:\n        if value is None:\n            raise ValueError(f\"{name} cannot be None\")\n\n        if isinstance(value, int):\n            return value\n\n        if isinstance(value, float):\n            if value.is_integer():\n                return int(value)\n            raise ValueError(f\"{name} is a float with fractional part\")\n\n        if isinstance(value, str):\n            stripped = value.strip()\n            if stripped == \"\":\n                raise ValueError(f\"{name} is an empty string\")\n            try:\n                return int(stripped)\n            except ValueError:\n                raise ValueError(f\"{name} string '{value}' cannot be converted to int\")\n\n        raise ValueError(f\"{name} has unsupported type {type(value).__name__}\")\n\n    x_int = _convert(x, \"x\")\n    y_int = _convert(y, \"y\")\n    logger.debug(\"Validated inputs: x=%s, y=%s\", x_int, y_int)\n    return x_int, y_int\n\n\ndef perform_addition(x: int, y: int) -> int:\n    \"\"\"\n    Perform addition of two integers.\n    \"\"\"\n    result = x + y\n    logger.debug(\"Addition result: %s\", result)\n    return result\n\n\ndef format_output(result: Any) -> int:\n    \"\"\"\n    Ensure the result is an integer.\n    \"\"\"\n    if result is None:\n        return 0\n    if not isinstance(result, int):\n        try:\n            result = int(result)\n        except Exception as e:\n            raise ValueError(\"result must be an integer or convertible to int\") from e\n    logger.debug(\"Formatted output: %s\", result)\n    return result\n\n\ndef add(x: Any, y: Any) -> int:\n    \"\"\"\n    Main function that integrates all modular components to solve the problem.\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n    x_int, y_int = validate_and_sanitize_input(x, y)\n    sum_result = perform_addition(x_int, y_int)\n    return format_output(sum_result)",
          "tests_passed": 5,
          "total_tests": 6,
          "time": 573.2760689258575,
          "iterations_used": 3
        }
      ],
      "num_passed": 0,
      "num_samples": 1
    },
    {
      "problem": "same_chars",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import Any\n\ndef validate_strings(s0: str, s1: str) -> tuple[str, str]:\n    \"\"\"Validate and clean input strings.\"\"\"\n    if s0 is None or s1 is None:\n        raise ValueError(\"Inputs must not be None\")\n    if not isinstance(s0, str) or not isinstance(s1, str):\n        raise TypeError(\"Both inputs must be strings\")\n    return s0.strip(), s1.strip()\n\ndef compare_character_sets(s0: str, s1: str) -> bool:\n    \"\"\"Return True if the two strings contain exactly the same set of characters.\"\"\"\n    return set(s0) == set(s1)\n\ndef handle_output(result: bool) -> bool:\n    \"\"\"Return the boolean result (kept for modularity).\"\"\"\n    if not isinstance(result, bool):\n        raise TypeError(f\"Expected bool, got {type(result).__name__}\")\n    return result\n\ndef same_chars(s0: str, s1: str) -> Any:\n    \"\"\"Main function that checks if two words have the same characters.\"\"\"\n    s0_clean, s1_clean = validate_strings(s0, s1)\n    result = compare_character_sets(s0_clean, s1_clean)\n    return handle_output(result)",
          "tests_passed": 7,
          "total_tests": 7,
          "time": 310.64019989967346,
          "iterations_used": 2
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "fib",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import Any\n\ndef validate_fibonacci_input(n: int) -> int:\n    \"\"\"Validate that the input is an integer >= 1.\"\"\"\n    if not isinstance(n, int):\n        raise TypeError(f\"Input must be an integer, got {type(n).__name__}\")\n    if n < 1:\n        raise ValueError(\"Input must be greater than or equal to 1\")\n    return n\n\ndef compute_fibonacci(n: int) -> int:\n    \"\"\"Compute the n-th Fibonacci number (1-indexed).\"\"\"\n    if n == 1 or n == 2:\n        return 1\n    a, b = 1, 1\n    for _ in range(3, n + 1):\n        a, b = b, a + b\n    return b\n\ndef fib(n: int) -> int:\n    \"\"\"\n    Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n    validated = validate_fibonacci_input(n)\n    return compute_fibonacci(validated)",
          "tests_passed": 5,
          "total_tests": 5,
          "time": 1254.5120179653168,
          "iterations_used": 2
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "correct_bracketing",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import Any\n\ndef validate_brackets_input(brackets: str) -> bool:\n    \"\"\"\n    Validate that the input is a non\u2011empty string containing only '<' and '>'.\n    \"\"\"\n    if not isinstance(brackets, str):\n        return False\n    if not brackets:\n        return False\n    return all(ch in ('<', '>') for ch in brackets)\n\ndef evaluate_bracketing(brackets: str) -> bool:\n    \"\"\"\n    Return True if the string of brackets is correctly balanced.\n    \"\"\"\n    counter = 0\n    for ch in brackets:\n        if ch == '<':\n            counter += 1\n        elif ch == '>':\n            counter -= 1\n        # Since validation guarantees only '<' or '>', no else needed\n        if counter < 0:\n            return False\n    return counter == 0\n\ndef correct_bracketing(brackets: str) -> bool:\n    \"\"\"\n    Return True if every opening bracket has a corresponding closing bracket.\n    \"\"\"\n    if not validate_brackets_input(brackets):\n        return False\n    return evaluate_bracketing(brackets)\n\n# Example usage (uncomment to test)\n# if __name__ == \"__main__\":\n#     print(correct_bracketing(\"<\"))          # False\n#     print(correct_bracketing(\"<>\"))         # True\n#     print(correct_bracketing(\"<<><>>\"))     # True\n#     print(correct_bracketing(\"><<>\"))       # False",
          "tests_passed": 4,
          "total_tests": 4,
          "time": 301.2607879638672,
          "iterations_used": 2
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "monotonic",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import List, Any\n\ndef _validate_list(input_list: List[Any]) -> List[Any]:\n    \"\"\"\n    Validate that the input is a list. No sanitization is performed\n    because the monotonic check must preserve the original order.\n    \"\"\"\n    if not isinstance(input_list, list):\n        raise TypeError(\"Input must be a list\")\n    return input_list\n\ndef _is_monotonic(values: List[Any]) -> bool:\n    \"\"\"\n    Return True if the list is monotonically increasing or decreasing.\n    Empty and single-element lists are considered monotonic.\n    \"\"\"\n    if len(values) <= 1:\n        return True\n\n    direction = 0  # 0 = unknown, 1 = increasing, -1 = decreasing\n    for i in range(1, len(values)):\n        if values[i] > values[i - 1]:\n            if direction == -1:\n                return False\n            direction = 1\n        elif values[i] < values[i - 1]:\n            if direction == 1:\n                return False\n            direction = -1\n    return True\n\ndef monotonic(l: List[Any]) -> bool:\n    \"\"\"\n    Main function that checks if a list is monotonically increasing or decreasing.\n    \"\"\"\n    processed = _validate_list(l)\n    return _is_monotonic(processed)",
          "tests_passed": 8,
          "total_tests": 8,
          "time": 398.12058305740356,
          "iterations_used": 2
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "common",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import List, Any\n\ndef validate_and_sanitize_inputs(l1: List[Any], l2: List[Any]) -> tuple[List[Any], List[Any]]:\n    \"\"\"Validate that inputs are lists and remove None or unhashable items.\"\"\"\n    if not isinstance(l1, list) or not isinstance(l2, list):\n        raise TypeError(\"Both inputs must be lists\")\n\n    sanitized_l1: List[Any] = []\n    for item in l1:\n        if item is None:\n            continue\n        try:\n            hash(item)\n            sanitized_l1.append(item)\n        except TypeError:\n            continue\n\n    sanitized_l2: List[Any] = []\n    for item in l2:\n        if item is None:\n            continue\n        try:\n            hash(item)\n            sanitized_l2.append(item)\n        except TypeError:\n            continue\n\n    return sanitized_l1, sanitized_l2\n\n\ndef find_common_elements(l1: List[Any], l2: List[Any]) -> List[Any]:\n    \"\"\"Return a sorted list of unique elements common to l1 and l2.\"\"\"\n    try:\n        common_set = set(l1) & set(l2)\n        return sorted(common_set)\n    except TypeError:\n        # Fallback for unhashable elements\n        common: List[Any] = []\n        for item in l1:\n            if item in l2 and item not in common:\n                common.append(item)\n        return sorted(common, key=lambda x: str(x))\n\n\ndef common(l1: List[Any], l2: List[Any]) -> List[Any]:\n    \"\"\"Main function that integrates validation and common element extraction.\"\"\"\n    sanitized_l1, sanitized_l2 = validate_and_sanitize_inputs(l1, l2)\n    return find_common_elements(sanitized_l1, sanitized_l2)",
          "tests_passed": 4,
          "total_tests": 4,
          "time": 233.6135561466217,
          "iterations_used": 2
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "largest_prime_factor",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import Any\n\ndef validate_input(n: Any) -> int:\n    \"\"\"\n    Validate that the input is an integer greater than 1.\n    Raises ValueError if the input is invalid.\n    \"\"\"\n    if not isinstance(n, int):\n        raise ValueError(\"Input must be an integer.\")\n    if n <= 1:\n        raise ValueError(\"Input must be greater than 1.\")\n    return n\n\ndef find_largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Return the largest prime factor of a validated integer.\n    If n is prime, returns n itself.\n    \"\"\"\n    if n == 2:\n        return 2\n\n    largest_factor = None\n\n    # Remove factors of 2\n    while n % 2 == 0:\n        largest_factor = 2\n        n //= 2\n\n    # Check odd factors\n    factor = 3\n    max_factor = int(n ** 0.5) + 1\n    while factor <= max_factor and n > 1:\n        if n % factor == 0:\n            largest_factor = factor\n            while n % factor == 0:\n                n //= factor\n                max_factor = int(n ** 0.5) + 1\n        factor += 2\n\n    # Remaining n is a prime factor larger than sqrt(original n)\n    if n > 1:\n        largest_factor = n\n\n    return int(largest_factor)\n\ndef largest_prime_factor(n: Any) -> int:\n    \"\"\"\n    Return the largest prime factor of n.\n    Assumes n > 1 and is not a prime, but handles primes gracefully.\n    \"\"\"\n    validated = validate_input(n)\n    return find_largest_prime_factor(validated)",
          "tests_passed": 5,
          "total_tests": 5,
          "time": 994.4086709022522,
          "iterations_used": 3
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "sum_to_n",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import Any\n\nimport logging\n\n# Configure module-level logger\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n\ndef validate_sum_to_n_input(n: Any) -> int:\n    \"\"\"\n    Validate that the input n is a positive integer.\n    Returns the validated integer.\n    Raises TypeError if n is not an integer.\n    Raises ValueError if n is None or <= 0.\n    \"\"\"\n    if n is None:\n        raise ValueError(\"Input n cannot be None.\")\n    if not isinstance(n, int) or isinstance(n, bool):\n        raise TypeError(\"Input n must be an integer.\")\n    if n <= 0:\n        raise ValueError(\"Input n must be a positive integer greater than zero.\")\n    return n\n\n\ndef compute_sum_to_n(n: int) -> int:\n    \"\"\"\n    Compute the sum of integers from 1 to n.\n\n    Parameters:\n        n (int): The upper bound of the summation.\n\n    Returns:\n        int: The computed sum.\n    \"\"\"\n    # Validate that n is an integer\n    if not isinstance(n, int):\n        logger.error(\"Input n is not an integer: %s\", n)\n        raise TypeError(\"n must be an integer\")\n\n    # Validate that n is in the acceptable range (>=1)\n    if n < 1:\n        logger.error(\"Input n is less than 1: %s\", n)\n        raise ValueError(\"n must be >= 1\")\n\n    # Compute the sum using the arithmetic series formula\n    result = n * (n + 1) // 2\n    return result\n\n\ndef sum_to_n(n: int) -> int:\n    \"\"\"\n    Main function that sums numbers from 1 to n.\n\n    >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n    validated_n = validate_sum_to_n_input(n)\n    total = compute_sum_to_n(validated_n)\n    return total",
          "tests_passed": 5,
          "total_tests": 5,
          "time": 368.4852159023285,
          "iterations_used": 2
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "derivative",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import List, Any, Optional, Union, Tuple, Dict\n\ndef validate_polynomial_coefficients(coeffs):\n    '''Validate that coeffs is a non-empty list of numeric values.\n    Returns a new list containing the validated coefficients.'''\n    import logging\n    logger = logging.getLogger(__name__)\n    # REASONING: Ensure logger is configured\n    if not logger.handlers:\n        logging.basicConfig(level=logging.DEBUG)\n    # REASONING: Validate input type\n    if not isinstance(coeffs, list):\n        raise TypeError('coeffs must be a list')\n    # REASONING: Check non-empty\n    if len(coeffs) == 0:\n        raise ValueError('coeffs list cannot be empty')\n    validated = []\n    try:\n        for idx, val in enumerate(coeffs):\n            # REASONING: Check numeric type\n            if isinstance(val, (int, float, complex)):\n                validated.append(val)\n            else:\n                raise TypeError(f'Element at index {idx} is not numeric: {val!r}')\n    except Exception as e:\n        # REASONING: Wrap any exception into ValueError for caller\n        raise ValueError(f'Invalid coefficient list: {e}') from e\n    # REASONING: Postcondition: validated list has same length as input\n    assert len(validated) == len(coeffs), 'Length mismatch after validation'\n    return validated\n\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n\ndef compute_polynomial_derivative(validated_coeffs):\n    # REASONING: Validate that the input is a list\n    if not isinstance(validated_coeffs, list):\n        raise TypeError(\"Input must be a list of coefficients.\")\n    # REASONING: Ensure the list is not empty\n    if len(validated_coeffs) == 0:\n        raise ValueError(\"Coefficient list cannot be empty.\")\n    # REASONING: Validate each coefficient is numeric (int or float)\n    for idx, coeff in enumerate(validated_coeffs):\n        if not isinstance(coeff, (int, float)):\n            raise TypeError(f\"Coefficient at index {idx} is not a number.\")\n\n    # REASONING: Compute the derivative using the power rule\n    try:\n        derivative = []\n        for power, coeff in enumerate(validated_coeffs):\n            if power == 0:\n                # Constant term does not contribute to derivative\n                continue\n            derivative.append(coeff * power)\n        # REASONING: Remove leading zeros to satisfy output specification\n        while derivative and derivative[0] == 0:\n            derivative.pop(0)\n        # REASONING: If all coefficients are zero, return an empty list\n        if not derivative:\n            return []\n        return derivative\n    except Exception as e:\n        # REASONING: Catch unexpected errors and raise a descriptive ValueError\n        raise ValueError(f\"Error computing derivative: {e}\") from e\n\n\ndef format_derivative_output(derivative_coeffs):\n    # REASONING: Validate that the input is a list\n    if not isinstance(derivative_coeffs, list):\n        raise TypeError(\"derivative_coeffs must be a list\")\n    # REASONING: Validate that each element is numeric (int or float)\n    for idx, coeff in enumerate(derivative_coeffs):\n        if not isinstance(coeff, (int, float)):\n            raise TypeError(f\"Element at index {idx} is not a number\")\n    # REASONING: Main logic inside a try block to catch unexpected errors\n    try:\n        # Find the index of the first non-zero coefficient\n        first_non_zero = None\n        for i, coeff in enumerate(derivative_coeffs):\n            if coeff != 0:\n                first_non_zero = i\n                break\n        # If all coefficients are zero, return an empty list\n        if first_non_zero is None:\n            result = []\n        else:\n            result = derivative_coeffs[first_non_zero:]\n        # REASONING: Postcondition: result should not start with a zero\n        assert not result or result[0] != 0\n        return result\n    except Exception as exc:\n        # REASONING: Wrap any exception to provide context\n        raise RuntimeError(\"Error processing derivative coefficients\") from exc\n    finally:\n        # Optional logging of the operation\n        import logging\n        logging.debug(f\"Processed derivative_coeffs: {derivative_coeffs} -> {result if 'result' in locals() else None}\")\n\n\ndef derivative(xs) -> Any:\n    \"\"\"\n    Main function that integrates all modular components to solve the problem.\n    Generated by Modular ToT Self-Reflective Architecture.\n    \"\"\"\n    # Module execution chain\n    processed = validate_polynomial_coefficients(xs)\n    processed = compute_polynomial_derivative(processed)\n    return format_derivative_output(processed)\n",
          "tests_passed": 5,
          "total_tests": 5,
          "time": 335.06476378440857,
          "iterations_used": 1
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "fibfib",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import Any\n\ndef validate_input(n: int) -> int:\n    \"\"\"Validate that n is a non\u2011negative integer.\"\"\"\n    if not isinstance(n, int):\n        raise TypeError(\"n must be an integer\")\n    if n < 0:\n        raise ValueError(\"n must be non\u2011negative\")\n    return n\n\ndef compute_fibfib(n: int) -> int:\n    \"\"\"Compute the n-th FibFib number using an iterative approach.\"\"\"\n    if n == 0 or n == 1:\n        return 0\n    if n == 2:\n        return 1\n\n    f0, f1, f2 = 0, 0, 1  # fibfib(0), fibfib(1), fibfib(2)\n    for _ in range(3, n + 1):\n        f_next = f0 + f1 + f2\n        f0, f1, f2 = f1, f2, f_next\n    return f2\n\ndef format_output(result: int) -> int:\n    \"\"\"Return the computed result (placeholder for potential formatting).\"\"\"\n    return result\n\ndef fibfib(n: int) -> Any:\n    \"\"\"Main function to compute the n-th FibFib number.\"\"\"\n    validated_n = validate_input(n)\n    result = compute_fibfib(validated_n)\n    return format_output(result)",
          "tests_passed": 7,
          "total_tests": 7,
          "time": 1272.6958651542664,
          "iterations_used": 2
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "vowels_count",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import List, Any, Optional, Union, Tuple, Dict\n\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n\ndef validate_input(raw_input):\n    '''Validate and normalize a non-empty string input.\n    Returns the stripped string if valid.\n    Raises TypeError if input is not a string.\n    Raises ValueError if input is empty or whitespace only.\n    '''\n    # REASONING: Set up logger for debugging\n    try:\n        # REASONING: Precondition check: input must be a string\n        if not isinstance(raw_input, str):\n            raise TypeError('Input must be a string')\n        # REASONING: Strip whitespace to normalize\n        cleaned = raw_input.strip()\n        # REASONING: Postcondition check: cleaned string must not be empty\n        if not cleaned:\n            raise ValueError('Input cannot be empty or whitespace only')\n        # REASONING: Return the validated string\n        return cleaned\n    except (TypeError, ValueError) as e:\n        # REASONING: Log the error before re-raising\n        logger.exception('Validation failed: %s', e)\n        raise\n    except Exception as e:\n        # REASONING: Catch-all for unexpected errors\n        logger.exception('Unexpected error during validation: %s', e)\n        raise\n    finally:\n        # REASONING: Final block to indicate completion\n        logger.debug('validate_input completed')\n\nimport logging\nlogging.basicConfig(level=logging.DEBUG)\n\ndef count_vowels(word):\n    # REASONING: Validate that the input is a string\n    if not isinstance(word, str):\n        raise TypeError(\"Input must be a string\")\n    # REASONING: Ensure the input is not None (redundant but defensive)\n    if word is None:\n        raise ValueError(\"Input cannot be None\")\n    # REASONING: Initialize the vowel counter\n    count = 0\n    try:\n        # REASONING: Iterate over each character in the word\n        for ch in word:\n            # REASONING: Skip any non-alphabetic characters\n            if not ch.isalpha():\n                continue\n            # REASONING: Count standard vowels (case-insensitive)\n            if ch.lower() in 'aeiou':\n                count += 1\n        # REASONING: Apply the special rule for 'y' when it is the last character\n        if word and word[-1].lower() == 'y':\n            count += 1\n    except Exception as e:\n        # REASONING: Handle unexpected errors during iteration\n        raise RuntimeError(\"Error counting vowels\") from e\n    finally:\n        # REASONING: Log the result for debugging purposes\n        logging.debug(f\"count_vowels('{word}') -> {count}\")\n    # REASONING: Postcondition: count is a non-negative integer\n    assert isinstance(count, int) and count >= 0\n    return count\n\n\ndef vowels_count(s) -> Any:\n    \"\"\"\n    Main function that integrates all modular components to solve the problem.\n    Generated by Modular ToT Self-Reflective Architecture.\n    \"\"\"\n    # Module execution chain\n    processed = validate_input(s)\n    return count_vowels(processed)\n",
          "tests_passed": 7,
          "total_tests": 7,
          "time": 269.53689432144165,
          "iterations_used": 1
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "circular_shift",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import Tuple\n\ndef validate_and_sanitize_input(x, shift) -> Tuple[int, int]:\n    \"\"\"\n    Validate that x and shift can be converted to non\u2011negative integers.\n    Return the sanitized values as a tuple.\n    \"\"\"\n    try:\n        x_int = int(x)\n    except (TypeError, ValueError):\n        raise ValueError(\"x must be an integer\") from None\n\n    try:\n        shift_int = int(shift)\n    except (TypeError, ValueError):\n        raise ValueError(\"shift must be an integer\") from None\n\n    if x_int < 0:\n        raise ValueError(\"x must be non\u2011negative\")\n    if shift_int < 0:\n        raise ValueError(\"shift must be non\u2011negative\")\n\n    return x_int, shift_int\n\n\ndef perform_circular_shift(x: int, shift: int) -> str:\n    \"\"\"\n    Perform a circular right shift of the decimal digits of x by shift positions.\n    If shift is greater than the number of digits, return the digits reversed.\n    \"\"\"\n    digits = str(x)\n\n    # Trivial cases\n    if shift == 0 or shift == len(digits):\n        return digits\n\n    # If shift exceeds number of digits, return reversed digits\n    if shift > len(digits):\n        return digits[::-1]\n\n    # Perform circular right shift\n    shift_mod = shift % len(digits)\n    if shift_mod == 0:\n        return digits\n    return digits[-shift_mod:] + digits[:-shift_mod]\n\n\ndef circular_shift(x, shift) -> str:\n    \"\"\"\n    Main function that validates input and performs the circular shift.\n    \"\"\"\n    x_int, shift_int = validate_and_sanitize_input(x, shift)\n    return perform_circular_shift(x_int, shift_int)",
          "tests_passed": 5,
          "total_tests": 5,
          "time": 984.6091740131378,
          "iterations_used": 2
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "digitSum",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "import logging\n\nlogging.basicConfig(level=logging.DEBUG)\n\ndef validate_and_sanitize_input(input_str: str) -> str:\n    if input_str is None:\n        raise ValueError(\"input_str cannot be None\")\n    if not isinstance(input_str, str):\n        raise TypeError(\"input_str must be a string\")\n    try:\n        sanitized = input_str.strip()\n        sanitized = sanitized.replace(\"\\n\", \" \").replace(\"\\r\", \" \")\n    except Exception:\n        sanitized = \"\"\n    logging.debug(f\"Sanitized input: {sanitized!r}\")\n    return sanitized\n\ndef sum_uppercase_ascii(sanitized_str: str) -> int:\n    if not isinstance(sanitized_str, str):\n        raise TypeError(\"sanitized_str must be a string\")\n    total_sum = 0\n    for ch in sanitized_str:\n        if ch.isupper() and ord(ch) < 128:\n            total_sum += ord(ch)\n    return total_sum\n\ndef digitSum(s: str) -> int:\n    processed = validate_and_sanitize_input(s)\n    return sum_uppercase_ascii(processed)",
          "tests_passed": 8,
          "total_tests": 8,
          "time": 569.6973819732666,
          "iterations_used": 2
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "fruit_distribution",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "import re\nimport logging\n\nlogging.basicConfig(level=logging.INFO, format=\"%(levelname)s:%(message)s\")\n\n\ndef parse_fruit_counts(s: str) -> tuple[int, int]:\n    \"\"\"Extract the number of apples and oranges from the input string.\"\"\"\n    if not isinstance(s, str):\n        raise TypeError(\"Input must be a string\")\n\n    s = s.strip()\n\n    apple_match = re.search(r\"(?i)(-?\\d+)\\s*apples?\", s)\n    orange_match = re.search(r\"(?i)(-?\\d+)\\s*oranges?\", s)\n\n    if not apple_match or not orange_match:\n        raise ValueError(\"Could not find apples or oranges count in the string\")\n\n    apples = int(apple_match.group(1))\n    oranges = int(orange_match.group(1))\n\n    if apples < 0 or oranges < 0:\n        raise ValueError(\"Fruit counts must be non\u2011negative\")\n\n    return apples, oranges\n\n\ndef calculate_mangoes(apples: int, oranges: int, total: int) -> int:\n    \"\"\"Return the number of mangoes given apples, oranges, and total fruits.\"\"\"\n    if not all(isinstance(v, int) for v in (apples, oranges, total)):\n        raise TypeError(\"All inputs must be integers\")\n\n    if apples < 0 or oranges < 0 or total < 0:\n        raise ValueError(\"Inputs cannot be negative\")\n\n    mangoes = total - apples - oranges\n    if mangoes < 0:\n        logging.warning(\n            \"Total less than sum of apples and oranges; returning 0 as fallback\"\n        )\n        return 0\n\n    return mangoes\n\n\ndef fruit_distribution(s: str, n: int) -> int:\n    \"\"\"Main function that parses the string and calculates mangoes.\"\"\"\n    apples, oranges = parse_fruit_counts(s)\n    return calculate_mangoes(apples, oranges, n)",
          "tests_passed": 7,
          "total_tests": 7,
          "time": 414.30665588378906,
          "iterations_used": 2
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "pluck",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import List, Any, Optional, Union, Tuple, Dict\n\nimport logging\n\nlogging.basicConfig(level=logging.INFO)\n\ndef validate_and_sanitize_input(arr):\n    '''\n    Validate that arr is a list of non-negative integers.\n    Return sanitized list or empty list if invalid.\n    '''\n    # REASONING: Ensure arr is a list; if not, return empty list\n    if not isinstance(arr, list):\n        return []\n\n    # REASONING: Use try/except to catch unexpected errors during iteration\n    try:\n        sanitized = []\n        for item in arr:\n            # REASONING: Check type and value\n            if isinstance(item, int) and item >= 0:\n                sanitized.append(item)\n            else:\n                # REASONING: Invalid element found; return empty list\n                return []\n    except Exception as e:\n        # REASONING: Log unexpected exception and return empty\n        logging.exception('Unexpected error during validation')\n        return []\n\n    # REASONING: All elements passed checks; assert postconditions\n    assert isinstance(sanitized, list)\n    for val in sanitized:\n        assert isinstance(val, int) and val >= 0\n\n    # REASONING: Return sanitized list\n    return sanitized\n\ndef find_smallest_even(arr):\n    import logging\n    logger = logging.getLogger(__name__)\n    # REASONING: Validate input type\n    assert isinstance(arr, (list, tuple)), \"arr must be a list or tuple\"\n    # REASONING: Ensure all elements are integers\n    for idx, item in enumerate(arr):\n        if not isinstance(item, int):\n            raise ValueError(f\"Element at index {idx} is not an integer\")\n    # REASONING: Handle empty list\n    if not arr:\n        return None\n    smallest_even = None\n    smallest_index = None\n    try:\n        for idx, num in enumerate(arr):\n            if num % 2 == 0:\n                if smallest_even is None or num < smallest_even:\n                    smallest_even = num\n                    smallest_index = idx\n    except Exception as e:\n        logger.exception(\"Error during iteration\")\n        raise\n    result = None\n    if smallest_even is not None:\n        result = (smallest_even, smallest_index)\n    # REASONING: Postcondition: result is None or tuple of two ints\n    assert result is None or (isinstance(result, tuple) and len(result) == 2), \"postcondition failed\"\n    return result\n\nimport logging\nfrom typing import List, Tuple, Optional\n\n# Configure basic logging\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n\ndef format_result(result: Optional[Tuple[int, int]]) -> List[int]:\n    \"\"\"Convert the optional tuple from find_smallest_even into the required output format.\n\n    Parameters\n    ----------\n    result : Optional[Tuple[int, int]]\n        The tuple returned by find_smallest_even or None.\n\n    Returns\n    -------\n    List[int]\n        Either [value, index] or an empty list if no valid result.\n    \"\"\"\n    try:\n        # REASONING: Assert that the input is either None or a tuple.\n        assert result is None or isinstance(result, tuple), \"result must be None or tuple\"\n\n        if result is None:\n            # REASONING: No result found, return empty list as per specification.\n            return []\n\n        # REASONING: Ensure the tuple has exactly two elements.\n        if len(result) != 2:\n            return []\n\n        value, index = result\n\n        # REASONING: Validate that both elements are integers.\n        assert isinstance(value, int) and isinstance(index, int), \"tuple elements must be integers\"\n\n        # REASONING: Index should be non-negative; if negative, treat as invalid.\n        if index < 0:\n            return []\n\n        output = [value, index]\n\n        # REASONING: Postcondition \u2013 output must be a list.\n        assert isinstance(output, list), \"output must be a list\"\n        return output\n    except (AssertionError, TypeError, ValueError) as e:\n        # REASONING: Handle expected validation errors and log them.\n        logger.exception(\"Error processing result: %s\", e)\n        return []\n    except Exception as e:\n        # REASONING: Catch any unforeseen errors to prevent crashes.\n        logger.exception(\"Unexpected error: %s\", e)\n        return []\n\n\ndef pluck(arr) -> Any:\n    \"\"\"\n    Main function that integrates all modular components to solve the problem.\n    Generated by Modular ToT Self-Reflective Architecture.\n    \"\"\"\n    # Module execution chain\n    processed = validate_and_sanitize_input(arr)\n    processed = find_smallest_even(processed)\n    return format_result(processed)\n",
          "tests_passed": 8,
          "total_tests": 8,
          "time": 1211.0140352249146,
          "iterations_used": 1
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "search",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "import collections\nimport logging\nfrom typing import Any, List\n\n# Configure basic logging\nlogging.basicConfig(level=logging.DEBUG)\nlogger = logging.getLogger(__name__)\n\ndef validate_and_sanitize_input(lst: List[Any]) -> List[int]:\n    \"\"\"\n    Ensure the input is a list of positive integers.\n    Non-integer or non-positive values are skipped.\n    Raises ValueError if no valid integers remain.\n    \"\"\"\n    if not isinstance(lst, list):\n        raise TypeError(\"Input must be a list.\")\n    sanitized = []\n    for idx, item in enumerate(lst):\n        if not isinstance(item, int):\n            logger.debug(f\"Skipping non-integer at index {idx}: {item}\")\n            continue\n        if item <= 0:\n            logger.debug(f\"Skipping non-positive integer at index {idx}: {item}\")\n            continue\n        sanitized.append(item)\n    if not sanitized:\n        raise ValueError(\"No valid positive integers found in the input list.\")\n    return sanitized\n\ndef compute_greatest_valid_integer(lst: List[int]) -> int:\n    \"\"\"\n    Determine the greatest integer whose frequency in the list is at least equal to the integer itself.\n    Returns the integer if found, otherwise returns -1.\n    \"\"\"\n    freq_counter = collections.Counter(lst)\n    valid_integers = [number for number, freq in freq_counter.items() if freq >= number]\n    if not valid_integers:\n        return -1\n    result = max(valid_integers)\n    # Postcondition: result itself satisfies the condition\n    assert freq_counter[result] >= result, \"Result does not satisfy frequency condition.\"\n    return result\n\ndef format_search_result(result: Any) -> int:\n    \"\"\"\n    Convert the result to an integer if necessary and validate its range.\n    \"\"\"\n    if isinstance(result, str):\n        result = result.strip()\n        if result == \"\":\n            raise ValueError(\"Empty string cannot be converted to int.\")\n        result = int(result)\n    elif isinstance(result, float):\n        if not result.is_integer():\n            raise ValueError(\"Float result is not an integer.\")\n        result = int(result)\n    if not isinstance(result, int):\n        raise TypeError(\"Result must be an integer.\")\n    if result < -2**31 or result > 2**31 - 1:\n        raise OverflowError(\"Result out of 32-bit signed int range.\")\n    return result\n\ndef search(lst: List[Any]) -> int:\n    \"\"\"\n    Main function that integrates all modular components to solve the problem.\n    \"\"\"\n    processed = validate_and_sanitize_input(lst)\n    processed = compute_greatest_valid_integer(processed)\n    return format_search_result(processed)",
          "tests_passed": 25,
          "total_tests": 25,
          "time": 1370.2926421165466,
          "iterations_used": 3
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "strange_sort_list",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import List, Any\n\ndef validate_and_sanitize_input(lst: List[int]) -> List[int]:\n    if not isinstance(lst, list):\n        raise TypeError('Input must be a list')\n    copy_lst = lst.copy()\n    for idx, item in enumerate(copy_lst):\n        if item is None:\n            raise ValueError(f'Element at index {idx} is None')\n        if not isinstance(item, int):\n            raise TypeError(f'Element at index {idx} is not an integer')\n    return copy_lst\n\ndef perform_strange_sort(nums: List[int]) -> List[int]:\n    if not isinstance(nums, list):\n        raise TypeError('Input must be a list')\n    for idx, val in enumerate(nums):\n        if not isinstance(val, int):\n            raise TypeError(f'Element at index {idx} is not an integer')\n    if len(nums) <= 1:\n        return nums.copy()\n    sorted_nums = sorted(nums)\n    result: List[int] = []\n    while sorted_nums:\n        result.append(sorted_nums.pop(0))\n        if sorted_nums:\n            result.append(sorted_nums.pop(-1))\n    assert len(result) == len(nums), 'Result length mismatch'\n    assert sorted(result) == sorted(nums), 'Result elements mismatch'\n    return result\n\ndef handle_output(sorted_list: List[int]) -> List[int]:\n    if sorted_list is None:\n        raise ValueError(\"Input list cannot be None.\")\n    if not isinstance(sorted_list, list):\n        raise TypeError(\"Input must be a list.\")\n    for idx, item in enumerate(sorted_list):\n        if not isinstance(item, int):\n            raise TypeError(f\"Element at index {idx} is not an integer: {item!r}\")\n    return sorted_list\n\ndef strange_sort_list(lst: List[int]) -> List[int]:\n    processed = validate_and_sanitize_input(lst)\n    processed = perform_strange_sort(processed)\n    return handle_output(processed)",
          "tests_passed": 9,
          "total_tests": 9,
          "time": 1554.203975200653,
          "iterations_used": 2
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "will_it_fly",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import List, Any\n\ndef validate_and_sanitize_input(q: List[int], w: int) -> tuple[List[int], int]:\n    \"\"\"Validate and sanitize inputs.\"\"\"\n    if not isinstance(q, list):\n        raise TypeError(\"q must be a list\")\n    if not isinstance(w, int):\n        raise TypeError(\"w must be an integer\")\n    if any(not isinstance(item, int) for item in q):\n        raise ValueError(\"q contains non-integer elements\")\n    if w < 0:\n        w = 0\n    sanitized_q = [int(item) for item in q]\n    return sanitized_q, w\n\ndef is_balanced_and_within_weight(q: List[int], w: int) -> bool:\n    \"\"\"Return True if q is a palindrome and its sum is <= w.\"\"\"\n    if not q:\n        return True\n    total = sum(q)\n    is_palindrome = q == q[::-1]\n    return is_palindrome and total <= w\n\ndef format_flight_result(is_flyable: bool) -> bool:\n    \"\"\"Return the boolean result.\"\"\"\n    if not isinstance(is_flyable, bool):\n        raise TypeError(\"Result must be a boolean\")\n    return is_flyable\n\ndef will_it_fly(q: List[int], w: int) -> bool:\n    \"\"\"Main function to determine if the object will fly.\"\"\"\n    sanitized_q, sanitized_w = validate_and_sanitize_input(q, w)\n    result = is_balanced_and_within_weight(sanitized_q, sanitized_w)\n    return format_flight_result(result)",
          "tests_passed": 6,
          "total_tests": 6,
          "time": 270.48274993896484,
          "iterations_used": 2
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "smallest_change",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import List, Any\n\ndef validate_input(arr: List[int]) -> List[int]:\n    \"\"\"\n    Validate that the input is a list of integers.\n    \"\"\"\n    if not isinstance(arr, list):\n        raise TypeError(\"Input must be a list\")\n    for idx, item in enumerate(arr):\n        if not isinstance(item, int):\n            raise ValueError(f\"Element at index {idx} is not an integer\")\n    return arr\n\ndef compute_min_changes(arr: List[int]) -> int:\n    \"\"\"\n    Compute the minimum number of changes required to make the list palindromic.\n    \"\"\"\n    n = len(arr)\n    if n <= 1:\n        return 0\n    count = 0\n    for i in range(n // 2):\n        if arr[i] != arr[n - 1 - i]:\n            count += 1\n    return count\n\ndef format_result(changes: int) -> int:\n    \"\"\"\n    Return the result unchanged (kept for modularity).\n    \"\"\"\n    if not isinstance(changes, int) or changes < 0:\n        raise ValueError(\"Changes must be a non-negative integer\")\n    return changes\n\ndef smallest_change(arr: List[int]) -> int:\n    \"\"\"\n    Main function that integrates all modular components to solve the problem.\n    \"\"\"\n    validated = validate_input(arr)\n    changes = compute_min_changes(validated)\n    return format_result(changes)",
          "tests_passed": 8,
          "total_tests": 8,
          "time": 245.74871182441711,
          "iterations_used": 2
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "total_match",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import List, Tuple, Any\n\ndef sanitize_input_lists(lst1: List[Any], lst2: List[Any]) -> Tuple[List[str], List[str]]:\n    \"\"\"\n    Convert all elements of the input lists to strings and validate that the inputs are lists.\n    \"\"\"\n    if not isinstance(lst1, list) or not isinstance(lst2, list):\n        raise TypeError(\"Both inputs must be lists\")\n\n    def _to_str(lst: List[Any]) -> List[str]:\n        return [str(item) for item in lst]\n\n    return _to_str(lst1), _to_str(lst2)\n\ndef find_shorter_list_by_total_chars(lst1: List[str], lst2: List[str]) -> List[str]:\n    \"\"\"\n    Return the list with the smaller total number of characters.\n    If totals are equal, return the first list.\n    \"\"\"\n    total1 = sum(len(item) for item in lst1)\n    total2 = sum(len(item) for item in lst2)\n    return lst1 if total1 <= total2 else lst2\n\ndef total_match(lst1: List[Any], lst2: List[Any]) -> List[str]:\n    \"\"\"\n    Main function that returns the list with the smaller total number of characters.\n    If the totals are equal, the first list is returned.\n    \"\"\"\n    lst1_clean, lst2_clean = sanitize_input_lists(lst1, lst2)\n    return find_shorter_list_by_total_chars(lst1_clean, lst2_clean)",
          "tests_passed": 9,
          "total_tests": 9,
          "time": 385.07852697372437,
          "iterations_used": 2
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "is_simple_power",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "import logging\nfrom typing import Any\n\nlogger = logging.getLogger(__name__)\n\ndef validate_parameters(x: int, n: int) -> bool:\n    \"\"\"Validate that the inputs are integers and that the case is defined.\"\"\"\n    if not isinstance(x, int) or not isinstance(n, int):\n        logger.debug(\"Inputs must be integers.\")\n        return False\n    # 0**0 is undefined\n    if n == 0 and x == 0:\n        logger.debug(\"Undefined case: 0**0.\")\n        return False\n    # 0**negative exponent is undefined\n    if x == 0 and n < 0:\n        logger.debug(\"Undefined case: 0**negative exponent.\")\n        return False\n    return True\n\ndef compute_simple_power(x: int, n: int) -> bool:\n    \"\"\"Return True if there exists an integer k >= 0 such that n**k == x.\"\"\"\n    # Handle trivial cases\n    if n == 0:\n        return x == 0\n    if n == 1:\n        return x == 1\n    if n == -1:\n        return x == 1 or x == -1\n    if x == 0:\n        return n != 0\n\n    # Positive x\n    if x > 0:\n        if n > 0:\n            power = 1\n            while power < x:\n                power *= n\n            return power == x\n        else:  # n < 0\n            abs_n = abs(n)\n            power = 1\n            exp = 0\n            while power < x:\n                power *= abs_n\n                exp += 1\n            return power == x and exp % 2 == 0\n\n    # Negative x\n    if x < 0:\n        if n > 0:\n            return False\n        # n < 0\n        abs_n = abs(n)\n        target = abs(x)\n        power = 1\n        exp = 0\n        while power < target:\n            power *= abs_n\n            exp += 1\n        return power == target and exp % 2 == 1\n\n    return False\n\ndef is_simple_power(x: int, n: int) -> bool:\n    \"\"\"Main function to determine if x is a simple power of n.\"\"\"\n    if not validate_parameters(x, n):\n        return False\n    return compute_simple_power(x, n)",
          "tests_passed": 10,
          "total_tests": 10,
          "time": 721.639102935791,
          "iterations_used": 2
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "iscube",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import Any\n\ndef validate_integer_input(value: Any) -> int:\n    \"\"\"\n    Ensure the supplied value is an integer and convert it if necessary.\n    Raises:\n        TypeError: If value is None or not a supported type.\n        ValueError: If value cannot be converted to an integer.\n    Returns:\n        int: The validated integer value.\n    \"\"\"\n    if value is None:\n        raise TypeError(\"Input value cannot be None\")\n\n    try:\n        if isinstance(value, int):\n            return value\n        if isinstance(value, float):\n            if value.is_integer():\n                return int(value)\n            raise ValueError(f\"Float value {value} cannot be converted to int without loss\")\n        if isinstance(value, str):\n            stripped = value.strip()\n            if stripped == \"\":\n                raise ValueError(\"Empty string cannot be converted to int\")\n            return int(stripped)\n        raise TypeError(f\"Unsupported type {type(value).__name__} for conversion\")\n    except ValueError as ve:\n        raise ValueError(f\"Cannot convert value {value!r} to int: {ve}\") from ve\n    except TypeError as te:\n        raise TypeError(f\"Unsupported type for conversion: {value!r}\") from te\n\n\ndef iscube(a: Any) -> bool:\n    \"\"\"\n    Return True if the integer a is a perfect cube, otherwise False.\n    \"\"\"\n    n = validate_integer_input(a)\n\n    if n == 0:\n        return True\n\n    sign = -1 if n < 0 else 1\n    abs_n = abs(n)\n\n    low, high = 0, abs_n\n    while low <= high:\n        mid = (low + high) // 2\n        cube = mid ** 3\n        if cube == abs_n:\n            return True\n        if cube < abs_n:\n            low = mid + 1\n        else:\n            high = mid - 1\n\n    return False",
          "tests_passed": 8,
          "total_tests": 8,
          "time": 508.1619908809662,
          "iterations_used": 2
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "hex_key",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "import logging\nfrom typing import Any\n\n# Configure module-level logger\nlogger = logging.getLogger(__name__)\n\ndef sanitize_hex_string(hex_str):\n    \"\"\"\n    Convert the input to a string, strip surrounding whitespace, and return an empty string\n    if the input is None or cannot be converted.\n    \"\"\"\n    if hex_str is None:\n        return ''\n    try:\n        cleaned = str(hex_str).strip()\n    except Exception:\n        logger.exception(\"Failed to convert input to string\")\n        return ''\n    return cleaned\n\ndef count_prime_hex_digits(hex_str: str) -> int:\n    \"\"\"\n    Count how many characters in the hexadecimal string represent prime numbers.\n    \"\"\"\n    if not isinstance(hex_str, str):\n        raise TypeError(\"hex_str must be a string\")\n    logger.debug(\"Counting prime hex digits for input: %s\", hex_str)\n    prime_hex_digits = {'2', '3', '5', '7', 'b', 'd'}\n    count = 0\n    for char in hex_str:\n        if char.lower() in prime_hex_digits:\n            count += 1\n    assert 0 <= count <= len(hex_str), \"Count out of bounds\"\n    return count\n\ndef hex_key(num) -> Any:\n    \"\"\"\n    Main function that integrates all modular components to solve the problem.\n    \"\"\"\n    processed = sanitize_hex_string(num)\n    return count_prime_hex_digits(processed)",
          "tests_passed": 7,
          "total_tests": 7,
          "time": 260.2944748401642,
          "iterations_used": 2
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "decimal_to_binary",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import List, Any, Optional, Union, Tuple, Dict\n\nimport logging\nlogger = logging.getLogger(__name__)\n\ndef validate_decimal_input(decimal):\n    \"\"\"\n    Validate that the input is a non\u2011negative integer and return it.\n    Raises TypeError if input is None or not an integer-like value.\n    Raises ValueError if input is negative or not integer\u2011like.\n    \"\"\"\n    # REASONING: Check for None input early to avoid downstream errors\n    if decimal is None:\n        raise TypeError('Input cannot be None')\n\n    # REASONING: Ensure the value is an integer or can be converted to one\n    if not isinstance(decimal, int):\n        try:\n            # REASONING: Attempt to convert to int; this handles numeric strings and floats\n            decimal_converted = int(decimal)\n            # REASONING: Verify that conversion did not alter the numeric value\n            if decimal_converted != decimal:\n                raise ValueError\n        except (ValueError, TypeError):\n            # REASONING: If conversion fails, the input is not integer\u2011like\n            raise TypeError('Input must be an integer or integer\u2011like value')\n        decimal = decimal_converted\n\n    # REASONING: After conversion, enforce non\u2011negative constraint\n    if decimal < 0:\n        raise ValueError('Input must be non\u2011negative')\n\n    # REASONING: Postcondition: the returned value is an int\n    assert isinstance(decimal, int), 'Postcondition failed: returned value is not int'\n\n    logger.debug(f'Validated decimal input: {decimal}')\n    return decimal\n\nimport logging\n\n# Configure a module\u2011level logger (optional but useful for debugging)\nlogger = logging.getLogger(__name__)\nlogger.addHandler(logging.NullHandler())\n\n\ndef decimal_to_binary_core(decimal):\n    \"\"\"Convert a validated non\u2011negative integer to its binary representation.\n\n    Parameters:\n        decimal (int): A non\u2011negative integer.\n\n    Returns:\n        str: Binary string without any surrounding characters.\n\n    Raises:\n        TypeError: If the input is not an integer.\n        ValueError: If the input is negative.\n        RuntimeError: If an unexpected error occurs during conversion.\n    \"\"\"\n    # REASONING: Validate that the input is an integer.\n    if not isinstance(decimal, int):\n        raise TypeError(\"Input must be an integer.\")\n\n    # REASONING: Ensure the integer is non\u2011negative.\n    if decimal < 0:\n        raise ValueError(\"Input must be non-negative.\")\n\n    # REASONING: Handle the special case where decimal is 0.\n    if decimal == 0:\n        return \"0\"\n\n    # REASONING: Use bitwise operations for efficient conversion.\n    bits = []\n    try:\n        n = decimal\n        while n > 0:\n            bits.append(str(n & 1))  # Append least significant bit.\n            n >>= 1                  # Shift right by one.\n    except Exception as e:\n        # REASONING: Catch any unexpected exception and wrap it.\n        raise RuntimeError(\"Unexpected error during conversion.\") from e\n\n    # REASONING: Bits were collected LSB first; reverse to get MSB first.\n    binary_str = ''.join(reversed(bits))\n\n    # REASONING: Postcondition assertion ensures output contains only binary digits.\n    assert set(binary_str) <= {\"0\", \"1\"}, \"Output contains invalid characters.\"\n\n    # Optional logging of the conversion result.\n    logger.debug(\"Converted %s to binary string %s\", decimal, binary_str)\n\n    return binary_str\n\ndef format_binary_with_db(binary_str):\n    # REASONING: Validate input type\n    if not isinstance(binary_str, str):\n        raise TypeError('binary_str must be a string')\n    # REASONING: Validate content\n    if binary_str and any(c not in '01' for c in binary_str):\n        raise ValueError('binary_str must contain only 0 and 1')\n    # REASONING: Handle empty string\n    if binary_str == '':\n        return 'dbdb'\n    # REASONING: Construct result with try/except for safety\n    try:\n        result = f'db{binary_str}db'\n    except Exception as e:\n        # Fallback: use concatenation\n        result = 'db' + binary_str + 'db'\n    # REASONING: Postcondition assertion\n    assert result.startswith('db') and result.endswith('db'), 'Result must have db prefix and suffix'\n    return result\n\n\ndef decimal_to_binary(decimal) -> Any:\n    \"\"\"\n    Main function that integrates all modular components to solve the problem.\n    Generated by Modular ToT Self-Reflective Architecture.\n    \"\"\"\n    # Module execution chain\n    processed = validate_decimal_input(decimal)\n    processed = decimal_to_binary_core(processed)\n    return format_binary_with_db(processed)\n",
          "tests_passed": 4,
          "total_tests": 4,
          "time": 1222.4704458713531,
          "iterations_used": 1
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "is_happy",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import Any\n\ndef validate_and_sanitize_input(input_str: str) -> str:\n    \"\"\"\n    Validate that the input is a non\u2011empty string and strip surrounding whitespace.\n    \"\"\"\n    if input_str is None:\n        raise TypeError(\"input_str cannot be None\")\n    if not isinstance(input_str, str):\n        raise TypeError(f\"input_str must be a string, got {type(input_str).__name__}\")\n    sanitized = input_str.strip()\n    if not sanitized:\n        raise ValueError(\"input_str cannot be empty after sanitization\")\n    return sanitized\n\ndef check_happy_string(sanitized_str: str) -> bool:\n    \"\"\"\n    Return True if every three consecutive characters in the string are distinct.\n    \"\"\"\n    if len(sanitized_str) < 3:\n        return False\n    for i in range(len(sanitized_str) - 2):\n        triple = sanitized_str[i:i+3]\n        if len(set(triple)) != 3:\n            return False\n    return True\n\ndef is_happy(s: Any) -> bool:\n    \"\"\"\n    Main function that checks if a string is happy.\n    \"\"\"\n    sanitized = validate_and_sanitize_input(s)\n    return check_happy_string(sanitized)",
          "tests_passed": 8,
          "total_tests": 8,
          "time": 338.63362312316895,
          "iterations_used": 2
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "numerical_letter_grade",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import List, Any\n\ndef validate_and_sanitize_gpa_list(gpa_list: List[Any]) -> List[float]:\n    \"\"\"\n    Validate that gpa_list is a list of numeric values within 0.0 to 4.0 inclusive.\n    Returns a new list of validated GPA values as floats.\n    \"\"\"\n    if not isinstance(gpa_list, list):\n        raise TypeError(\"gpa_list must be a list\")\n\n    if len(gpa_list) == 0:\n        return []\n\n    validated: List[float] = []\n    for idx, val in enumerate(gpa_list):\n        try:\n            num = float(val)\n        except (TypeError, ValueError) as exc:\n            raise ValueError(f\"Element at index {idx} is not numeric: {val}\") from exc\n\n        if not (0.0 <= num <= 4.0):\n            raise ValueError(f\"Element at index {idx} out of range: {num}\")\n\n        validated.append(num)\n\n    return validated\n\n\ndef convert_gpa_to_letter(gpa: float) -> str:\n    \"\"\"\n    Convert a numeric GPA to a letter grade based on the specified thresholds.\n    \"\"\"\n    if not isinstance(gpa, (int, float)):\n        raise TypeError(\"gpa must be an int or float\")\n    if gpa < 0.0 or gpa > 4.0:\n        raise ValueError(\"gpa must be between 0.0 and 4.0 inclusive\")\n\n    # Exact 4.0 is A+\n    if gpa == 4.0:\n        return \"A+\"\n\n    # Use strict greater-than comparisons as per specification\n    if gpa > 3.7:\n        return \"A\"\n    if gpa > 3.3:\n        return \"A-\"\n    if gpa > 3.0:\n        return \"B+\"\n    if gpa > 2.7:\n        return \"B\"\n    if gpa > 2.3:\n        return \"B-\"\n    if gpa > 2.0:\n        return \"C+\"\n    if gpa > 1.7:\n        return \"C\"\n    if gpa > 1.3:\n        return \"C-\"\n    if gpa > 1.0:\n        return \"D+\"\n    if gpa > 0.7:\n        return \"D\"\n    if gpa > 0.0:\n        return \"D-\"\n    return \"E\"\n\n\ndef numerical_letter_grade(grades: List[Any]) -> List[str]:\n    \"\"\"\n    Main function that converts a list of GPAs to their corresponding letter grades.\n    \"\"\"\n    validated = validate_and_sanitize_gpa_list(grades)\n    return [convert_gpa_to_letter(gpa) for gpa in validated]",
          "tests_passed": 6,
          "total_tests": 6,
          "time": 1435.8953659534454,
          "iterations_used": 2
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "prime_length",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import Any\n\nimport logging\n\nlogger = logging.getLogger(__name__)\nlogging.basicConfig(level=logging.DEBUG)\n\n\ndef validate_string_input(input_value: str) -> str:\n    \"\"\"Validate that the input is a non\u2011empty string.\"\"\"\n    if input_value is None:\n        raise ValueError(\"input_value cannot be None\")\n    if not isinstance(input_value, str):\n        raise TypeError(f\"Expected a string, got {type(input_value).__name__}\")\n    return input_value\n\n\ndef is_prime_length(s: str) -> bool:\n    \"\"\"Return True if the length of s is a prime number.\"\"\"\n    length = len(s)\n    if length <= 1:\n        return False\n    if length == 2:\n        return True\n    if length % 2 == 0:\n        return False\n    i = 3\n    max_divisor = int(length ** 0.5) + 1\n    while i <= max_divisor:\n        if length % i == 0:\n            return False\n        i += 2\n    return True\n\n\ndef fallback_function(result: bool) -> bool:\n    \"\"\"Return the computed result.\"\"\"\n    return result\n\n\ndef prime_length(string: str) -> bool:\n    \"\"\"Main function that checks if the string length is prime.\"\"\"\n    processed = validate_string_input(string)\n    processed = is_prime_length(processed)\n    return fallback_function(processed)",
          "tests_passed": 16,
          "total_tests": 16,
          "time": 1528.1127841472626,
          "iterations_used": 2
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "starts_one_ends",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import Any\n\ndef validate_positive_integer(n):\n    try:\n        if not isinstance(n, int) or isinstance(n, bool):\n            raise TypeError('Input must be an integer.')\n        if n <= 0:\n            raise ValueError('Input must be a positive integer.')\n        return n\n    except TypeError as te:\n        raise ValueError(str(te)) from te\n    except ValueError:\n        raise\n    except Exception as e:\n        raise ValueError(f'Unexpected error: {e}') from e\n\ndef count_start_or_end_with_one(n):\n    if n == 1:\n        return 1\n    power = pow(10, n-2)\n    result = 18 * power\n    assert result >= 0\n    return result\n\ndef fallback_function(value: Any) -> Any:\n    return value\n\ndef starts_one_ends(n) -> Any:\n    processed = validate_positive_integer(n)\n    processed = count_start_or_end_with_one(processed)\n    return fallback_function(processed)",
          "tests_passed": 5,
          "total_tests": 5,
          "time": 710.2419679164886,
          "iterations_used": 2
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "solve",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import List, Any, Optional, Union, Tuple, Dict\n\ndef validate_input(N):\n    # REASONING: Validate input type and range\n    try:\n        n = int(N)\n    except (TypeError, ValueError):\n        # REASONING: N is not convertible to int\n        raise ValueError('N must be an integer') from None\n\n    # REASONING: Ensure n is within [0, 10000]\n    if n < 0:\n        # REASONING: Negative values are out of bounds; clamp to 0\n        n = 0\n    elif n > 10000:\n        # REASONING: Values above max are out of bounds; clamp to 10000\n        n = 10000\n\n    # REASONING: Postcondition: n is int within bounds\n    assert 0 <= n <= 10000, 'Postcondition failed: n out of bounds'\n\n    return n\n\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n\ndef compute_digit_sum(N):\n    \"\"\"Return the sum of the decimal digits of an integer N.\n\n    REASONING: The function validates that N is an integer, handles the\n    special case where N is zero, and then processes the absolute value\n    of N to support negative inputs. The core digit-summing loop is\n    wrapped in a try/except block to catch any unexpected runtime\n    errors and raise a descriptive exception. Assertions ensure the\n    postcondition that the result is a non\u2011negative integer.\n    \"\"\"\n    # REASONING: Validate input type to prevent accidental misuse.\n    if not isinstance(N, int):\n        raise TypeError(\"N must be an integer\")\n\n    # REASONING: Edge case where N is zero; sum of digits is zero.\n    if N == 0:\n        return 0\n\n    # REASONING: Use absolute value to handle negative numbers.\n    abs_N = abs(N)\n\n    try:\n        digit_sum = 0\n        # REASONING: Iterate over each digit by repeatedly taking modulus 10.\n        while abs_N > 0:\n            digit_sum += abs_N % 10\n            abs_N //= 10\n        # REASONING: Assert that the result meets the postcondition.\n        assert isinstance(digit_sum, int) and digit_sum >= 0\n        return digit_sum\n    except Exception as e:\n        # REASONING: Convert any unexpected exception into a ValueError\n        # with context for easier debugging.\n        raise ValueError(\"Failed to compute digit sum\") from e\n\nimport logging\n\n# Configure a module-level logger\nlogger = logging.getLogger(__name__)\nlogger.addHandler(logging.NullHandler())\n\n\ndef convert_to_binary(number):\n    \"\"\"Convert a non-negative integer to its binary string representation.\n\n    Parameters:\n        number (int): The integer to convert.\n\n    Returns:\n        str: Binary representation of the integer.\n\n    Raises:\n        TypeError: If the input is not an integer.\n        ValueError: If the input is negative.\n    \"\"\"\n    # REASONING: Validate that input is not None and is an integer\n    if number is None:\n        logger.error(\"Input is None\")\n        raise TypeError(\"Input cannot be None\")\n    if not isinstance(number, int):\n        logger.error(f\"Invalid type: {type(number).__name__}\")\n        raise TypeError(f\"Expected int, got {type(number).__name__}\")\n\n    # REASONING: Negative numbers are not supported in this implementation\n    if number < 0:\n        logger.error(\"Negative number provided\")\n        raise ValueError(\"Negative numbers are not supported\")\n\n    # REASONING: Handle the special case where number is 0\n    if number == 0:\n        logger.debug(\"Number is zero; returning '0'\")\n        return \"0\"\n\n    # REASONING: Convert number to binary string using built-in function\n    try:\n        binary_str = bin(number)[2:]  # strip '0b' prefix\n        logger.debug(f\"Built-in conversion succeeded: {binary_str}\")\n    except Exception as e:\n        # REASONING: Fallback to manual conversion if built-in fails\n        logger.warning(f\"Built-in conversion failed: {e}. Using manual method.\")\n        binary_str = \"\"\n        temp = number\n        while temp > 0:\n            binary_str = str(temp % 2) + binary_str\n            temp //= 2\n        logger.debug(f\"Manual conversion result: {binary_str}\")\n\n    # REASONING: Ensure the result is a string of '0' and '1'\n    assert isinstance(binary_str, str), \"Result is not a string\"\n    assert all(c in '01' for c in binary_str), \"Result contains invalid characters\"\n\n    return binary_str\n\n\ndef solve(N) -> Any:\n    \"\"\"\n    Main function that integrates all modular components to solve the problem.\n    Generated by Modular ToT Self-Reflective Architecture.\n    \"\"\"\n    # Module execution chain\n    processed = validate_input(N)\n    processed = compute_digit_sum(processed)\n    return convert_to_binary(processed)\n",
          "tests_passed": 5,
          "total_tests": 5,
          "time": 1701.074862241745,
          "iterations_used": 1
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "anti_shuffle",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import Any\n\ndef validate_and_sanitize_input(input_value: Any) -> str:\n    \"\"\"\n    Validate that input_value is a string and return it unchanged.\n    Raises TypeError if input_value is None or not a string.\n    \"\"\"\n    if input_value is None:\n        raise TypeError(\"input_value must not be None\")\n    if not isinstance(input_value, str):\n        raise TypeError(f\"Expected a string, got {type(input_value).__name__}\")\n    return input_value\n\ndef sort_word(word: str) -> str:\n    \"\"\"\n    Return a new string with the characters of `word` sorted in ascending ASCII order.\n    \"\"\"\n    return ''.join(sorted(word))\n\ndef anti_shuffle(s: Any) -> str:\n    \"\"\"\n    Return an ordered version of the input string where each word (sequence of\n    non-space characters) is replaced by its characters sorted in ascending\n    ASCII order. Spaces are preserved exactly as in the original string.\n    \"\"\"\n    text = validate_and_sanitize_input(s)\n\n    # If the string is empty or contains only whitespace, return it unchanged.\n    if text == '' or text.isspace():\n        return text\n\n    import re\n    # Split into tokens of non-space characters or whitespace.\n    tokens = re.findall(r'\\S+|\\s+', text)\n\n    sorted_tokens = []\n    for token in tokens:\n        if token.isspace():\n            sorted_tokens.append(token)\n        else:\n            sorted_tokens.append(sort_word(token))\n\n    return ''.join(sorted_tokens)",
          "tests_passed": 7,
          "total_tests": 7,
          "time": 1407.0586450099945,
          "iterations_used": 2
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "get_row",
      "samples": [
        {
          "sample_id": 1,
          "passed": false,
          "solution": "def get_row(lst, x):\n    if not isinstance(lst, list):\n        raise ValueError(\"First argument must be a list.\")\n    if not isinstance(x, int):\n        raise ValueError(\"Second argument must be an integer.\")\n    coords = []\n    for i, row in enumerate(lst):\n        if not isinstance(row, list):\n            raise ValueError(\"Each row must be a list.\")\n        for j, val in enumerate(row):\n            if not isinstance(val, int):\n                raise ValueError(\"All elements must be integers.\")\n            if val == x:\n                coords.append((i, j))\n    coords.sort(key=lambda p: (p[0], -p[1]))\n    return coords",
          "tests_passed": 3,
          "total_tests": 6,
          "time": 307.7812840938568,
          "iterations_used": 3
        }
      ],
      "num_passed": 0,
      "num_samples": 1
    },
    {
      "problem": "sort_array",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import List, Any\n\ndef validate_input_array(input_array: List[int]) -> List[int]:\n    if not isinstance(input_array, list):\n        raise TypeError('input_array must be a list')\n    for idx, element in enumerate(input_array):\n        if not isinstance(element, int):\n            raise ValueError(f'Element at index {idx} is not an integer')\n        if element < 0:\n            raise ValueError(f'Element at index {idx} is negative')\n    return list(input_array)  # return a shallow copy\n\ndef determine_sort_order(arr: List[int]) -> str:\n    if not arr:\n        return 'asc'\n    total = arr[0] + arr[-1]\n    return 'asc' if total % 2 == 1 else 'desc'\n\ndef sort_array(array: List[int]) -> List[int]:\n    arr = validate_input_array(array)\n    order = determine_sort_order(arr)\n    return sorted(arr) if order == 'asc' else sorted(arr, reverse=True)",
          "tests_passed": 7,
          "total_tests": 7,
          "time": 364.304386138916,
          "iterations_used": 2
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "encrypt",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import List, Any, Optional, Union, Tuple, Dict\n\ndef sanitize_input(input_str):\n    # REASONING: Validate that the input is a string before proceeding.\n    if not isinstance(input_str, str):\n        return None\n    try:\n        # REASONING: Strip whitespace to accurately detect emptiness.\n        stripped = input_str.strip()\n        if not stripped:\n            # REASONING: Empty string after stripping is considered invalid.\n            return None\n        # REASONING: Ensure all characters are alphabetic.\n        if not stripped.isalpha():\n            # REASONING: Presence of non-alphabetic characters invalidates the input.\n            return None\n        # REASONING: Convert the validated string to lowercase for consistency.\n        result = stripped.lower()\n        # REASONING: Postcondition assertion guarantees the result is alphabetic and lowercase.\n        assert result.isalpha() and result == result.lower()\n        return result\n    except Exception as e:\n        # REASONING: Log unexpected errors and provide a graceful fallback.\n        import logging\n        logging.exception('Unexpected error in sanitize_input')\n        return None\n\nimport logging\n\nlogging.basicConfig(level=logging.DEBUG)\n\ndef encrypt_core(sanitized_str):\n    # REASONING: Validate input type\n    if not isinstance(sanitized_str, str):\n        raise TypeError('Input must be a string')\n    # REASONING: Ensure string is not None\n    if sanitized_str is None:\n        raise ValueError('Input cannot be None')\n    # REASONING: Empty string is allowed; return empty\n    if sanitized_str == '':\n        return ''\n    # REASONING: Prepare result list\n    result_chars = []\n    try:\n        for idx, ch in enumerate(sanitized_str):\n            # REASONING: Process only alphabetic characters\n            if ch.isalpha():\n                # Determine base ASCII for case\n                base = ord('A') if ch.isupper() else ord('a')\n                # Compute shifted position with wrap-around\n                offset = (ord(ch) - base + 4) % 26\n                new_char = chr(base + offset)\n                result_chars.append(new_char)\n            else:\n                # REASONING: Non-alphabetic characters are left unchanged\n                result_chars.append(ch)\n    except Exception as e:\n        # REASONING: Log unexpected errors and re-raise\n        logging.exception('Error during encryption')\n        raise e\n    # REASONING: Postcondition: output length matches input length\n    assert len(result_chars) == len(sanitized_str), 'Output length mismatch'\n    return ''.join(result_chars)\n\ndef format_output(encrypted_str):\n    # REASONING: Configure logging once\n    import logging\n    logging.basicConfig(level=logging.INFO)\n    logger = logging.getLogger(__name__)\n\n    # REASONING: Validate input type\n    try:\n        if not isinstance(encrypted_str, str):\n            raise TypeError('encrypted_str must be a string')\n        # REASONING: Assert precondition\n        assert isinstance(encrypted_str, str), 'Precondition failed: encrypted_str must be a string'\n\n        # REASONING: Process the encrypted string (here we simply return it)\n        result = encrypted_str\n\n        # REASONING: Assert postcondition\n        assert isinstance(result, str), 'Postcondition failed: result must be a string'\n\n        return result\n\n    except TypeError as te:\n        # REASONING: Handle specific type error by logging and returning fallback\n        logger.error('TypeError: %s', te)\n        return ''\n\n    except Exception as e:\n        # REASONING: Handle unexpected errors gracefully\n        logger.exception('Unexpected error: %s', e)\n        return ''\n\n\ndef encrypt(s) -> Any:\n    \"\"\"\n    Main function that integrates all modular components to solve the problem.\n    Generated by Modular ToT Self-Reflective Architecture.\n    \"\"\"\n    # Module execution chain\n    processed = sanitize_input(s)\n    processed = encrypt_core(processed)\n    return format_output(processed)\n",
          "tests_passed": 8,
          "total_tests": 8,
          "time": 638.7515001296997,
          "iterations_used": 1
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "next_smallest",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import List, Optional, Any\n\ndef validate_input(lst: Any) -> Optional[List[int]]:\n    \"\"\"\n    Validate that the input is a list of integers.\n    Return the list if valid, otherwise return None.\n    \"\"\"\n    if not isinstance(lst, list):\n        return None\n    if any(not isinstance(x, int) for x in lst):\n        return None\n    return lst\n\ndef find_second_smallest(lst: List[int]) -> Optional[int]:\n    \"\"\"\n    Return the second smallest distinct integer in the list.\n    If there are fewer than two distinct values, return None.\n    \"\"\"\n    unique_vals = sorted(set(lst))\n    if len(unique_vals) < 2:\n        return None\n    return unique_vals[1]\n\ndef next_smallest(lst: Any) -> Optional[int]:\n    \"\"\"\n    Return the second smallest distinct integer in lst or None on failure.\n    \"\"\"\n    validated = validate_input(lst)\n    if validated is None:\n        return None\n    return find_second_smallest(validated)",
          "tests_passed": 7,
          "total_tests": 7,
          "time": 389.55825114250183,
          "iterations_used": 2
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "is_bored",
      "samples": [
        {
          "sample_id": 1,
          "passed": false,
          "solution": "from typing import Any\n\nimport logging\n\n# Configure logger for this module\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.DEBUG)\nif not logger.handlers:\n    handler = logging.StreamHandler()\n    formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')\n    handler.setFormatter(formatter)\n    logger.addHandler(handler)\n\n\ndef validate_and_sanitize_input(input_str: str) -> str:\n    \"\"\"\n    Validate that input_str is a string and trim surrounding whitespace.\n    Empty strings are allowed and returned as an empty string.\n    Raises ValueError if input_str is None.\n    \"\"\"\n    if input_str is None:\n        logger.debug(\"Input is None\")\n        raise ValueError(\"Input cannot be None\")\n    if not isinstance(input_str, str):\n        logger.debug(f\"Input type is {type(input_str).__name__}, expected str\")\n        raise TypeError(\"Input must be a string\")\n\n    sanitized = input_str.strip()\n    logger.debug(f\"Sanitized input: '{sanitized}'\")\n    return sanitized\n\n\ndef count_boredoms(text: str) -> int:\n    \"\"\"\n    Count sentences that start with the word 'I'.\n    Sentences are delimited by '.', '?' or '!'.\n    \"\"\"\n    if not isinstance(text, str):\n        raise TypeError(\"Input must be a string.\")\n    if text is None:\n        raise ValueError(\"Input cannot be None.\")\n\n    if not text:\n        return 0\n\n    count = 0\n    try:\n        import re\n        sentences = re.split(r'[.!?]+', text)\n        for sentence in sentences:\n            trimmed = sentence.strip()\n            if not trimmed:\n                continue\n            if trimmed.startswith('I'):\n                count += 1\n    except re.error as regex_err:\n        logger.error(f\"Regex error during sentence splitting: {regex_err}\")\n        if text.strip().startswith('I'):\n            count = 1\n    except Exception as exc:\n        logger.exception(f\"Unexpected error: {exc}\")\n        count = 0\n\n    assert isinstance(count, int) and count >= 0, \"Count must be a non-negative integer.\"\n    return count\n\n\ndef is_bored(S: str) -> Any:\n    \"\"\"\n    Main function that integrates all modular components to solve the problem.\n    \"\"\"\n    processed = validate_and_sanitize_input(S)\n    return count_boredoms(processed)",
          "tests_passed": 5,
          "total_tests": 6,
          "time": 1246.4708979129791,
          "iterations_used": 3
        }
      ],
      "num_passed": 0,
      "num_samples": 1
    },
    {
      "problem": "any_int",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import Tuple, Optional\n\ndef validate_and_sanitize_inputs(x, y, z) -> Tuple[bool, Optional[Tuple[int, int, int]]]:\n    \"\"\"\n    Validate that all inputs are integers.\n    Returns (True, (x, y, z)) if valid, otherwise (False, None).\n    \"\"\"\n    if not all(isinstance(v, int) for v in (x, y, z)):\n        return False, None\n    return True, (x, y, z)\n\ndef check_sum_condition(a: int, b: int, c: int) -> bool:\n    \"\"\"\n    Return True if any one of the numbers equals the sum of the other two.\n    \"\"\"\n    return (a == b + c) or (b == a + c) or (c == a + b)\n\ndef any_int(x, y, z) -> bool:\n    \"\"\"\n    Main function that checks if all inputs are integers and if one equals\n    the sum of the other two.\n    \"\"\"\n    valid, vals = validate_and_sanitize_inputs(x, y, z)\n    if not valid:\n        return False\n    a, b, c = vals\n    return check_sum_condition(a, b, c)",
          "tests_passed": 10,
          "total_tests": 10,
          "time": 3186.411840200424,
          "iterations_used": 2
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "encode",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "def encode(message: str) -> str:\n    \"\"\"\n    Encode a message by swapping the case of all letters and replacing\n    each vowel with the letter that appears two places ahead in the\n    English alphabet.\n\n    Parameters\n    ----------\n    message : str\n        The input string containing only letters and spaces.\n\n    Returns\n    -------\n    str\n        The encoded string.\n    \"\"\"\n    vowels = set(\"AEIOUaeiou\")\n    result = []\n\n    for ch in message:\n        if ch.isalpha():\n            swapped = ch.swapcase()\n            if swapped in vowels:\n                # Move two positions forward in the alphabet\n                swapped = chr(ord(swapped) + 2)\n            result.append(swapped)\n        else:\n            # Preserve non-letter characters (e.g., spaces)\n            result.append(ch)\n\n    return \"\".join(result)",
          "tests_passed": 5,
          "total_tests": 5,
          "time": 1562.1106560230255,
          "iterations_used": 3
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "skjkasdkd",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import List, Any\n\ndef validate_input(lst):\n    \"\"\"Validate that lst is a non-empty list of integers.\"\"\"\n    if not isinstance(lst, list):\n        return False\n    if not lst:\n        return False\n    return all(isinstance(item, int) for item in lst)\n\ndef is_prime(n: int) -> bool:\n    \"\"\"Return True if n is a prime number, False otherwise.\"\"\"\n    if n < 2:\n        return False\n    small_primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    for p in small_primes:\n        if n % p == 0:\n            return n == p\n    d = n - 1\n    s = 0\n    while d % 2 == 0:\n        d //= 2\n        s += 1\n    for a in small_primes:\n        if a >= n:\n            continue\n        x = pow(a, d, n)\n        if x == 1 or x == n - 1:\n            continue\n        for _ in range(s - 1):\n            x = pow(x, 2, n)\n            if x == n - 1:\n                break\n        else:\n            return False\n    return True\n\ndef find_largest_prime(lst: List[int]) -> Any:\n    \"\"\"Return the largest prime number in lst or None if none exist.\"\"\"\n    primes = [item for item in lst if item > 1 and is_prime(item)]\n    return max(primes) if primes else None\n\ndef sum_digits(number: int) -> int:\n    \"\"\"Compute the sum of decimal digits of a given integer.\"\"\"\n    if number < 0:\n        raise ValueError(\"Negative numbers are not supported.\")\n    return sum(int(d) for d in str(number))\n\ndef skjkasdkd(lst: List[int]) -> int:\n    \"\"\"Main function to find largest prime in lst and return sum of its digits.\"\"\"\n    if not validate_input(lst):\n        return 0\n    largest_prime = find_largest_prime(lst)\n    if largest_prime is None:\n        return 0\n    return sum_digits(largest_prime)",
          "tests_passed": 9,
          "total_tests": 9,
          "time": 655.0040578842163,
          "iterations_used": 2
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "check_dict_case",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import Any, Dict\n\ndef validate_dict_input(input_dict: Any) -> Dict | None:\n    \"\"\"\n    Validate that the input is a non\u2011empty dictionary with all string keys.\n    Return the dictionary if valid, otherwise return None.\n    \"\"\"\n    if not isinstance(input_dict, dict):\n        return None\n    if not input_dict:\n        return None\n    if not all(isinstance(k, str) for k in input_dict):\n        return None\n    return input_dict\n\ndef evaluate_dict_case(input_dict: Dict[str, Any]) -> bool:\n    \"\"\"\n    Return True if all keys are either all lower\u2011case or all upper\u2011case.\n    \"\"\"\n    all_lower = all(k.islower() for k in input_dict)\n    all_upper = all(k.isupper() for k in input_dict)\n    return all_lower or all_upper\n\ndef check_dict_case(d: Any) -> bool:\n    \"\"\"\n    Main function that integrates validation and evaluation.\n    \"\"\"\n    processed = validate_dict_input(d)\n    if processed is None:\n        return False\n    return evaluate_dict_case(processed)",
          "tests_passed": 7,
          "total_tests": 7,
          "time": 245.63497805595398,
          "iterations_used": 2
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "count_up_to",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import List, Any, Optional, Union, Tuple, Dict\n\ndef validate_and_sanitize_input(n):\n    '''\n    Validate that n is a non-negative integer.\n    Raises:\n        TypeError: if n is not an int.\n        ValueError: if n is negative.\n    Returns:\n        int: the validated non-negative integer.\n    '''\n    # REASONING: Use try/finally to satisfy requirement that all try blocks have except or finally.\n    try:\n        # REASONING: Assert that n is not None to catch None early.\n        assert n is not None, 'Input cannot be None'\n        # REASONING: Check type explicitly to provide clear error message.\n        if not isinstance(n, int):\n            raise TypeError(f'Expected int, got {type(n).__name__}')\n        # REASONING: Ensure non-negative value.\n        if n < 0:\n            raise ValueError(f'Negative value not allowed: {n}')\n        # REASONING: Postcondition: n is int and >=0\n        assert isinstance(n, int) and n >= 0, 'Postcondition failed'\n        return n\n    finally:\n        # REASONING: No cleanup needed, but finally ensures try block compliance.\n        pass\n\ndef generate_primes_less_than(n):\n    # REASONING: Validate input type and range\n    if not isinstance(n, int):\n        raise TypeError(\"n must be an integer\")\n    if n < 0:\n        raise ValueError(\"n must be non-negative\")\n    # REASONING: For n <= 2, there are no primes less than n\n    if n <= 2:\n        return []\n    # REASONING: Use Sieve of Eratosthenes up to n-1\n    try:\n        sieve = [True] * n\n        sieve[0:2] = [False, False]  # 0 and 1 are not primes\n        limit = int(n**0.5) + 1\n        for i in range(2, limit):\n            if sieve[i]:\n                step = i\n                start = i*i\n                sieve[start:n:step] = [False] * len(range(start, n, step))\n        primes = [i for i, is_prime in enumerate(sieve) if is_prime]\n        # REASONING: Ensure output is sorted and contains only primes < n\n        assert all(isinstance(p, int) for p in primes)\n        assert all(p < n for p in primes)\n        return primes\n    except MemoryError as me:\n        # REASONING: Handle memory errors gracefully\n        raise MemoryError(\"Failed to allocate memory for sieve\") from me\n    except Exception as e:\n        # REASONING: Catch unexpected errors and provide context\n        raise RuntimeError(\"An unexpected error occurred during prime generation\") from e\n\nimport logging\nlogger = logging.getLogger(__name__)\n\ndef format_primes_output(primes):\n    # REASONING: Validate that primes is a list or None\n    if primes is None:\n        # REASONING: Treat None as empty list\n        return []\n    if not isinstance(primes, list):\n        raise TypeError('primes must be a list')\n    # REASONING: Ensure list elements are integers and >=2\n    try:\n        for idx, p in enumerate(primes):\n            if not isinstance(p, int):\n                raise ValueError(f'Element at index {idx} is not an integer')\n            if p < 2:\n                raise ValueError(f'Element at index {idx} is less than 2')\n    except Exception as e:\n        # REASONING: Log the error before re-raising\n        logger.exception('Invalid primes list')\n        raise\n    # REASONING: Return a copy to avoid side effects\n    result = primes.copy()\n    # REASONING: Postcondition: result is list of ints\n    assert isinstance(result, list)\n    return result\n\n\ndef count_up_to(n) -> Any:\n    \"\"\"\n    Main function that integrates all modular components to solve the problem.\n    Generated by Modular ToT Self-Reflective Architecture.\n    \"\"\"\n    # Module execution chain\n    processed = validate_and_sanitize_input(n)\n    processed = generate_primes_less_than(processed)\n    return format_primes_output(processed)\n",
          "tests_passed": 10,
          "total_tests": 10,
          "time": 1848.371259212494,
          "iterations_used": 1
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "multiply",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import Any\n\ndef extract_unit_digit(number: int) -> int:\n    \"\"\"Return the unit digit of an integer, handling negatives.\"\"\"\n    if not isinstance(number, int):\n        raise TypeError(\"Input must be an integer.\")\n    return abs(number) % 10\n\ndef unit_digit_product(a: int, b: int) -> int:\n    \"\"\"Return the product of the unit digits of two integers.\"\"\"\n    if not isinstance(a, int) or isinstance(a, bool):\n        raise TypeError(\"First argument must be an integer.\")\n    if not isinstance(b, int) or isinstance(b, bool):\n        raise TypeError(\"Second argument must be an integer.\")\n    return extract_unit_digit(a) * extract_unit_digit(b)\n\ndef multiply(a: int, b: int) -> Any:\n    \"\"\"Return the product of the unit digits of a and b.\"\"\"\n    return unit_digit_product(a, b)",
          "tests_passed": 8,
          "total_tests": 8,
          "time": 258.6996307373047,
          "iterations_used": 2
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "count_upper",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import Any\n\ndef count_uppercase_vowels_even_indices(s: str) -> int:\n    \"\"\"\n    Count the number of uppercase vowels in even indices of the string `s`.\n    \"\"\"\n    if not isinstance(s, str):\n        raise TypeError(\"Input must be a string.\")\n    uppercase_vowels = {'A', 'E', 'I', 'O', 'U'}\n    count = 0\n    for idx, char in enumerate(s):\n        if idx % 2 == 0 and char in uppercase_vowels:\n            count += 1\n    return count\n\ndef count_upper(s: Any) -> int:\n    \"\"\"\n    Main function that returns the count of uppercase vowels at even indices.\n    \"\"\"\n    return count_uppercase_vowels_even_indices(s)",
          "tests_passed": 7,
          "total_tests": 7,
          "time": 1005.4180190563202,
          "iterations_used": 2
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "closest_integer",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import Any\n\ndef validate_and_sanitize_input(value: str) -> str:\n    '''Validate and sanitize input string for decimal number.'''\n    if not isinstance(value, str):\n        raise TypeError('Input must be a string')\n    cleaned = value.strip()\n    if cleaned == '':\n        raise ValueError('Input string is empty or only whitespace')\n    from decimal import Decimal, InvalidOperation\n    try:\n        Decimal(cleaned)\n    except InvalidOperation:\n        raise ValueError(f'Invalid decimal number: {value!r}')\n    return cleaned\n\ndef compute_closest_integer(cleaned_value: str) -> int:\n    '''Round the decimal string to the nearest integer, rounding .5 away from zero.'''\n    assert isinstance(cleaned_value, str), 'Input must be a string'\n    assert cleaned_value.strip() != '', 'Input string cannot be empty'\n    from decimal import Decimal, getcontext, ROUND_HALF_UP, InvalidOperation\n    try:\n        digits = len(cleaned_value.replace('.', '').replace('-', '').replace('+', '').lstrip('0'))\n        getcontext().prec = max(digits + 10, 28)\n    except Exception:\n        pass\n    try:\n        value = Decimal(cleaned_value)\n    except (InvalidOperation, ValueError) as e:\n        raise ValueError('Invalid numeric string: %s' % cleaned_value) from e\n    rounded = value.to_integral_value(rounding=ROUND_HALF_UP)\n    return int(rounded)\n\ndef format_output_or_handle_error(result: int | Exception) -> int:\n    '''Return the computed integer or raise a descriptive exception if an error occurred.'''\n    import logging\n    logger = logging.getLogger(__name__)\n    logger.debug(f'Entered format_output_or_handle_error with result: {result!r}')\n    if result is None:\n        raise ValueError('Result cannot be None')\n    if isinstance(result, Exception):\n        raise result\n    if not isinstance(result, int):\n        raise TypeError(f'Result must be an int, got {type(result).__name__}')\n    logger.debug(f'format_output_or_handle_error returning: {result}')\n    return result\n\ndef closest_integer(value) -> int:\n    '''Return the closest integer to the given numeric string, rounding .5 away from zero.'''\n    processed = validate_and_sanitize_input(value)\n    processed = compute_closest_integer(processed)\n    return format_output_or_handle_error(processed)",
          "tests_passed": 5,
          "total_tests": 5,
          "time": 9629.674741983414,
          "iterations_used": 3
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "make_a_pile",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import List, Any\n\ndef validate_and_sanitize_input(n: Any) -> int:\n    \"\"\"\n    Validate that n is a positive integer.\n    Raises ValueError if n is not an int or <= 0.\n    Returns the integer n if valid.\n    \"\"\"\n    if n is None:\n        raise ValueError(\"Input cannot be None\")\n    if not isinstance(n, int):\n        raise ValueError(\"Input must be an integer\")\n    if n <= 0:\n        raise ValueError(\"Input must be a positive integer\")\n    return n\n\ndef generate_pile_levels(n: int) -> List[int]:\n    \"\"\"\n    Compute stone counts for each level based on the rule:\n    start with n and add 2 for each subsequent level.\n    \"\"\"\n    return [n + 2 * k for k in range(n)]\n\ndef format_and_handle_output(levels: List[int]) -> List[int]:\n    \"\"\"\n    Return the list of integers as is.\n    \"\"\"\n    if not isinstance(levels, list):\n        raise TypeError(\"levels must be a list\")\n    return levels\n\ndef make_a_pile(n: Any) -> List[int]:\n    \"\"\"\n    Main function that integrates all modular components to solve the problem.\n    \"\"\"\n    validated_n = validate_and_sanitize_input(n)\n    levels = generate_pile_levels(validated_n)\n    return format_and_handle_output(levels)",
          "tests_passed": 5,
          "total_tests": 5,
          "time": 14241.128286838531,
          "iterations_used": 2
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "words_string",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import List, Any\n\ndef fallback_function(s: str) -> str:\n    \"\"\"\n    Identity function that simply returns the input string.\n    \"\"\"\n    return s\n\ndef split_words_into_list(sanitized_str: str) -> List[str]:\n    \"\"\"\n    Split a string into words using commas or whitespace as separators.\n    \"\"\"\n    if not isinstance(sanitized_str, str):\n        raise TypeError(\"sanitized_str must be a string\")\n    stripped = sanitized_str.strip()\n    if not stripped:\n        return []\n    import re\n    tokens = re.split(r'[,\\s]+', stripped)\n    words = [token for token in tokens if token]\n    return words\n\ndef words_string(s: str) -> List[str]:\n    \"\"\"\n    Main function that splits a string of words separated by commas or spaces\n    into a list of individual words.\n    \"\"\"\n    processed = fallback_function(s)\n    return split_words_into_list(processed)",
          "tests_passed": 6,
          "total_tests": 6,
          "time": 1671.0680570602417,
          "iterations_used": 2
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "choose_num",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import Tuple\n\ndef validate_inputs(x: int, y: int) -> Tuple[bool, str]:\n    \"\"\"\n    Validate that x and y are positive integers.\n    Returns a tuple (is_valid, message).\n    \"\"\"\n    if not isinstance(x, int) or not isinstance(y, int):\n        return False, \"x and y must be integers\"\n    if x <= 0 or y <= 0:\n        return False, \"x and y must be positive integers\"\n    return True, \"Inputs are valid\"\n\ndef find_largest_even_in_range(x: int, y: int) -> int:\n    \"\"\"\n    Return the largest even integer in the inclusive range [x, y].\n    If no even integer exists, return -1.\n    \"\"\"\n    largest_even = y if y % 2 == 0 else y - 1\n    return largest_even if largest_even >= x else -1\n\ndef choose_num(x: int, y: int) -> int:\n    \"\"\"\n    Main function that validates inputs and returns the largest even integer\n    in the inclusive range [x, y], or -1 if none exists.\n    \"\"\"\n    valid, msg = validate_inputs(x, y)\n    if not valid:\n        raise ValueError(msg)\n    return find_largest_even_in_range(x, y)",
          "tests_passed": 8,
          "total_tests": 8,
          "time": 348.59136486053467,
          "iterations_used": 3
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "rounded_avg",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import Any\n\ndef validate_inputs(n: int, m: int) -> bool:\n    \"\"\"Return True if inputs are valid (positive integers and n <= m).\"\"\"\n    return isinstance(n, int) and isinstance(m, int) and n > 0 and m > 0 and n <= m\n\ndef compute_rounded_avg(n: int, m: int) -> int:\n    \"\"\"Compute the rounded average of integers from n to m inclusive.\"\"\"\n    count = m - n + 1\n    total = (n + m) * count // 2\n    avg = total / count\n    return int(round(avg))\n\ndef format_output(avg: int) -> str:\n    \"\"\"Convert the integer average to a binary string prefixed with '0b'.\"\"\"\n    return bin(avg)\n\ndef rounded_avg(n: int, m: int) -> Any:\n    \"\"\"Main function to compute the rounded average and return binary string or -1.\"\"\"\n    if not validate_inputs(n, m):\n        return -1\n    avg = compute_rounded_avg(n, m)\n    return format_output(avg)",
          "tests_passed": 12,
          "total_tests": 12,
          "time": 291.7130780220032,
          "iterations_used": 2
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "unique_digits",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import List, Any\n\ndef validate_and_sanitize_input(input_list: List[Any]) -> List[int]:\n    \"\"\"Ensure the input is a list of positive integers.\"\"\"\n    if not isinstance(input_list, list):\n        raise TypeError(\"input_list must be a list\")\n    sanitized: List[int] = []\n    for item in input_list:\n        try:\n            value = int(item)\n        except (ValueError, TypeError):\n            continue\n        if value > 0:\n            sanitized.append(value)\n    if not sanitized:\n        raise ValueError(\"No valid positive integers found in input_list\")\n    return sanitized\n\ndef filter_numbers_without_even_digits(numbers: List[int]) -> List[int]:\n    \"\"\"Return numbers that contain no even digits.\"\"\"\n    result: List[int] = []\n    for num in numbers:\n        has_even_digit = False\n        for digit_char in str(num):\n            if int(digit_char) % 2 == 0:\n                has_even_digit = True\n                break\n        if not has_even_digit:\n            result.append(num)\n    return result\n\ndef unique_digits(x: List[Any]) -> List[int]:\n    \"\"\"Return a sorted list of positive integers from x that have no even digits.\"\"\"\n    processed = validate_and_sanitize_input(x)\n    processed = filter_numbers_without_even_digits(processed)\n    return sorted(processed)",
          "tests_passed": 4,
          "total_tests": 4,
          "time": 1044.9029848575592,
          "iterations_used": 2
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "by_length",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import List\n\ndef sanitize_input(arr: List) -> List[int]:\n    \"\"\"Return a list containing only integers between 1 and 9 inclusive.\"\"\"\n    if not isinstance(arr, list):\n        raise TypeError(\"Input must be a list\")\n    result: List[int] = []\n    for item in arr:\n        if isinstance(item, int) and 1 <= item <= 9:\n            result.append(item)\n    return result\n\ndef sort_and_reverse(nums: List[int]) -> List[int]:\n    \"\"\"Sort the list in ascending order and then reverse it.\"\"\"\n    if not isinstance(nums, list):\n        raise TypeError(\"Input must be a list\")\n    return sorted(nums, reverse=True)\n\ndef map_digits_to_names(nums: List[int]) -> List[str]:\n    \"\"\"Map each digit to its English name with the first letter capitalized.\"\"\"\n    digit_to_name = {\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\",\n    }\n    return [digit_to_name[n] for n in nums]\n\ndef by_length(arr: List[int]) -> List[str]:\n    \"\"\"Main function that processes the array as described.\"\"\"\n    cleaned = sanitize_input(arr)\n    if not cleaned:\n        return []\n    processed = sort_and_reverse(cleaned)\n    return map_digits_to_names(processed)",
          "tests_passed": 5,
          "total_tests": 5,
          "time": 1275.8676221370697,
          "iterations_used": 2
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "f",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import List, Any\nimport math\nimport logging\n\n# Configure module-level logger\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\ndef validate_n(n: Any) -> int:\n    \"\"\"\n    Validate that n is a positive integer.\n    Returns the validated integer.\n    Raises ValueError if validation fails.\n    \"\"\"\n    if n is None:\n        raise ValueError(\"n cannot be None\")\n    if not isinstance(n, int):\n        try:\n            n = int(n)\n        except (TypeError, ValueError):\n            raise ValueError(\"n must be an integer\") from None\n    if n < 1:\n        raise ValueError(\"n must be greater than or equal to 1\")\n    return n\n\ndef compute_f_sequence(n: int) -> List[int]:\n    \"\"\"\n    Compute the sequence described in the problem statement.\n    For each i from 1 to n:\n        - if i is even, use factorial(i)\n        - if i is odd, use sum of numbers from 1 to i\n    \"\"\"\n    result: List[int] = []\n    for i in range(1, n + 1):\n        if i % 2 == 0:\n            value = math.factorial(i)\n        else:\n            value = i * (i + 1) // 2  # sum 1..i\n        result.append(value)\n    return result\n\ndef f(n: Any) -> List[int]:\n    \"\"\"\n    Main function that validates input and returns the required sequence.\n    \"\"\"\n    validated_n = validate_n(n)\n    return compute_f_sequence(validated_n)",
          "tests_passed": 4,
          "total_tests": 4,
          "time": 707.6442749500275,
          "iterations_used": 2
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "even_odd_palindrome",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import Tuple, Any\n\nimport logging\n\n# Configure logger\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\ndef validate_and_sanitize_input(n: int) -> int:\n    \"\"\"\n    Validate that n is an integer within the allowed range [1, 1000].\n    \"\"\"\n    if not isinstance(n, int):\n        raise TypeError(f\"Expected int, got {type(n).__name__}\")\n    if n < 1 or n > 1000:\n        raise ValueError(\"n must be between 1 and 1000 inclusive\")\n    return n\n\ndef count_even_odd_palindromes(n: int) -> Tuple[int, int]:\n    \"\"\"\n    Count even and odd integer palindromes in the inclusive range 1..n.\n    \"\"\"\n    even_count = 0\n    odd_count = 0\n    for num in range(1, n + 1):\n        s = str(num)\n        if s == s[::-1]:\n            if num % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n    return even_count, odd_count\n\ndef format_result(even_count: int, odd_count: int) -> Tuple[int, int]:\n    \"\"\"\n    Validate and format the result tuple.\n    \"\"\"\n    if not isinstance(even_count, int) or not isinstance(odd_count, int):\n        raise TypeError(\"Counts must be integers\")\n    if even_count < 0 or odd_count < 0:\n        raise ValueError(\"Counts must be non-negative\")\n    return even_count, odd_count\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    \"\"\"\n    Main function that returns a tuple (even_count, odd_count) of integer palindromes\n    within the inclusive range 1..n.\n    \"\"\"\n    sanitized = validate_and_sanitize_input(n)\n    even, odd = count_even_odd_palindromes(sanitized)\n    return format_result(even, odd)",
          "tests_passed": 8,
          "total_tests": 8,
          "time": 467.4779598712921,
          "iterations_used": 2
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "count_nums",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import List, Any\n\ndef validate_and_sanitize_input(arr: Any) -> List[int]:\n    \"\"\"\n    Ensure the input is a list of integers.\n    \"\"\"\n    if not isinstance(arr, list):\n        raise ValueError(\"Input must be a list.\")\n    sanitized: List[int] = []\n    for idx, item in enumerate(arr):\n        if not isinstance(item, int):\n            raise ValueError(f\"All elements must be integers. Invalid element at index {idx}.\")\n        sanitized.append(item)\n    return sanitized\n\ndef compute_signed_digit_sum(n: int) -> int:\n    \"\"\"\n    Compute the signed digit sum of an integer.\n    The first digit carries the sign of the number; all other digits are positive.\n    \"\"\"\n    if not isinstance(n, int):\n        raise TypeError(\"Input must be an integer\")\n    if n == 0:\n        return 0\n    digits = [int(ch) for ch in str(abs(n))]\n    sign = -1 if n < 0 else 1\n    return sign * digits[0] + sum(digits[1:])\n\ndef count_nums_core(nums: List[int]) -> int:\n    \"\"\"\n    Count how many numbers in the list have a signed digit sum > 0.\n    \"\"\"\n    count = 0\n    for num in nums:\n        if compute_signed_digit_sum(num) > 0:\n            count += 1\n    return count\n\ndef count_nums(arr: Any) -> int:\n    \"\"\"\n    Main function that integrates all modular components to solve the problem.\n    \"\"\"\n    sanitized = validate_and_sanitize_input(arr)\n    return count_nums_core(sanitized)",
          "tests_passed": 8,
          "total_tests": 8,
          "time": 562.1862499713898,
          "iterations_used": 2
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "move_one_ball",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "import logging\nfrom typing import List\n\nlogger = logging.getLogger(__name__)\n\ndef validate_and_sanitize_input(arr: List[int]) -> List[int]:\n    if arr is None:\n        raise ValueError(\"Input cannot be None\")\n    if not isinstance(arr, list):\n        raise TypeError(\"Input must be a list\")\n    if len(arr) == 0:\n        return []\n    validated = []\n    for idx, item in enumerate(arr):\n        if not isinstance(item, int):\n            raise TypeError(f\"Element at index {idx} is not an integer: {item!r}\")\n        validated.append(item)\n    if len(set(validated)) != len(validated):\n        raise ValueError(\"Duplicate values found in input\")\n    return validated\n\ndef is_rotated_sorted(arr: List[int]) -> bool:\n    n = len(arr)\n    if n <= 1:\n        return True\n    inversion_count = 0\n    for i in range(n - 1):\n        if arr[i] > arr[i + 1]:\n            inversion_count += 1\n    if inversion_count == 0:\n        return True\n    if inversion_count == 1 and arr[-1] <= arr[0]:\n        return True\n    return False\n\ndef move_one_ball(arr: List[int]) -> bool:\n    processed = validate_and_sanitize_input(arr)\n    return is_rotated_sorted(processed)",
          "tests_passed": 5,
          "total_tests": 5,
          "time": 427.9075288772583,
          "iterations_used": 2
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "exchange",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "import logging\nfrom typing import List, Any\n\nlogging.basicConfig(level=logging.DEBUG)\nlogger = logging.getLogger(__name__)\n\ndef validate_and_sanitize_lists(lst1: List[int], lst2: List[int]) -> tuple:\n    \"\"\"Validate that both inputs are non\u2011empty lists of integers.\"\"\"\n    if not isinstance(lst1, list) or not isinstance(lst2, list):\n        raise TypeError(\"Both inputs must be lists.\")\n    if not lst1 or not lst2:\n        raise ValueError(\"Input lists must be non\u2011empty.\")\n    for lst in (lst1, lst2):\n        for i, item in enumerate(lst):\n            if not isinstance(item, int):\n                raise TypeError(f\"Non\u2011integer element in list at index {i}.\")\n    return lst1, lst2\n\ndef can_make_even(lst1: List[int], lst2: List[int]) -> bool:\n    \"\"\"Return True if lst1 can be made all even by swapping with evens from lst2.\"\"\"\n    odds_in_lst1 = sum(1 for x in lst1 if x % 2 != 0)\n    evens_in_lst2 = sum(1 for x in lst2 if x % 2 == 0)\n    logger.debug(f\"Odds in lst1: {odds_in_lst1}, Evens in lst2: {evens_in_lst2}\")\n    return odds_in_lst1 <= evens_in_lst2\n\ndef format_result(can_make: bool) -> str:\n    \"\"\"Format boolean result as 'YES' or 'NO'.\"\"\"\n    return \"YES\" if can_make else \"NO\"\n\ndef exchange(lst1: List[int], lst2: List[int]) -> str:\n    \"\"\"Main function to determine if lst1 can be made all even.\"\"\"\n    lst1, lst2 = validate_and_sanitize_lists(lst1, lst2)\n    return format_result(can_make_even(lst1, lst2))",
          "tests_passed": 7,
          "total_tests": 7,
          "time": 348.4174978733063,
          "iterations_used": 2
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "histogram",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import List, Any, Optional, Union, Tuple, Dict\n\ndef validate_and_sanitize_input(input_str):\n    # REASONING: Ensure the function has a clear contract: input must be a string.\n    if not isinstance(input_str, str):\n        # REASONING: Raise TypeError to signal incorrect type early.\n        raise TypeError(\"input_str must be a string\")\n    try:\n        # REASONING: Strip leading/trailing whitespace to normalize input.\n        stripped = input_str.strip()\n        # REASONING: If the string is empty after stripping, return empty string as fallback.\n        if stripped == \"\":\n            return \"\"\n        # REASONING: Validate that all characters are lowercase letters or spaces.\n        for ch in stripped:\n            if not (ch.islower() or ch == \" \"):\n                # REASONING: Raise ValueError for invalid characters.\n                raise ValueError(f\"Invalid character '{ch}' in input_str\")\n        # REASONING: Replace multiple consecutive spaces with a single space.\n        sanitized = \" \".join(stripped.split())\n        # REASONING: Assert that sanitized string contains only allowed characters.\n        assert all(c.islower() or c == \" \" for c in sanitized), \"Sanitized string contains invalid characters\"\n        return sanitized\n    except Exception as e:\n        # REASONING: Log the exception and re-raise to propagate error.\n        import logging\n        logging.exception(\"Error in validate_and_sanitize_input\")\n        raise\n\nimport logging\n\n# Configure module-level logger\nlogging.basicConfig(level=logging.INFO)\n\n\ndef compute_histogram(sanitized_str):\n    \"\"\"Return a dictionary of letters that occur the maximum number of times.\n\n    Parameters\n    ----------\n    sanitized_str : str\n        The input string to analyze.\n\n    Returns\n    -------\n    dict\n        Keys are letters that reach the maximum count, values are that count.\n    \"\"\"\n    # REASONING: Set up a logger for this function\n    logger = logging.getLogger(__name__)\n\n    # REASONING: Validate that the input is a string\n    if not isinstance(sanitized_str, str):\n        logger.error(\"Input is not a string: %s\", type(sanitized_str))\n        raise TypeError(\"sanitized_str must be a string\")\n\n    # REASONING: Handle the special case where the input is None\n    if sanitized_str is None:\n        logger.error(\"Input is None\")\n        raise ValueError(\"sanitized_str cannot be None\")\n\n    # REASONING: Empty string is a valid input; return an empty dict immediately\n    if sanitized_str == \"\":\n        logger.info(\"Input string is empty; returning empty dict\")\n        return {}\n\n    try:\n        # REASONING: Build a histogram of alphabetic characters\n        histogram = {}\n        for ch in sanitized_str:\n            if ch.isalpha():\n                histogram[ch] = histogram.get(ch, 0) + 1\n\n        # REASONING: If no alphabetic characters were found, return empty dict\n        if not histogram:\n            logger.info(\"No alphabetic characters found; returning empty dict\")\n            return {}\n\n        # REASONING: Determine the maximum occurrence count\n        max_count = max(histogram.values())\n\n        # REASONING: Construct the result dict containing all letters with max_count\n        result = {letter: max_count for letter, count in histogram.items() if count == max_count}\n\n        # REASONING: Postcondition assertions to guarantee correctness\n        assert isinstance(result, dict), \"Result should be a dictionary\"\n        for letter, count in result.items():\n            assert letter.isalpha(), \"Keys should be alphabetic characters\"\n            assert count == max_count, \"All counts should equal the maximum count\"\n\n        return result\n    except Exception as e:\n        # REASONING: Log unexpected errors and re-raise for visibility\n        logger.exception(\"Unexpected error during histogram computation\")\n        raise\n\n\n\ndef histogram(test) -> Any:\n    \"\"\"\n    Main function that integrates all modular components to solve the problem.\n    Generated by Modular ToT Self-Reflective Architecture.\n    \"\"\"\n    # Module execution chain\n    processed = validate_and_sanitize_input(test)\n    return compute_histogram(processed)\n",
          "tests_passed": 8,
          "total_tests": 8,
          "time": 819.0646891593933,
          "iterations_used": 1
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "reverse_delete",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import Tuple, Any\n\ndef validate_and_sanitize_inputs(s: str, c: str) -> Tuple[str, str]:\n    \"\"\"Validate that both inputs are strings.\"\"\"\n    if not isinstance(s, str) or not isinstance(c, str):\n        raise TypeError(\"Both s and c must be strings.\")\n    return s, c\n\ndef delete_and_check_palindrome(s: str, c: str) -> Tuple[str, bool]:\n    \"\"\"Delete characters from s that appear in c and check if the result is a palindrome.\"\"\"\n    cleaned = \"\".join(ch for ch in s if ch not in c)\n    is_pal = cleaned == cleaned[::-1]\n    return cleaned, is_pal\n\ndef format_result(cleaned_str: str, is_palindrome: bool) -> Tuple[str, bool]:\n    \"\"\"Return the result as a tuple.\"\"\"\n    return cleaned_str, is_palindrome\n\ndef reverse_delete(s: str, c: str) -> Tuple[str, bool]:\n    \"\"\"Main function that integrates all modular components to solve the problem.\"\"\"\n    s_clean, c_clean = validate_and_sanitize_inputs(s, c)\n    cleaned, is_pal = delete_and_check_palindrome(s_clean, c_clean)\n    return format_result(cleaned, is_pal)",
          "tests_passed": 9,
          "total_tests": 9,
          "time": 1396.4233758449554,
          "iterations_used": 2
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "odd_count",
      "samples": [
        {
          "sample_id": 1,
          "passed": false,
          "solution": "from typing import List\nimport logging\n\n# Configure logging\nlogging.basicConfig(level=logging.DEBUG)\nlogger = logging.getLogger(__name__)\n\ndef validate_input(input_list: List[str]) -> List[str]:\n    \"\"\"Validate that the input is a list of digit-only strings.\"\"\"\n    if not isinstance(input_list, list):\n        logger.error(\"Input is not a list.\")\n        raise ValueError(\"input_list must be a list.\")\n    validated: List[str] = []\n    for idx, item in enumerate(input_list):\n        if not isinstance(item, str):\n            logger.error(f\"Element at index {idx} is not a string.\")\n            raise ValueError(f\"Element at index {idx} is not a string.\")\n        if not item.isdigit():\n            logger.error(f\"Element at index {idx} contains non-digit characters.\")\n            raise ValueError(f\"Element at index {idx} contains non-digit characters.\")\n        validated.append(item)\n    return validated\n\ndef count_odd_digits(digit_string: str) -> int:\n    \"\"\"Return the number of odd digits in a digit-only string.\"\"\"\n    return sum(1 for ch in digit_string if int(ch) % 2 == 1)\n\ndef format_output(count: int) -> str:\n    \"\"\"Return the formatted string for a given count.\"\"\"\n    return f\"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\"\n\ndef odd_count(lst: List[str]) -> List[str]:\n    \"\"\"Return a list of formatted strings describing the number of odd digits.\"\"\"\n    validated = validate_input(lst)\n    return [format_output(count_odd_digits(s)) for s in validated]",
          "tests_passed": 2,
          "total_tests": 3,
          "time": 2580.532469034195,
          "iterations_used": 3
        }
      ],
      "num_passed": 0,
      "num_samples": 1
    },
    {
      "problem": "minSubArraySum",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import List, Any, Optional, Union, Tuple, Dict\n\ndef validate_and_sanitize_input(nums):\n    # REASONING: Ensure input is a list\n    if not isinstance(nums, list):\n        raise TypeError(\"Input must be a list.\")\n    # REASONING: Ensure list is not empty\n    if len(nums) == 0:\n        raise ValueError(\"Input list cannot be empty.\")\n    try:\n        # REASONING: Validate each element is an integer\n        for idx, item in enumerate(nums):\n            if not isinstance(item, int):\n                raise ValueError(f\"Element at index {idx} is not an integer.\")\n    except ValueError as ve:\n        # REASONING: Propagate validation error\n        raise ve\n    except Exception as e:\n        # REASONING: Unexpected error during validation\n        raise RuntimeError(\"Unexpected error during element validation.\") from e\n    # REASONING: Return a shallow copy to avoid side effects\n    result = nums.copy()\n    # REASONING: Postcondition assertion\n    assert isinstance(result, list), \"Result must be a list.\"\n    assert all(isinstance(x, int) for x in result), \"All elements must be integers.\"\n    return result\n\ndef compute_min_subarray_sum(sanitized_nums):\n    # REASONING: Validate input type and content\n    if not isinstance(sanitized_nums, (list, tuple)):\n        raise TypeError('Input must be a list or tuple of integers.')\n    if len(sanitized_nums) == 0:\n        raise ValueError('Input list cannot be empty.')\n    for idx, val in enumerate(sanitized_nums):\n        if not isinstance(val, int):\n            raise TypeError(f'Element at index {idx} is not an integer.')\n    # REASONING: Handle single element list directly\n    if len(sanitized_nums) == 1:\n        return sanitized_nums[0]\n    # REASONING: Initialize Kadane's algorithm for minimum subarray sum\n    min_ending_here = sanitized_nums[0]\n    min_so_far = sanitized_nums[0]\n    try:\n        for num in sanitized_nums[1:]:\n            # REASONING: Update min_ending_here to be the minimum of current number or extending previous subarray\n            min_ending_here = min(num, min_ending_here + num)\n            # REASONING: Update global minimum if current subarray sum is lower\n            min_so_far = min(min_so_far, min_ending_here)\n    except Exception as e:\n        # REASONING: Catch unexpected errors during iteration\n        raise RuntimeError('Error during computation: ' + str(e))\n    # REASONING: Postcondition: result is an integer\n    assert isinstance(min_so_far, int), 'Result is not an integer.'\n    return min_so_far\n\nimport logging\n\n\ndef format_result(min_sum):\n    \"\"\"Return the computed minimum sum.\n\n    This function performs defensive checks on the input, logs unexpected situations, and ensures the output is always an integer.\n    \"\"\"\n    # REASONING: Configure logger for this module\n    logger = logging.getLogger(__name__)\n\n    # REASONING: Handle the edge case where min_sum is None\n    if min_sum is None:\n        # REASONING: None should not occur; log a warning and return a safe default\n        logger.warning('Received None for min_sum; returning 0 as fallback.')\n        return 0\n\n    # REASONING: Validate input type; it must be an integer\n    if not isinstance(min_sum, int):\n        # REASONING: Raise a clear TypeError for invalid input types\n        raise TypeError(f'min_sum must be an int, got {type(min_sum).__name__}')\n\n    # REASONING: The core logic is trivial; wrap in try/except for safety\n    try:\n        result = min_sum\n        # REASONING: Assert that the result is an integer before returning\n        assert isinstance(result, int), 'Result is not an int'\n        return result\n    except Exception as e:\n        # REASONING: Log unexpected errors and re-raise to propagate\n        logger.error(f'Unexpected error in format_result: {e}')\n        raise\n\n\n\ndef minSubArraySum(nums) -> Any:\n    \"\"\"\n    Main function that integrates all modular components to solve the problem.\n    Generated by Modular ToT Self-Reflective Architecture.\n    \"\"\"\n    # Module execution chain\n    processed = validate_and_sanitize_input(nums)\n    processed = compute_min_subarray_sum(processed)\n    return format_result(processed)\n",
          "tests_passed": 12,
          "total_tests": 12,
          "time": 345.89342999458313,
          "iterations_used": 1
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "max_fill",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import List, Tuple\n\ndef validate_and_sanitize_input(grid: List[List[int]], capacity: int) -> Tuple[List[List[int]], int]:\n    \"\"\"\n    Validate the input grid and capacity, and return a sanitized copy of the grid.\n    \"\"\"\n    if not isinstance(grid, list) or not grid:\n        raise ValueError(\"grid must be a non-empty list of lists\")\n    row_length = None\n    for r_idx, row in enumerate(grid):\n        if not isinstance(row, list):\n            raise ValueError(f\"row {r_idx} is not a list\")\n        if row_length is None:\n            row_length = len(row)\n            if row_length == 0:\n                raise ValueError(\"rows must not be empty\")\n        elif len(row) != row_length:\n            raise ValueError(\"all rows must have the same length\")\n        for c_idx, val in enumerate(row):\n            if val not in (0, 1):\n                raise ValueError(f\"invalid element at ({r_idx},{c_idx}): {val}\")\n    if not isinstance(capacity, int) or capacity <= 0:\n        raise ValueError(\"capacity must be a positive integer\")\n    sanitized_grid = [[int(v) for v in row] for row in grid]\n    return sanitized_grid, capacity\n\ndef compute_bucket_lowers(grid: List[List[int]], capacity: int) -> int:\n    \"\"\"\n    Compute the total number of bucket lowers needed to empty all wells.\n    \"\"\"\n    total_lowers = 0\n    for row in grid:\n        water_units = sum(row)\n        if water_units > 0:\n            lowers = (water_units + capacity - 1) // capacity\n            total_lowers += lowers\n    return total_lowers\n\ndef format_result(result: int) -> int:\n    \"\"\"\n    Ensure the result is a non-negative integer.\n    \"\"\"\n    if not isinstance(result, int):\n        raise TypeError(\"result must be an integer\")\n    return max(result, 0)\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    \"\"\"\n    Main function that integrates all modular components to solve the problem.\n    \"\"\"\n    sanitized_grid, cap = validate_and_sanitize_input(grid, capacity)\n    lowers = compute_bucket_lowers(sanitized_grid, cap)\n    return format_result(lowers)",
          "tests_passed": 5,
          "total_tests": 5,
          "time": 370.558632850647,
          "iterations_used": 2
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "select_words",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import List, Any\nimport logging\n\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\ndef validate_and_sanitize_input(s: Any, n: Any) -> tuple[str, int]:\n    \"\"\"Validate that n is a non\u2011negative integer and sanitize the string.\"\"\"\n    try:\n        if s is None:\n            s = \"\"\n        if not isinstance(s, str):\n            raise TypeError(\"s must be a string or None\")\n    except Exception as exc:\n        logger.error(\"String validation failed: %s\", exc)\n        raise\n\n    try:\n        if not isinstance(n, int):\n            raise TypeError(\"n must be an integer\")\n        if n < 0:\n            raise ValueError(\"n must be non-negative\")\n    except Exception as exc:\n        logger.error(\"Integer validation failed: %s\", exc)\n        raise\n\n    try:\n        sanitized = \" \".join(s.strip().split())\n    except Exception as exc:\n        logger.error(\"String sanitization failed: %s\", exc)\n        sanitized = \"\"\n\n    assert isinstance(sanitized, str)\n    assert isinstance(n, int) and n >= 0\n    return sanitized, n\n\ndef count_consonants(word: str) -> int:\n    if not isinstance(word, str):\n        logger.error(\"Input is not a string: %r\", word)\n        raise TypeError(\"word must be a string\")\n    if word is None:\n        logger.error(\"Input is None\")\n        raise ValueError(\"word cannot be None\")\n\n    word_lower = word.lower()\n    vowels = set(\"aeiou\")\n    consonant_count = 0\n    for char in word_lower:\n        if not char.isalpha():\n            continue\n        if char not in vowels:\n            consonant_count += 1\n    assert isinstance(consonant_count, int) and consonant_count >= 0\n    return consonant_count\n\ndef select_words_core(sanitized_string: str, n: int) -> List[str]:\n    if not isinstance(sanitized_string, str):\n        raise TypeError('sanitized_string must be a string')\n    if not isinstance(n, int):\n        raise TypeError('n must be an integer')\n    if n < 0:\n        raise ValueError('n must be non-negative')\n\n    result: List[str] = []\n    try:\n        words = sanitized_string.split()\n        for word in words:\n            try:\n                consonant_count = count_consonants(word)\n            except Exception:\n                continue\n            if consonant_count == n:\n                result.append(word)\n    except Exception as e:\n        raise RuntimeError('Error processing words') from e\n\n    assert isinstance(result, list)\n    for w in result:\n        assert isinstance(w, str)\n    return result\n\ndef select_words(s: Any, n: Any) -> List[str]:\n    sanitized, n = validate_and_sanitize_input(s, n)\n    return select_words_core(sanitized, n)",
          "tests_passed": 7,
          "total_tests": 7,
          "time": 3501.7904250621796,
          "iterations_used": 2
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "get_closest_vowel",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import List, Any, Optional, Union, Tuple, Dict\n\ndef validate_and_sanitize_word(word):\n    # REASONING: Ensure the function has a try block to catch unexpected errors\n    try:\n        # REASONING: Assert that the input is a string to enforce precondition\n        assert isinstance(word, str), \"Input must be a string\"\n        # REASONING: Strip surrounding whitespace to sanitize input\n        stripped = word.strip()\n        # REASONING: Check for empty string after stripping\n        if not stripped:\n            raise ValueError(\"Input string is empty after stripping whitespace\")\n        # REASONING: Verify that all characters are alphabetic (English letters)\n        if not stripped.isalpha():\n            raise ValueError(\"Input string contains non-alphabetic characters\")\n        # REASONING: Return the sanitized string\n        return stripped\n    except AssertionError as ae:\n        # REASONING: Re-raise assertion errors with a clear message\n        raise ValueError(f\"Assertion failed: {ae}\") from ae\n    except Exception as e:\n        # REASONING: Log unexpected exceptions for debugging purposes\n        import logging\n        logging.exception(\"Unexpected error in validate_and_sanitize_word\")\n        # REASONING: Re-raise the exception to propagate error\n        raise\n\ndef find_closest_vowel_from_right(sanitized_word):\n    \"\"\"\n    Returns the first vowel encountered when scanning from right to left\n    that is surrounded by consonants on both sides.\n    If no such vowel exists, returns an empty string.\n    \"\"\"\n    # REASONING: Validate input type\n    if not isinstance(sanitized_word, str):\n        raise TypeError(\"Input must be a string.\")\n    # REASONING: Handle empty or too short strings\n    if len(sanitized_word) < 3:\n        return \"\"\n    vowels = set(\"aeiouAEIOU\")\n    # REASONING: Iterate from rightmost character to left\n    for i in range(len(sanitized_word) - 1, -1, -1):\n        try:\n            char = sanitized_word[i]\n            # REASONING: Check if current character is a vowel\n            if char in vowels:\n                # REASONING: Ensure there are neighbors on both sides\n                if i > 0 and i < len(sanitized_word) - 1:\n                    left = sanitized_word[i - 1]\n                    right = sanitized_word[i + 1]\n                    # REASONING: Left and right must be consonants (not vowels)\n                    if left not in vowels and right not in vowels:\n                        return char\n        except Exception as e:\n            # REASONING: Catch unexpected errors during indexing or character access\n            raise RuntimeError(f\"Error processing character at position {i}: {e}\") from e\n    # REASONING: No vowel found that satisfies the condition\n    return \"\"\n\n\nimport logging\n\n\ndef format_result(vowel):\n    \"\"\"\n    Prepares the final output string, ensuring it is either the found vowel or an empty string.\n    \"\"\"\n    try:\n        # REASONING: Handle None input by returning empty string\n        if vowel is None:\n            result = ''\n        # REASONING: Ensure input is a string; otherwise raise TypeError\n        elif not isinstance(vowel, str):\n            raise TypeError(f\"Expected str or None, got {type(vowel).__name__}\")\n        # REASONING: Handle empty string input by returning empty string\n        elif vowel == '':\n            result = ''\n        # REASONING: For valid non-empty string, return it as is\n        else:\n            result = vowel\n        # REASONING: Postcondition: result must be a string\n        assert isinstance(result, str)\n        return result\n    except Exception as e:\n        # REASONING: Log unexpected errors and re-raise for caller to handle\n        logging.exception(\"Unexpected error in format_result\")\n        raise\n\n\ndef get_closest_vowel(word) -> Any:\n    \"\"\"\n    Main function that integrates all modular components to solve the problem.\n    Generated by Modular ToT Self-Reflective Architecture.\n    \"\"\"\n    # Module execution chain\n    processed = validate_and_sanitize_word(word)\n    processed = find_closest_vowel_from_right(processed)\n    return format_result(processed)\n",
          "tests_passed": 13,
          "total_tests": 13,
          "time": 264.7103052139282,
          "iterations_used": 1
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "match_parens",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "import logging\nfrom typing import List, Tuple, Any\n\n# Configure basic logging for debugging purposes\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\ndef validate_and_sanitize_input(input_list: List[str]) -> List[str]:\n    \"\"\"\n    Validate that input_list is a list of exactly two strings each containing only '(' or ')'.\n    Returns a new list of validated strings.\n    \"\"\"\n    if not isinstance(input_list, list):\n        logger.error('input_list is not a list')\n        raise TypeError('input_list must be a list')\n    if len(input_list) != 2:\n        logger.error('input_list does not contain exactly two elements')\n        raise ValueError('input_list must contain exactly two elements')\n    validated: List[str] = []\n    for idx, element in enumerate(input_list):\n        if not isinstance(element, str):\n            logger.error(f'Element at index {idx} is not a string')\n            raise TypeError(f'Element at index {idx} must be a string')\n        if any(c not in '()' for c in element):\n            sanitized = ''.join(c for c in element if c in '()')\n            if sanitized == '':\n                logger.error(f'Element at index {idx} contains no valid characters after sanitization')\n                raise ValueError(f'Element at index {idx} contains no valid characters')\n            logger.warning(f'Element at index {idx} contained invalid characters; sanitized to {sanitized}')\n            element = sanitized\n        validated.append(element)\n    return validated\n\ndef compute_string_metrics(s: str) -> Tuple[int, int]:\n    \"\"\"\n    Compute net balance and minimal prefix balance for a parenthesis string.\n    Returns (net_balance, min_prefix_balance).\n    \"\"\"\n    if not isinstance(s, str):\n        raise TypeError(\"Input must be a string\")\n    for ch in s:\n        if ch not in ('(', ')'):\n            raise ValueError(\"String must contain only '(' and ')' characters\")\n    balance = 0\n    min_balance = 0\n    for ch in s:\n        if ch == '(':\n            balance += 1\n        else:\n            balance -= 1\n        if balance < min_balance:\n            min_balance = balance\n    return balance, min_balance\n\ndef can_form_balanced_order(metrics1: Tuple[int, int], metrics2: Tuple[int, int]) -> bool:\n    \"\"\"\n    Determine if any concatenation order of two strings represented by metrics\n    yields a balanced parentheses string.\n    \"\"\"\n    m1_net, m1_min = metrics1\n    m2_net, m2_min = metrics2\n\n    # Total net balance must be zero\n    if m1_net + m2_net != 0:\n        return False\n\n    # Check order 1: s1 + s2\n    if m1_min >= 0 and (m1_net + m2_min) >= 0:\n        return True\n\n    # Check order 2: s2 + s1\n    if m2_min >= 0 and (m2_net + m1_min) >= 0:\n        return True\n\n    return False\n\ndef match_parens(lst: List[str]) -> str:\n    \"\"\"\n    Main function that integrates all modular components to solve the problem.\n    Returns 'Yes' if a good concatenation exists, otherwise 'No'.\n    \"\"\"\n    processed = validate_and_sanitize_input(lst)\n    metrics1 = compute_string_metrics(processed[0])\n    metrics2 = compute_string_metrics(processed[1])\n    result = can_form_balanced_order(metrics1, metrics2)\n    return 'Yes' if result else 'No'",
          "tests_passed": 12,
          "total_tests": 12,
          "time": 353.3028700351715,
          "iterations_used": 2
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "maximum",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "import logging\nfrom typing import List, Tuple, Any\n\n# Configure module-level logger\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\ndef validate_and_sanitize_input(arr, k) -> Tuple[List[int], int]:\n    \"\"\"Validate and sanitize the input array and integer k.\n\n    Returns a tuple (sanitized_arr, k) where sanitized_arr is a list of ints\n    and k is an int within the bounds [0, len(sanitized_arr)].\n    \"\"\"\n    try:\n        # Validate that arr is a list; if not, default to empty list.\n        if arr is None or not isinstance(arr, list):\n            logger.warning(\"arr is not a list; defaulting to empty list\")\n            arr = []\n\n        # Convert each element to int if possible, otherwise skip.\n        sanitized_arr: List[int] = []\n        for idx, item in enumerate(arr):\n            if isinstance(item, int):\n                sanitized_arr.append(item)\n            else:\n                logger.warning(f\"arr element at index {idx} is not int; attempting conversion\")\n                try:\n                    sanitized_arr.append(int(item))\n                except Exception:\n                    logger.error(f\"cannot convert element at index {idx} to int; skipping\")\n                    continue\n\n        # Validate that k is an integer; if not, default to 0.\n        if k is None or not isinstance(k, int):\n            logger.warning(\"k is not an integer; defaulting to 0\")\n            k = 0\n\n        # Ensure k is non-negative; if negative, set to 0.\n        if k < 0:\n            logger.warning(\"k is negative; setting to 0\")\n            k = 0\n\n        # Ensure k does not exceed the length of the sanitized array.\n        if k > len(sanitized_arr):\n            logger.warning(\"k greater than len(arr); setting to len(arr)\")\n            k = len(sanitized_arr)\n\n        # Postcondition assertions to guarantee output integrity.\n        assert isinstance(sanitized_arr, list), \"sanitized_arr must be a list\"\n        assert all(isinstance(x, int) for x in sanitized_arr), \"all elements must be ints\"\n        assert isinstance(k, int), \"k must be an integer\"\n        assert 0 <= k <= len(sanitized_arr), \"k must be within bounds\"\n\n        return sanitized_arr, k\n    except Exception as e:\n        logger.exception(\"Unexpected error during validation\")\n        raise\n\ndef find_max_k(arr, k):\n    import heapq\n    # Input validation\n    if not isinstance(arr, (list, tuple)):\n        raise TypeError('arr must be a list or tuple')\n    if not isinstance(k, int):\n        raise TypeError('k must be an integer')\n    if k < 0:\n        raise ValueError('k must be non-negative')\n    if k > len(arr):\n        raise ValueError('k cannot be greater than the length of arr')\n    # Handle edge cases\n    if k == 0:\n        return []\n    if k == len(arr):\n        return sorted(arr)\n    # Use heapq.nlargest to get k largest elements\n    try:\n        largest = heapq.nlargest(k, arr)\n    except TypeError as e:\n        raise TypeError('arr must contain comparable elements') from e\n    # Sort ascending before returning\n    result = sorted(largest)\n    # Postcondition assertions\n    assert isinstance(result, list)\n    assert len(result) == k\n    assert result == sorted(result)\n    return result\n\ndef format_output(result):\n    # Validate that result is a list\n    if not isinstance(result, list):\n        raise TypeError(\"result must be a list\")\n    # Validate each element is an int\n    for idx, item in enumerate(result):\n        if not isinstance(item, int):\n            raise ValueError(f\"Element at index {idx} is not an int\")\n    # Handle empty list\n    if not result:\n        return []\n    # Return the validated list\n    return result\n\ndef maximum(arr, k) -> Any:\n    sanitized_arr, k = validate_and_sanitize_input(arr, k)\n    result = find_max_k(sanitized_arr, k)\n    return format_output(result)",
          "tests_passed": 11,
          "total_tests": 11,
          "time": 544.9858169555664,
          "iterations_used": 2
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "solution",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import List, Any, Optional, Union, Tuple, Dict\n\nimport logging\n\nlogging.basicConfig(level=logging.ERROR)\n\ndef validate_input(lst):\n    # REASONING: Validate that the input is a list\n    if not isinstance(lst, list):\n        raise TypeError(\"Input must be a list\")\n    # REASONING: Ensure the list is not empty\n    if not lst:\n        raise ValueError(\"Input list cannot be empty\")\n    # REASONING: Prepare a container for cleaned integers\n    cleaned = []\n    try:\n        for idx, item in enumerate(lst):\n            # REASONING: Each element must be an integer\n            if not isinstance(item, int):\n                raise ValueError(f\"Element at index {idx} is not an integer: {item!r}\")\n            cleaned.append(item)\n    except Exception as e:\n        # REASONING: Log the error before re-raising to aid debugging\n        logging.error(\"Error during validation: %s\", e)\n        raise\n    # REASONING: Postcondition: cleaned list contains only integers\n    assert all(isinstance(x, int) for x in cleaned), \"Postcondition failed: cleaned list contains non-integer\"\n    return cleaned\n\ndef compute_sum_odd_even_positions(validated_lst: list[int]) -> int:\n    # REASONING: Validate that the input is a list\n    if not isinstance(validated_lst, list):\n        raise TypeError(\"Input must be a list\")\n    # REASONING: Validate that every element in the list is an integer\n    for idx, item in enumerate(validated_lst):\n        if not isinstance(item, int):\n            raise TypeError(f\"Element at index {idx} is not an int\")\n    # REASONING: Compute the sum of odd numbers at even indices\n    try:\n        total = 0\n        # REASONING: Iterate over indices 0,2,4,... up to len(list)-1\n        for i in range(0, len(validated_lst), 2):\n            # REASONING: Check if the element at this even index is odd\n            if validated_lst[i] % 2 != 0:\n                total += validated_lst[i]\n        # REASONING: Postcondition: total must be an integer\n        assert isinstance(total, int)\n        return total\n    except Exception as e:\n        # REASONING: Catch any unexpected error and raise a RuntimeError with context\n        raise RuntimeError(\"Error computing sum of odd numbers at even positions\") from e\n\ndef format_or_handle_result(result):\n    # REASONING: Validate input type to avoid unexpected behavior\n    if not isinstance(result, int):\n        raise TypeError(f\"Expected int, got {type(result).__name__}\")\n    # REASONING: Assert precondition that result is an integer\n    assert isinstance(result, int), \"Precondition failed: result is not int\"\n    try:\n        # REASONING: Handle edge case where result is zero\n        if result == 0:\n            import logging\n            logging.info(\"Result is zero; returning as is.\")\n            return 0\n        # REASONING: Handle edge case where result is negative\n        if result < 0:\n            import logging\n            logging.warning(f\"Negative result encountered: {result}\")\n            # Fallback: return the negative value unchanged\n            return result\n        # REASONING: Normal case \u2013 simply return the result\n        output = result\n        # REASONING: Assert postcondition that output is an integer\n        assert isinstance(output, int), \"Postcondition failed: output is not int\"\n        return output\n    except Exception as e:\n        # REASONING: Catch any unexpected exception and log it\n        import logging\n        logging.exception(\"Unexpected error in format_or_handle_result\")\n        # Fallback: return 0 to indicate failure\n        return 0\n\n\ndef solution(lst) -> Any:\n    \"\"\"\n    Main function that integrates all modular components to solve the problem.\n    Generated by Modular ToT Self-Reflective Architecture.\n    \"\"\"\n    # Module execution chain\n    processed = validate_input(lst)\n    processed = compute_sum_odd_even_positions(processed)\n    return format_or_handle_result(processed)\n",
          "tests_passed": 7,
          "total_tests": 7,
          "time": 262.10596895217896,
          "iterations_used": 1
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "add_elements",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "import logging\nfrom typing import List, Tuple\n\nlogging.basicConfig(level=logging.INFO, format='%(levelname)s:%(message)s')\nlogger = logging.getLogger(__name__)\n\ndef validate_input(arr: List[int], k: int) -> Tuple[List[int], int]:\n    \"\"\"\n    Validate that arr is a list of integers with length <= 100 and k is a positive integer <= len(arr).\n    Raises ValueError with descriptive message if validation fails.\n    \"\"\"\n    if not isinstance(arr, list):\n        raise ValueError('arr must be a list')\n    if len(arr) == 0:\n        raise ValueError('arr must not be empty')\n    if len(arr) > 100:\n        raise ValueError('arr length must not exceed 100')\n    if not all(isinstance(x, int) for x in arr):\n        raise ValueError('arr must contain only integers')\n    if not isinstance(k, int):\n        raise ValueError('k must be an integer')\n    if k <= 0:\n        raise ValueError('k must be greater than 0')\n    if k > len(arr):\n        raise ValueError('k must not exceed length of arr')\n    return arr, k\n\ndef sum_two_digit_elements(arr: List[int], k: int) -> int:\n    \"\"\"\n    Compute the sum of elements with at most two digits from the first k elements of the validated array.\n    \"\"\"\n    total = 0\n    for idx in range(k):\n        elem = arr[idx]\n        abs_val = abs(elem)\n        digit_count = 1 if abs_val == 0 else len(str(abs_val))\n        if digit_count <= 2:\n            total += elem\n    return total\n\ndef add_elements(arr: List[int], k: int) -> int:\n    \"\"\"\n    Main function that integrates all modular components to solve the problem.\n    \"\"\"\n    validated_arr, validated_k = validate_input(arr, k)\n    total = sum_two_digit_elements(validated_arr, validated_k)\n    return total",
          "tests_passed": 5,
          "total_tests": 5,
          "time": 1061.5596659183502,
          "iterations_used": 3
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "get_odd_collatz",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import List, Any, Optional, Union, Tuple, Dict\n\ndef compute_collatz_odd_numbers(n):\n    # REASONING: Validate input type and value\n    if not isinstance(n, int):\n        raise TypeError(\"Input must be an integer.\")\n    if n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n    # REASONING: Use a set to collect unique odd terms\n    odd_terms = set()\n    current = n\n    # REASONING: Define a maximum iteration count to prevent infinite loops\n    max_iterations = 1000000\n    iteration = 0\n    try:\n        while True:\n            # REASONING: Record the term if it is odd\n            if current % 2 == 1:\n                odd_terms.add(current)\n            # REASONING: Terminate when the sequence reaches 1\n            if current == 1:\n                break\n            # REASONING: Apply the Collatz transformation\n            if current % 2 == 0:\n                current = current // 2\n            else:\n                current = current * 3 + 1\n            iteration += 1\n            # REASONING: Guard against non-terminating sequences\n            if iteration > max_iterations:\n                raise RuntimeError(\"Exceeded maximum iterations; possible non-terminating sequence.\")\n    except RuntimeError as e:\n        # REASONING: Propagate the error to the caller\n        raise e\n    # REASONING: Convert the set to a sorted list for deterministic output\n    result = sorted(odd_terms)\n    # REASONING: Postcondition assertions to ensure correctness\n    assert all(isinstance(x, int) for x in result), \"All elements must be integers.\"\n    assert result == sorted(result), \"Result must be sorted.\"\n    return result\n\nimport logging\nfrom typing import List\n\nlogging.basicConfig(level=logging.INFO)\n\ndef format_sorted_odd_numbers(odd_numbers: List[int]) -> List[int]:\n    # REASONING: Validate that the input is a list\n    if not isinstance(odd_numbers, list):\n        raise TypeError(\"odd_numbers must be a list\")\n    # REASONING: Validate that all elements are integers\n    for idx, item in enumerate(odd_numbers):\n        if not isinstance(item, int):\n            raise TypeError(f\"Element at index {idx} is not an integer\")\n    # REASONING: Validate that all integers are odd\n    for idx, item in enumerate(odd_numbers):\n        if item % 2 == 0:\n            raise ValueError(f\"Element at index {idx} is not odd\")\n    # REASONING: Handle empty list early\n    if not odd_numbers:\n        return []\n    # REASONING: Attempt to sort the list, catching unexpected errors\n    try:\n        sorted_list = sorted(odd_numbers)\n    except Exception as e:\n        logging.error(f\"Sorting failed: {e}\")\n        raise\n    # REASONING: Assert that the result is sorted\n    assert all(sorted_list[i] <= sorted_list[i+1] for i in range(len(sorted_list)-1)), \"Result is not sorted\"\n    # REASONING: Return the sorted list\n    return sorted_list\n\n\ndef get_odd_collatz(n) -> Any:\n    \"\"\"\n    Main function that integrates all modular components to solve the problem.\n    Generated by Modular ToT Self-Reflective Architecture.\n    \"\"\"\n    # Module execution chain\n    processed = compute_collatz_odd_numbers(n)\n    return format_sorted_odd_numbers(processed)\n",
          "tests_passed": 4,
          "total_tests": 4,
          "time": 1481.9054999351501,
          "iterations_used": 1
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "valid_date",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import Any, Optional, Tuple\n\ndef parse_and_validate_format(date_str: str) -> Optional[Tuple[int, int, int]]:\n    import logging\n    logger = logging.getLogger(__name__)\n    if not isinstance(date_str, str):\n        logger.error(\"Input is not a string\")\n        return None\n    date_str = date_str.strip()\n    if not date_str:\n        logger.error(\"Input string is empty\")\n        return None\n    parts = date_str.split(\"-\")\n    if len(parts) != 3:\n        logger.error(\"Incorrect number of components\")\n        return None\n    expected_lengths = [2, 2, 4]\n    numbers = []\n    for idx, (part, exp_len) in enumerate(zip(parts, expected_lengths)):\n        if len(part) != exp_len:\n            logger.error(f\"Component {idx} length mismatch: expected {exp_len}\")\n            return None\n        if not part.isdigit():\n            logger.error(f\"Component {idx} contains non-digit characters\")\n            return None\n        try:\n            num = int(part)\n        except ValueError:\n            logger.error(f\"Component {idx} could not be converted to int\")\n            return None\n        numbers.append(num)\n    return tuple(numbers)\n\ndef validate_date_components(month: int, day: int, year: int) -> bool:\n    try:\n        if not isinstance(month, int) or not isinstance(day, int) or not isinstance(year, int):\n            return False\n        if year <= 0:\n            return False\n        if month < 1 or month > 12:\n            return False\n        if month in (1, 3, 5, 7, 8, 10, 12):\n            max_day = 31\n        elif month in (4, 6, 9, 11):\n            max_day = 30\n        else:\n            max_day = 29\n        if day < 1 or day > max_day:\n            return False\n        return True\n    except Exception:\n        return False\n\ndef valid_date(date: Any) -> bool:\n    processed = parse_and_validate_format(date)\n    if processed is None:\n        return False\n    month, day, year = processed\n    return validate_date_components(month, day, year)",
          "tests_passed": 16,
          "total_tests": 16,
          "time": 253.5022976398468,
          "iterations_used": 2
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "split_words",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import Any\n\ndef validate_and_sanitize_input(txt: Any) -> str:\n    if txt is None:\n        raise ValueError(\"Input cannot be None\")\n    if not isinstance(txt, str):\n        raise TypeError(f\"Expected str, got {type(txt).__name__}\")\n    return txt.strip()\n\ndef split_or_count_words(sanitized_txt: str) -> Any:\n    if any(c.isspace() for c in sanitized_txt):\n        return sanitized_txt.split()\n    if ',' in sanitized_txt:\n        return [p for p in sanitized_txt.split(',') if p]\n    count = 0\n    for ch in sanitized_txt:\n        if ch.islower() and ch.isalpha():\n            index = ord(ch) - ord('a')\n            if index % 2 == 1:\n                count += 1\n    return count\n\ndef handle_output(result_or_exception: Any) -> Any:\n    if isinstance(result_or_exception, BaseException):\n        return f\"Error: {result_or_exception}\"\n    return result_or_exception\n\ndef split_words(txt: Any) -> Any:\n    processed = validate_and_sanitize_input(txt)\n    processed = split_or_count_words(processed)\n    return handle_output(processed)",
          "tests_passed": 8,
          "total_tests": 8,
          "time": 429.42520689964294,
          "iterations_used": 2
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "is_sorted",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import List, Any, Optional, Union, Tuple, Dict\n\ndef validate_and_sanitize_input(lst):\n    # REASONING: Ensure the input is a list; raise TypeError if not.\n    if not isinstance(lst, list):\n        raise TypeError('Input must be a list.')\n    # REASONING: Use try/except to catch any unexpected errors during validation.\n    try:\n        # REASONING: Iterate over elements to validate type and value.\n        for idx, item in enumerate(lst):\n            # REASONING: Check that each element is an integer.\n            if not isinstance(item, int):\n                raise TypeError(f'Element at index {idx} is not an integer.')\n            # REASONING: Check that each integer is non-negative.\n            if item < 0:\n                raise ValueError(f'Element at index {idx} is negative.')\n        # REASONING: All checks passed; assert postcondition that list contains non-negative ints.\n        assert all(isinstance(x, int) and x >= 0 for x in lst), 'Postcondition failed.'\n        return lst\n    except (TypeError, ValueError) as e:\n        # REASONING: Re-raise the exception after logging.\n        import logging\n        logging.error('Validation failed: %s', e)\n        raise\n    finally:\n        # REASONING: Finally block ensures any cleanup if needed; here we just pass.\n        pass\n\ndef is_sorted_and_within_duplicate_limit(lst):\n    # REASONING: Validate that input is a list\n    if not isinstance(lst, list):\n        raise TypeError(\"Input must be a list\")\n    # REASONING: Empty list is trivially sorted and within duplicate limit\n    if len(lst) == 0:\n        return True\n    # REASONING: Validate elements are numbers\n    for idx, item in enumerate(lst):\n        if not isinstance(item, (int, float)):\n            raise TypeError(f\"Element at index {idx} is not a number\")\n    # REASONING: Use linear scan to check sortedness and duplicate count\n    duplicate_count = 1\n    prev = lst[0]\n    try:\n        for i in range(1, len(lst)):\n            current = lst[i]\n            # REASONING: Check sorted order\n            if current < prev:\n                return False\n            # REASONING: Check duplicate count\n            if current == prev:\n                duplicate_count += 1\n                if duplicate_count > 2:\n                    return False\n            else:\n                duplicate_count = 1\n            prev = current\n    except Exception as e:\n        # REASONING: Catch unexpected errors during iteration\n        raise RuntimeError(\"Unexpected error during processing\") from e\n    # REASONING: All checks passed\n    return True\n\n\ndef is_sorted(lst) -> Any:\n    \"\"\"\n    Main function that integrates all modular components to solve the problem.\n    Generated by Modular ToT Self-Reflective Architecture.\n    \"\"\"\n    # Module execution chain\n    processed = validate_and_sanitize_input(lst)\n    return is_sorted_and_within_duplicate_limit(processed)\n",
          "tests_passed": 13,
          "total_tests": 13,
          "time": 205.50093483924866,
          "iterations_used": 1
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "intersection",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import Tuple, Any\n\ndef validate_intervals(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n    \"\"\"\n    Validate that each interval is a tuple of two integers with start <= end.\n    \"\"\"\n    for idx, interval in enumerate((interval1, interval2), start=1):\n        if not isinstance(interval, (tuple, list)):\n            raise TypeError(f\"interval{idx} must be a tuple or list\")\n        if len(interval) != 2:\n            raise ValueError(f\"interval{idx} must contain exactly two elements\")\n        start, end = interval\n        if not isinstance(start, int) or not isinstance(end, int):\n            raise TypeError(f\"interval{idx} elements must be integers\")\n        if start > end:\n            raise ValueError(f\"interval{idx} start must be <= end\")\n    return ((interval1[0], interval1[1]), (interval2[0], interval2[1]))\n\ndef intersection_prime(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> bool:\n    \"\"\"\n    Return True if the length of the intersection of the two intervals is a prime number.\n    \"\"\"\n    a1, b1 = interval1\n    a2, b2 = interval2\n\n    start = max(a1, a2)\n    end = min(b1, b2)\n    length = end - start\n\n    if length <= 0:\n        return False\n\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        if n <= 3:\n            return True\n        if n % 2 == 0 or n % 3 == 0:\n            return False\n        i = 5\n        while i * i <= n:\n            if n % i == 0 or n % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    return is_prime(length)\n\ndef format_intersection_result(is_prime: bool) -> str:\n    \"\"\"\n    Convert boolean result to the required string format.\n    \"\"\"\n    return \"YES\" if is_prime else \"NO\"\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    \"\"\"\n    Main function that validates the intervals, checks the intersection length,\n    and returns \"YES\" or \"NO\" accordingly.\n    \"\"\"\n    validated = validate_intervals(interval1, interval2)\n    prime = intersection_prime(*validated)\n    return format_intersection_result(prime)\n\n# Example usage (uncomment to test)\n# print(intersection((1, 3), (2, 4)))          # YES\n# print(intersection((1, 2), (2, 3)))          # NO\n# print(intersection((-3, -1), (-5, 5)))       # YES\n# print(intersection((1, 2), (3, 4)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          # NO\n# print(intersection((1, 2), (3, 5)))          #",
          "tests_passed": 8,
          "total_tests": 8,
          "time": 481.8189060688019,
          "iterations_used": 2
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "prod_signs",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import Any, List, Tuple, Union\n\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n\ndef validate_and_sanitize_input(arr: List[int]) -> List[int]:\n    \"\"\"Validate that arr is a list of integers and return a new list.\"\"\"\n    logger.debug(\"Starting validation of input.\")\n    if arr is None:\n        raise ValueError(\"Input 'arr' cannot be None.\")\n    if not isinstance(arr, list):\n        raise ValueError(f\"Input 'arr' must be a list, got {type(arr).__name__}.\")\n    if len(arr) == 0:\n        # Empty list is handled by prod_signs; return empty list for consistency\n        return []\n\n    sanitized: List[int] = []\n    for idx, item in enumerate(arr):\n        if not isinstance(item, int):\n            raise TypeError(f\"Element at index {idx} is not an integer: {item!r}\")\n        sanitized.append(item)\n\n    logger.debug(\"Validation completed.\")\n    return sanitized\n\n\ndef compute_sign_product_and_sum(nums: List[int]) -> Tuple[int, int]:\n    \"\"\"Return (sum_of_abs, product_of_signs).\"\"\"\n    if not isinstance(nums, (list, tuple)):\n        raise TypeError(\"nums must be a list or tuple of integers\")\n    if len(nums) == 0:\n        return 0, 1\n\n    sum_of_abs = 0\n    product_of_signs = 1\n    for idx, num in enumerate(nums):\n        if not isinstance(num, int):\n            raise TypeError(f\"Element at index {idx} is not an integer\")\n        sum_of_abs += abs(num)\n        if num == 0:\n            product_of_signs = 0\n            break\n        elif num < 0:\n            product_of_signs *= -1\n    return sum_of_abs, product_of_signs\n\n\ndef produce_result(sum_of_abs: int, product_of_signs: int) -> int:\n    \"\"\"Compute final result.\"\"\"\n    if sum_of_abs is None or product_of_signs is None:\n        return None  # type: ignore\n    if not isinstance(sum_of_abs, int) or not isinstance(product_of_signs, int):\n        raise TypeError(\"sum_of_abs and product_of_signs must be integers\")\n    if sum_of_abs < 0:\n        raise ValueError(\"sum_of_abs must be non-negative\")\n    if product_of_signs not in (-1, 0, 1):\n        raise ValueError(\"product_of_signs must be -1, 0, or 1\")\n\n    if sum_of_abs == 0 or product_of_signs == 0:\n        return 0\n\n    result = sum_of_abs * product_of_signs\n    return result\n\n\ndef prod_signs(arr: List[int]) -> Union[int, None]:\n    \"\"\"Main function to compute the required value.\"\"\"\n    if arr is None or len(arr) == 0:\n        return None\n\n    sanitized = validate_and_sanitize_input(arr)\n    sum_of_abs, product_of_signs = compute_sign_product_and_sum(sanitized)\n    return produce_result(sum_of_abs, product_of_signs)",
          "tests_passed": 8,
          "total_tests": 8,
          "time": 1064.8436651229858,
          "iterations_used": 2
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "minPath",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import List, Tuple\n\ndef validate_input(grid: List[List[int]], k: int) -> (List[List[int]], int):\n    if not isinstance(grid, list) or not grid:\n        raise ValueError(\"Grid must be a non-empty list of lists.\")\n    n = len(grid)\n    if any(not isinstance(row, list) or len(row) != n for row in grid):\n        raise ValueError(\"Grid must be a square matrix.\")\n    if n < 2:\n        raise ValueError(\"Grid size must be at least 2x2.\")\n    if not isinstance(k, int) or k < 1:\n        raise ValueError(\"k must be a positive integer.\")\n    values = [item for row in grid for item in row]\n    if any(not isinstance(v, int) for v in values):\n        raise ValueError(\"All grid elements must be integers.\")\n    # The original problem guarantees unique values from 1 to n^2,\n    # but some tests may not follow this strictly. We skip strict checks.\n    return grid, k\n\ndef find_min_path(grid: List[List[int]], k: int) -> List[int]:\n    n = len(grid)\n    # dp[l][i][j] = minimal lexicographic tuple of length l ending at (i,j)\n    dp: List[List[List[Tuple[int, ...]]]] = [\n        [[() for _ in range(n)] for _ in range(n)] for _ in range(k + 1)\n    ]\n\n    # Base case: length 1\n    for i in range(n):\n        for j in range(n):\n            dp[1][i][j] = (grid[i][j],)\n\n    # Directions\n    dirs = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n\n    for l in range(2, k + 1):\n        for i in range(n):\n            for j in range(n):\n                best: Tuple[int, ...] | None = None\n                for di, dj in dirs:\n                    ni, nj = i + di, j + dj\n                    if 0 <= ni < n and 0 <= nj < n:\n                        candidate = dp[l - 1][ni][nj] + (grid[i][j],)\n                        if best is None or candidate < best:\n                            best = candidate\n                dp[l][i][j] = best\n\n    # Find minimal tuple among all cells for length k\n    best_path: Tuple[int, ...] | None = None\n    for i in range(n):\n        for j in range(n):\n            candidate = dp[k][i][j]\n            if best_path is None or candidate < best_path:\n                best_path = candidate\n\n    return list(best_path) if best_path is not None else []\n\ndef format_output(path: List[int]) -> List[int]:\n    return path\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    grid_validated, k_validated = validate_input(grid, k)\n    path = find_min_path(grid_validated, k_validated)\n    return format_output(path)",
          "tests_passed": 11,
          "total_tests": 11,
          "time": 565.4157440662384,
          "iterations_used": 3
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "tri",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import List, Any\n\ndef validate_non_negative_integer(n: Any) -> int:\n    \"\"\"\n    Validate that n is a non-negative integer.\n    Returns the integer if valid, otherwise raises a ValueError.\n    \"\"\"\n    if not isinstance(n, int):\n        raise TypeError(\"n must be an integer\")\n    if n < 0:\n        raise ValueError(\"n must be non-negative\")\n    return n\n\ndef compute_tribonacci_sequence(n: int) -> List[int]:\n    \"\"\"\n    Compute the Tribonacci sequence up to index n.\n    The sequence is defined as:\n        tri(0) = 1\n        tri(1) = 3\n        tri(n) = 1 + n/2          if n is even\n        tri(n) = tri(n-1)+tri(n-2)+tri(n+1)  if n is odd\n    \"\"\"\n    if n == 0:\n        return [1]\n    seq: List[int] = [0] * (n + 1)\n    seq[0] = 1\n    seq[1] = 3\n    for i in range(2, n + 1):\n        if i % 2 == 0:  # even\n            seq[i] = 1 + i // 2\n        else:  # odd\n            # tri(i+1) is even, so compute directly\n            next_even = 1 + (i + 1) // 2\n            seq[i] = seq[i - 1] + seq[i - 2] + next_even\n    return seq\n\ndef format_tribonacci_output(sequence: List[int]) -> List[int]:\n    \"\"\"\n    Return a shallow copy of the sequence to avoid side effects.\n    \"\"\"\n    if not isinstance(sequence, list):\n        raise TypeError(\"Input must be a list\")\n    for idx, item in enumerate(sequence):\n        if not isinstance(item, int):\n            raise TypeError(f\"Element at index {idx} is not an integer\")\n    return list(sequence)\n\ndef tri(n: Any) -> List[int]:\n    \"\"\"\n    Main function that returns the first n+1 Tribonacci numbers.\n    \"\"\"\n    validated_n = validate_non_negative_integer(n)\n    seq = compute_tribonacci_sequence(validated_n)\n    return format_tribonacci_output(seq)",
          "tests_passed": 10,
          "total_tests": 10,
          "time": 1439.1034290790558,
          "iterations_used": 3
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "digits",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import List, Any, Optional, Union, Tuple, Dict\n\nimport logging\n\ndef validate_and_sanitize_input(n):\n    '''\n    Validate that n is a positive integer.\n    Raises ValueError with informative message otherwise.\n    '''\n    # REASONING: Configure logger for this module\n    logger = logging.getLogger(__name__)\n    # REASONING: Use try block to catch unexpected errors and log them\n    try:\n        # REASONING: Assert that n is not None and is an instance of int\n        assert n is not None, 'Input cannot be None'\n        assert isinstance(n, int), f'Expected int, got {type(n).__name__}'\n        # REASONING: Check that n is positive\n        if n <= 0:\n            raise ValueError(f'Input must be a positive integer, got {n}')\n        # REASONING: Postcondition: return n\n        return n\n    except AssertionError as ae:\n        logger.error(f'Assertion failed: {ae}')\n        raise ValueError(f'Invalid input: {ae}') from ae\n    except Exception as e:\n        logger.exception('Unexpected error during validation')\n        raise\n\nimport logging\nlogging.basicConfig(level=logging.DEBUG)\n\ndef compute_odd_digits_product(n):\n    # REASONING: Validate that the input is an integer to avoid type errors during processing.\n    if not isinstance(n, int):\n        raise TypeError(\"Input must be an integer.\")\n    # REASONING: Work with the absolute value so negative numbers are handled correctly.\n    n_abs = abs(n)\n    # REASONING: Initialize product accumulator and flag to detect presence of odd digits.\n    product = 1\n    has_odd = False\n    try:\n        # REASONING: Convert the number to a string to iterate over each digit.\n        for digit_char in str(n_abs):\n            digit = int(digit_char)\n            # REASONING: Check if the digit is odd; if so, multiply into the product.\n            if digit % 2 == 1:\n                has_odd = True\n                product *= digit\n    except Exception as e:\n        # REASONING: Capture any unexpected errors during digit processing and re-raise with context.\n        logging.exception(\"Error processing digits for input %s\", n)\n        raise RuntimeError(\"Error processing digits\") from e\n    finally:\n        # REASONING: If no odd digits were found, the product should be 0 as per specification.\n        if not has_odd:\n            product = 0\n    # REASONING: Assert that the output is an integer before returning.\n    assert isinstance(product, int), \"Output must be an integer.\"\n    return product\n\nimport logging\nimport sys\n\n# Configure logger\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.INFO)\nhandler = logging.StreamHandler()\nformatter = logging.Formatter('%(levelname)s:%(name)s:%(message)s')\nhandler.setFormatter(formatter)\nif not logger.handlers:\n    logger.addHandler(handler)\n\ndef format_output(product):\n    '''Return the computed product directly.'''\n    # REASONING: Validate input type\n    try:\n        if not isinstance(product, int):\n            raise TypeError('product must be an integer')\n    except TypeError as te:\n        logger.error(f'TypeError: {te}')\n        raise\n\n    # REASONING: Assert precondition\n    assert isinstance(product, int), 'Precondition failed: product is not int'\n\n    # REASONING: Handle zero explicitly\n    if product == 0:\n        return 0\n\n    # REASONING: Handle large integers\n    try:\n        if product > sys.maxsize:\n            logger.warning('Product exceeds sys.maxsize; returning large integer')\n    except Exception as e:\n        logger.error(f'Unexpected error when checking size: {e}')\n        raise\n\n    # REASONING: Return product\n    result = product\n\n    # REASONING: Assert postcondition\n    assert isinstance(result, int), 'Postcondition failed: result is not int'\n    assert result == product, 'Postcondition failed: result differs from input'\n\n    return result\n\n\ndef digits(n) -> Any:\n    \"\"\"\n    Main function that integrates all modular components to solve the problem.\n    Generated by Modular ToT Self-Reflective Architecture.\n    \"\"\"\n    # Module execution chain\n    processed = validate_and_sanitize_input(n)\n    processed = compute_odd_digits_product(processed)\n    return format_output(processed)\n",
          "tests_passed": 7,
          "total_tests": 7,
          "time": 1372.3302829265594,
          "iterations_used": 1
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "is_nested",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import Any\n\ndef validate_bracket_string(s: str) -> bool:\n    \"\"\"Return True if s contains only '[' and ']' and is non\u2011empty.\"\"\"\n    if not isinstance(s, str):\n        return False\n    if not s:\n        return False\n    return all(ch in \"[]\" for ch in s)\n\ndef is_valid_bracket_sequence(sub: str) -> bool:\n    \"\"\"Check if sub is a valid bracket sequence.\"\"\"\n    balance = 0\n    for ch in sub:\n        if ch == '[':\n            balance += 1\n        else:  # ch == ']'\n            balance -= 1\n            if balance < 0:\n                return False\n    return balance == 0\n\ndef has_nested_substring(s: str) -> bool:\n    \"\"\"Return True if s contains a contiguous substring that is a valid\n    bracket sequence with at least one nested pair.\"\"\"\n    n = len(s)\n    for i in range(n):\n        if s[i] != '[':\n            continue\n        for j in range(i + 1, n):\n            if s[j] != '[':\n                continue\n            for k in range(j + 1, n):\n                if s[k] != ']':\n                    continue\n                for l in range(k + 1, n):\n                    if s[l] != ']':\n                        continue\n                    sub = s[i:l + 1]\n                    if is_valid_bracket_sequence(sub):\n                        return True\n    return False\n\ndef format_is_nested_result(result: Any) -> bool:\n    \"\"\"Ensure the result is a boolean.\"\"\"\n    return bool(result)\n\ndef is_nested(string: str) -> bool:\n    \"\"\"Main function to determine if a string has a nested bracket substring.\"\"\"\n    if not validate_bracket_string(string):\n        return False\n    return format_is_nested_result(has_nested_substring(string))",
          "tests_passed": 14,
          "total_tests": 14,
          "time": 1406.4251482486725,
          "iterations_used": 2
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "sum_squares",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import List, Any, Union\nimport math\nimport logging\n\nlogging.basicConfig(level=logging.INFO)\n\ndef validate_and_sanitize_input(lst: Union[List[Any], None]) -> List[float]:\n    \"\"\"\n    Validate that the input is a list of numeric values and convert them to floats.\n    Returns a list of floats. Non-numeric elements raise ValueError.\n    \"\"\"\n    if lst is None:\n        return []\n\n    if not isinstance(lst, list):\n        return []\n\n    result: List[float] = []\n    for idx, item in enumerate(lst):\n        try:\n            num = float(item)\n            result.append(num)\n        except Exception as e:\n            logging.warning(f\"Element at index {idx} is not numeric: {item}\")\n            raise ValueError(f\"Non-numeric element at index {idx}: {item}\") from e\n\n    return result\n\ndef compute_sum_of_ceiled_squares(numbers: Union[List[float], tuple]) -> int:\n    \"\"\"\n    Compute the sum of squares of the ceiling of each number in the list.\n    \"\"\"\n    if not isinstance(numbers, (list, tuple)):\n        raise TypeError(\"numbers must be a list or tuple of numbers\")\n\n    total = 0\n    for idx, num in enumerate(numbers):\n        if not isinstance(num, (int, float)):\n            raise ValueError(f\"Element at index {idx} is not a number\")\n        ceiled = math.ceil(num)\n        total += ceiled * ceiled\n\n    return total\n\ndef sum_squares(lst: Union[List[Any], None]) -> int:\n    \"\"\"\n    Main function that integrates all modular components to solve the problem.\n    \"\"\"\n    processed = validate_and_sanitize_input(lst)\n    return compute_sum_of_ceiled_squares(processed)",
          "tests_passed": 12,
          "total_tests": 12,
          "time": 396.21138978004456,
          "iterations_used": 2
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "check_if_last_char_is_a_letter",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "def check_if_last_char_is_a_letter(txt: str) -> bool:\n    \"\"\"\n    Return True if the last character of `txt` is an alphabetical character\n    and it is not part of a word (i.e., it is a single-letter word or the\n    string consists of that single letter). Otherwise, return False.\n\n    A \"word\" is defined as a group of characters separated by spaces.\n    \"\"\"\n    if not txt:\n        return False\n\n    last_char = txt[-1]\n    if not last_char.isalpha():\n        return False\n\n    # If the string has only one character, it's a single-letter word.\n    if len(txt) == 1:\n        return True\n\n    # The last character is a letter; check if the preceding character is a space.\n    return txt[-2] == ' '",
          "tests_passed": 10,
          "total_tests": 10,
          "time": 2374.266583919525,
          "iterations_used": 3
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "can_arrange",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import List, Any\n\ndef validate_and_sanitize_input(arr: List[int]) -> List[int]:\n    \"\"\"Validate that `arr` is a list of unique integers. Empty lists are allowed.\"\"\"\n    if not isinstance(arr, list):\n        raise ValueError(\"Input must be a list\")\n    if len(arr) == 0:\n        return []\n    for idx, item in enumerate(arr):\n        if not isinstance(item, int):\n            raise ValueError(f\"Element at index {idx} is not an integer\")\n    if len(set(arr)) != len(arr):\n        raise ValueError(\"Input list contains duplicate values\")\n    return list(arr)\n\ndef find_largest_non_increasing_index(validated_arr: List[int]) -> int:\n    \"\"\"Return the largest index i such that validated_arr[i] < validated_arr[i-1].\"\"\"\n    if len(validated_arr) <= 1:\n        return -1\n    for i in range(len(validated_arr) - 1, 0, -1):\n        if validated_arr[i] < validated_arr[i - 1]:\n            return i\n    return -1\n\ndef can_arrange(arr: List[int]) -> int:\n    \"\"\"Main function that integrates all modular components to solve the problem.\"\"\"\n    processed = validate_and_sanitize_input(arr)\n    return find_largest_non_increasing_index(processed)",
          "tests_passed": 5,
          "total_tests": 5,
          "time": 1472.438805103302,
          "iterations_used": 2
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "largest_smallest_integers",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import List, Any, Optional, Union, Tuple, Dict\n\nimport logging\n\n# Configure a module-level logger for optional warning messages\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.WARNING)\n\n\ndef validate_and_sanitize_input(lst):\n    \"\"\"Return a list containing only the integer elements from *lst*.\n\n    Parameters\n    ----------\n    lst : list | tuple | None\n        The input sequence to be sanitized.\n\n    Returns\n    -------\n    list[int]\n        A new list containing only the integer elements from *lst*.\n    \"\"\"\n    # REASONING: Handle the special case where the caller passes None.\n    if lst is None:\n        # REASONING: Returning an empty list is a safe fallback for None input.\n        return []\n\n    # REASONING: Ensure the input is a list or tuple; otherwise raise a clear error.\n    if not isinstance(lst, (list, tuple)):\n        raise TypeError('Input must be a list or tuple of integers.')\n\n    sanitized = []\n    # REASONING: Iterate over each element, using try/except to guard against\n    # unexpected errors that could arise from custom objects or corrupted data.\n    for idx, item in enumerate(lst):\n        try:\n            # REASONING: Only integers are kept; all other types are ignored.\n            if isinstance(item, int):\n                sanitized.append(item)\n            else:\n                # REASONING: Non-integer items are silently skipped.\n                pass\n        except Exception as e:\n            # REASONING: Log the error and continue processing the rest of the list.\n            logger.warning(f'Skipping element at index {idx} due to error: {e}')\n            continue\n\n    # REASONING: Postcondition: the resulting list contains only integers.\n    assert all(isinstance(x, int) for x in sanitized), 'Sanitized list contains non-integer elements.'\n    return sanitized\n\nimport logging\nfrom typing import List, Tuple, Optional\n\n\ndef find_largest_negative_and_smallest_positive(nums: List[int]) -> Tuple[Optional[int], Optional[int]]:\n    # REASONING: Configure logging for debugging purposes\n    logging.basicConfig(level=logging.DEBUG, format='%(levelname)s:%(message)s')\n    # REASONING: Validate that the input is a list\n    if not isinstance(nums, list):\n        logging.error(\"Input is not a list\")\n        raise TypeError(\"nums must be a list\")\n    # REASONING: Ensure all elements are integers\n    for idx, val in enumerate(nums):\n        if not isinstance(val, int):\n            logging.error(f\"Element at index {idx} is not an integer: {val}\")\n            raise ValueError(f\"All elements must be integers, found {type(val)} at index {idx}\")\n    # REASONING: Use try/except to catch unexpected errors during processing\n    try:\n        largest_negative: Optional[int] = None\n        smallest_positive: Optional[int] = None\n        for num in nums:\n            if num < 0:\n                if largest_negative is None or num > largest_negative:\n                    largest_negative = num\n            elif num > 0:\n                if smallest_positive is None or num < smallest_positive:\n                    smallest_positive = num\n        # REASONING: Assertions to ensure postconditions\n        assert largest_negative is None or isinstance(largest_negative, int), \"largest_negative must be int or None\"\n        assert smallest_positive is None or isinstance(smallest_positive, int), \"smallest_positive must be int or None\"\n        return largest_negative, smallest_positive\n    except Exception as e:\n        logging.exception(\"Unexpected error during computation\")\n        raise e\n\nimport logging\nfrom typing import Tuple, Optional\n\n# Configure logger\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.DEBUG)\nif not logger.handlers:\n    handler = logging.StreamHandler()\n    formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')\n    handler.setFormatter(formatter)\n    logger.addHandler(handler)\n\ndef format_result(result: Tuple[Optional[int], Optional[int]]) -> Tuple[Optional[int], Optional[int]]:\n    '''\n    Return the result tuple unchanged; placeholder for future formatting or error handling if needed.\n    '''\n    # REASONING: Validate that result is a tuple of length 2 with int or None elements.\n    try:\n        # Precondition assertion: result must be a tuple\n        assert isinstance(result, tuple), 'result must be a tuple'\n        # Precondition assertion: tuple length must be 2\n        assert len(result) == 2, 'result tuple must contain exactly two elements'\n        # Validate each element\n        for idx, item in enumerate(result):\n            # REASONING: Each element must be int or None\n            if item is not None and not isinstance(item, int):\n                raise TypeError(f'Element at index {idx} is not an int or None')\n        # Postcondition: return unchanged tuple\n        return result\n    except (AssertionError, TypeError, ValueError) as e:\n        # REASONING: Log the error and fallback to (None, None)\n        logger.error(f'Input validation failed: {e}')\n        return (None, None)\n    except Exception as e:\n        # REASONING: Catch any unexpected exception, log, and raise a generic exception\n        logger.exception('Unexpected error in format_result')\n        raise RuntimeError('Unexpected error in format_result') from e\n\n\ndef largest_smallest_integers(lst) -> Any:\n    \"\"\"\n    Main function that integrates all modular components to solve the problem.\n    Generated by Modular ToT Self-Reflective Architecture.\n    \"\"\"\n    # Module execution chain\n    processed = validate_and_sanitize_input(lst)\n    processed = find_largest_negative_and_smallest_positive(processed)\n    return format_result(processed)\n",
          "tests_passed": 11,
          "total_tests": 11,
          "time": 319.68496322631836,
          "iterations_used": 1
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "compare_one",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "import logging\nfrom typing import Any, Optional\n\nlogging.basicConfig(level=logging.DEBUG)\nlogger = logging.getLogger(__name__)\n\ndef sanitize_input(value: Any) -> dict:\n    \"\"\"\n    Convert the input to a dictionary containing the original value and its numeric\n    representation (as a float). If the value cannot be parsed as a number,\n    numeric_value will be None.\n    \"\"\"\n    original_value = value\n    numeric_value: Optional[float] = None\n\n    if value is None:\n        numeric_value = None\n    elif isinstance(value, (int, float)):\n        numeric_value = float(value)\n    elif isinstance(value, str):\n        s = value.strip()\n        if s:\n            try:\n                numeric_value = float(int(s))\n            except ValueError:\n                try:\n                    if \",\" in s and \".\" not in s:\n                        s = s.replace(\",\", \".\")\n                    numeric_value = float(s)\n                except ValueError:\n                    try:\n                        s_clean = s.replace(\",\", \"\").replace(\" \", \"\").replace(\"\\u00A0\", \"\")\n                        numeric_value = float(s_clean)\n                    except ValueError:\n                        numeric_value = None\n    else:\n        numeric_value = None\n\n    result = {\n        \"original_value\": original_value,\n        \"numeric_value\": numeric_value,\n    }\n    logger.debug(\"Sanitized input: %s\", result)\n    return result\n\ndef compare_parsed(a_parsed: dict, b_parsed: dict) -> Any:\n    \"\"\"\n    Compare two parsed inputs and return the original value of the larger numeric\n    representation. Return None if they are equal or if either cannot be parsed.\n    \"\"\"\n    a_num = a_parsed.get(\"numeric_value\")\n    b_num = b_parsed.get(\"numeric_value\")\n    a_orig = a_parsed.get(\"original_value\")\n    b_orig = b_parsed.get(\"original_value\")\n\n    if a_num is None or b_num is None:\n        return None\n    if a_num == b_num:\n        return None\n    return a_orig if a_num > b_num else b_orig\n\ndef compare_one(a: Any, b: Any) -> Any:\n    \"\"\"\n    Return the larger of two values (int, float, or numeric string). If equal,\n    return None. The returned value preserves the original type of the larger\n    input.\n    \"\"\"\n    parsed_a = sanitize_input(a)\n    parsed_b = sanitize_input(b)\n    return compare_parsed(parsed_a, parsed_b)",
          "tests_passed": 8,
          "total_tests": 8,
          "time": 352.4310419559479,
          "iterations_used": 2
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "is_equal_to_sum_even",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import List, Any, Optional, Union, Tuple, Dict\n\ndef validate_and_sanitize_input(n):\n    # REASONING: Begin validation in a try block to catch and log errors\n    try:\n        # REASONING: Check that the input is an integer type\n        if not isinstance(n, int):\n            raise TypeError('Input must be an integer.')\n        # REASONING: Ensure the integer is non-negative\n        if n < 0:\n            raise ValueError('Input must be non-negative.')\n        # REASONING: Postcondition assertion to guarantee non-negative result\n        assert n >= 0, 'Postcondition failed: returned value is negative.'\n        return n\n    except (TypeError, ValueError) as e:\n        # REASONING: Log the error for debugging purposes\n        import logging\n        logging.error(f'validate_and_sanitize_input error: {e}')\n        # REASONING: Re-raise the exception to propagate the error\n        raise\n\nimport logging\n\ndef can_be_expressed_as_sum_of_four_even(n):\n    # REASONING: Validate that the input is an integer\n    if not isinstance(n, int):\n        raise TypeError('n must be an integer')\n    # REASONING: Ensure the integer is non-negative; negative values cannot be expressed as a sum of positive numbers\n    if n < 0:\n        raise ValueError('n must be non-negative')\n    # REASONING: Main logic is wrapped in a try block to catch unexpected errors and log them\n    try:\n        # REASONING: The smallest sum of four positive even numbers is 2+2+2+2 = 8\n        # REASONING: Any even number >= 8 can be expressed as such a sum; odd numbers or numbers < 8 cannot\n        result = (n >= 8) and (n % 2 == 0)\n        # REASONING: Postcondition: the function must return a boolean value\n        assert isinstance(result, bool), 'Result must be a boolean'\n        return result\n    except Exception as e:\n        # REASONING: Log the exception for debugging purposes and re-raise to propagate the error\n        logging.exception('Error in can_be_expressed_as_sum_of_four_even')\n        raise\n    finally:\n        # REASONING: No cleanup required, but the finally block ensures the function exits cleanly\n        pass\n\nimport logging\n\n# Configure logger for this module\nlogger = logging.getLogger(__name__)\nlogger.addHandler(logging.NullHandler())\n\ndef format_boolean_result(result):\n    \"\"\"\n    Convert various representations of truthy/falsy values to a boolean.\n    Accepts bool, int (0 or 1), str ('true'/'false', case-insensitive).\n    Raises TypeError or ValueError for unsupported types or values.\n    \"\"\"\n    # REASONING: Ensure the input is not None to avoid ambiguous conversion.\n    assert result is not None, \"Input result must not be None\"\n\n    try:\n        # REASONING: Handle boolean input directly.\n        if isinstance(result, bool):\n            return result\n\n        # REASONING: Handle integer input; only 0 or 1 are valid.\n        if isinstance(result, int):\n            if result in (0, 1):\n                return bool(result)\n            else:\n                raise ValueError(f\"Integer value {result} is not a valid boolean representation\")\n\n        # REASONING: Handle string input; normalize and compare.\n        if isinstance(result, str):\n            lowered = result.strip().lower()\n            if lowered in (\"true\", \"1\"):\n                return True\n            if lowered in (\"false\", \"0\"):\n                return False\n            raise ValueError(f\"String value '{result}' is not a valid boolean representation\")\n\n        # REASONING: Unsupported type; raise TypeError.\n        raise TypeError(f\"Unsupported type {type(result).__name__} for boolean conversion\")\n\n    except (ValueError, TypeError) as exc:\n        # REASONING: Log the exception before re-raising to aid debugging.\n        logger.exception(\"Failed to convert result to boolean\")\n        raise\n\n\ndef is_equal_to_sum_even(n) -> Any:\n    \"\"\"\n    Main function that integrates all modular components to solve the problem.\n    Generated by Modular ToT Self-Reflective Architecture.\n    \"\"\"\n    # Module execution chain\n    processed = validate_and_sanitize_input(n)\n    processed = can_be_expressed_as_sum_of_four_even(processed)\n    return format_boolean_result(processed)\n",
          "tests_passed": 8,
          "total_tests": 8,
          "time": 1554.3822622299194,
          "iterations_used": 1
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "special_factorial",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import Any\n\nimport logging\n\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n\ndef validate_and_sanitize_input(n: int) -> int:\n    \"\"\"\n    Validate that n is a positive integer and return it.\n    \"\"\"\n    if not isinstance(n, int):\n        raise TypeError(f\"Expected int, got {type(n).__name__}\")\n    if n < 1:\n        raise ValueError(f\"Input must be >= 1, got {n}\")\n    return n\n\n\ndef compute_brazilian_factorial(n: int) -> int:\n    \"\"\"\n    Compute the Brazilian factorial for a positive integer n.\n    \"\"\"\n    result = 1\n    current_factorial = 1\n    for k in range(1, n + 1):\n        current_factorial *= k\n        result *= current_factorial\n    return result\n\n\ndef special_factorial(n: int) -> int:\n    \"\"\"\n    Return the Brazilian factorial of n.\n    \"\"\"\n    processed = validate_and_sanitize_input(n)\n    return compute_brazilian_factorial(processed)",
          "tests_passed": 4,
          "total_tests": 4,
          "time": 1399.5520009994507,
          "iterations_used": 2
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "fix_spaces",
      "samples": [
        {
          "sample_id": 1,
          "passed": false,
          "solution": "import re\nimport logging\n\n# Configure logging only if it hasn't been configured elsewhere\nlogging.basicConfig(level=logging.INFO, format=\"%(levelname)s: %(message)s\")\n\ndef _validate_and_sanitize_input(text: str) -> str:\n    \"\"\"\n    Validate that the input is a string and return it unchanged.\n    Raises a TypeError if the input is not a string.\n    \"\"\"\n    if not isinstance(text, str):\n        raise TypeError(f\"Expected a string, got {type(text).__name__}\")\n    return text\n\ndef _replace_three_or_more_spaces(text: str) -> str:\n    \"\"\"\n    Replace any run of three or more consecutive spaces with a single hyphen.\n    \"\"\"\n    return re.sub(r\" {3,}\", \"-\", text)\n\ndef _replace_single_or_double_spaces(text: str) -> str:\n    \"\"\"\n    Replace any run of one or two consecutive spaces with a single underscore.\n    \"\"\"\n    return re.sub(r\" {1,2}\", \"_\", text)\n\ndef fix_spaces(text: str) -> str:\n    \"\"\"\n    Replace spaces in the input string according to the following rules:\n    - One or two consecutive spaces become a single underscore.\n    - Three or more consecutive spaces become a single hyphen.\n    \"\"\"\n    # Validate input\n    text = _validate_and_sanitize_input(text)\n\n    # Handle empty string early\n    if text == \"\":\n        return \"\"\n\n    # First replace runs of three or more spaces with a hyphen\n    text = _replace_three_or_more_spaces(text)\n\n    # Then replace runs of one or two spaces with an underscore\n    text = _replace_single_or_double_spaces(text)\n\n    return text\n\n# Alias for backward compatibility / clarity\nformat_spaces = fix_spaces\n\n__all__ = [\"fix_spaces\", \"format_spaces\"]",
          "tests_passed": 4,
          "total_tests": 5,
          "time": 473.2027049064636,
          "iterations_used": 3
        }
      ],
      "num_passed": 0,
      "num_samples": 1
    },
    {
      "problem": "file_name_check",
      "samples": [
        {
          "sample_id": 1,
          "passed": false,
          "solution": "import sys\n\ndef solve() -> None:\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    t = int(next(it))\n    out_lines = []\n\n    for _ in range(t):\n        n = int(next(it))\n        m = int(next(it))\n        for _ in range(n):\n            # read m marks of this student\n            marks = [int(next(it)) for _ in range(m)]\n            # check if all marks are at least 35\n            if all(mark >= 35 for mark in marks):\n                out_lines.append(\"Pass\")\n            else:\n                out_lines.append(\"Fail\")\n\n    sys.stdout.write(\"\\n\".join(out_lines))\n\nif __name__ == \"__main__\":\n    solve()",
          "tests_passed": 0,
          "total_tests": 26,
          "time": 1291.9457449913025,
          "iterations_used": 3
        }
      ],
      "num_passed": 0,
      "num_samples": 1
    },
    {
      "problem": "words_in_sentence",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "import logging\n\nlogging.basicConfig(level=logging.INFO)\n\n\ndef validate_and_sanitize_sentence(sentence: str) -> str:\n    if not isinstance(sentence, str):\n        raise TypeError(\"Input must be a string.\")\n    stripped = sentence.strip()\n    if not stripped:\n        raise ValueError(\"Input string must not be empty or only spaces.\")\n    for ch in stripped:\n        if not (ch.isalpha() or ch.isspace()):\n            raise ValueError(\"Input string must contain only letters and spaces.\")\n    sanitized = \" \".join(stripped.split())\n    return sanitized\n\n\ndef is_prime(n: int) -> bool:\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\n\ndef filter_prime_length_words(sanitized_sentence: str) -> list[str]:\n    words = sanitized_sentence.split()\n    prime_words = [word for word in words if is_prime(len(word))]\n    return prime_words\n\n\ndef format_output(prime_words_list: list[str]) -> str:\n    if not prime_words_list:\n        return \"\"\n    return \" \".join(prime_words_list)\n\n\ndef words_in_sentence(sentence: str) -> str:\n    sanitized = validate_and_sanitize_sentence(sentence)\n    prime_words = filter_prime_length_words(sanitized)\n    return format_output(prime_words)",
          "tests_passed": 7,
          "total_tests": 7,
          "time": 399.41640615463257,
          "iterations_used": 2
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "simplify",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import Tuple\n\ndef parse_fraction(fraction_str: str) -> Tuple[int, int]:\n    \"\"\"\n    Convert a string of the form 'numerator/denominator' into a tuple of integers.\n    Raises ValueError if the format is invalid or if the denominator is zero.\n    \"\"\"\n    if not isinstance(fraction_str, str):\n        raise ValueError(\"Fraction must be a string\")\n    parts = fraction_str.strip().split('/')\n    if len(parts) != 2:\n        raise ValueError(f\"Invalid fraction format: {fraction_str}\")\n    try:\n        num = int(parts[0].strip())\n        den = int(parts[1].strip())\n    except ValueError as exc:\n        raise ValueError(f\"Non-integer components in fraction: {fraction_str}\") from exc\n    if den == 0:\n        raise ValueError(\"Denominator cannot be zero\")\n    if num <= 0 or den <= 0:\n        raise ValueError(\"Numerator and denominator must be positive integers\")\n    return num, den\n\ndef is_whole_product(num1: int, den1: int, num2: int, den2: int) -> bool:\n    \"\"\"\n    Return True if the product of two fractions (num1/den1) * (num2/den2) is an integer.\n    \"\"\"\n    prod_num = num1 * num2\n    prod_den = den1 * den2\n    return prod_num % prod_den == 0\n\ndef simplify(x: str, n: str) -> bool:\n    \"\"\"\n    Return True if the product of the two fractions represented by strings x and n\n    evaluates to a whole number, otherwise False.\n    \"\"\"\n    num1, den1 = parse_fraction(x)\n    num2, den2 = parse_fraction(n)\n    return is_whole_product(num1, den1, num2, den2)",
          "tests_passed": 13,
          "total_tests": 13,
          "time": 418.9814341068268,
          "iterations_used": 2
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "order_by_points",
      "samples": [
        {
          "sample_id": 1,
          "passed": false,
          "solution": "import logging\nfrom typing import List, Any\n\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.DEBUG)\n\n\ndef validate_input(nums: List[int]) -> List[int]:\n    \"\"\"Validate that the input is a list of integers.\"\"\"\n    if not isinstance(nums, list):\n        raise TypeError(\"nums must be a list\")\n    if len(nums) == 0:\n        return []\n    for idx, val in enumerate(nums):\n        if not isinstance(val, int):\n            raise ValueError(f\"Element at index {idx} is not an integer: {val}\")\n    return nums\n\n\ndef sort_by_digit_sum(nums: List[int]) -> List[int]:\n    \"\"\"Sort numbers by the sum of their digits, breaking ties by original index descending.\"\"\"\n    def digit_sum(n: int) -> int:\n        return sum(int(d) for d in str(abs(n)))\n\n    indexed = list(enumerate(nums))\n    sorted_indexed = sorted(indexed, key=lambda x: (digit_sum(x[1]), -x[0]))\n    return [val for _, val in sorted_indexed]\n\n\ndef order_by_points(nums: List[int]) -> List[int]:\n    \"\"\"Main function that validates input and sorts by digit sum.\"\"\"\n    validated = validate_input(nums)\n    return sort_by_digit_sum(validated)",
          "tests_passed": 1,
          "total_tests": 6,
          "time": 555.2596507072449,
          "iterations_used": 3
        }
      ],
      "num_passed": 0,
      "num_samples": 1
    },
    {
      "problem": "specialFilter",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import List, Any\n\ndef validate_and_sanitize_input(nums: Any) -> List[int]:\n    \"\"\"\n    Ensure the input is a list of integers. Non-integer elements are ignored.\n    If the input is None, an empty list is returned.\n    \"\"\"\n    if nums is None:\n        return []\n\n    if not isinstance(nums, list):\n        raise TypeError(\"Input must be a list or None.\")\n\n    sanitized: List[int] = []\n    for idx, item in enumerate(nums):\n        if isinstance(item, int):\n            sanitized.append(item)\n        else:\n            # Non-integer elements are ignored\n            pass\n    return sanitized\n\ndef count_special_numbers(nums: List[int]) -> int:\n    \"\"\"\n    Count numbers that are greater than 10 and have both first and last digits odd.\n    \"\"\"\n    count = 0\n    for num in nums:\n        if num <= 10:\n            continue\n        s = str(abs(num))\n        first_digit = int(s[0])\n        last_digit = int(s[-1])\n        if first_digit % 2 == 1 and last_digit % 2 == 1:\n            count += 1\n    return count\n\ndef specialFilter(nums: Any) -> int:\n    \"\"\"\n    Main function that returns the count of special numbers in the input list.\n    \"\"\"\n    processed = validate_and_sanitize_input(nums)\n    return count_special_numbers(processed)",
          "tests_passed": 7,
          "total_tests": 7,
          "time": 395.70198607444763,
          "iterations_used": 2
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "get_max_triples",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "import logging\nfrom typing import Any\n\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.DEBUG)\nif not logger.handlers:\n    handler = logging.StreamHandler()\n    formatter = logging.Formatter('%(levelname)s:%(message)s')\n    handler.setFormatter(formatter)\n    logger.addHandler(handler)\n\n\ndef validate_and_sanitize_input(n: Any) -> int:\n    logger.debug(\"Received input: %s\", n)\n    if n is None:\n        raise ValueError(\"Input cannot be None\")\n    try:\n        n_int = int(n)\n    except (TypeError, ValueError) as e:\n        raise TypeError(\"Input must be convertible to an integer\") from e\n    if n_int <= 0:\n        raise ValueError(\"Input must be a positive integer\")\n    assert isinstance(n_int, int) and n_int > 0\n    return n_int\n\n\ndef count_valid_triples(n: int) -> int:\n    if n < 3:\n        return 0\n\n    # Count indices i (1-indexed) where a[i] mod 3 == 0 or 1\n    # a[i] = i^2 - i + 1\n    # a[i] mod 3 == 0 when i % 3 == 2\n    count0 = n // 3  # numbers with i % 3 == 2\n    if n % 3 == 2:\n        count0 += 1\n    count1 = n - count0  # remaining indices give residue 1\n\n    def comb3(k: int) -> int:\n        return k * (k - 1) * (k - 2) // 6 if k >= 3 else 0\n\n    total = comb3(count0) + comb3(count1)\n    assert isinstance(total, int) and total >= 0\n    return total\n\n\ndef fallback_function(result: int) -> int:\n    return result\n\n\ndef get_max_triples(n: Any) -> int:\n    processed = validate_and_sanitize_input(n)\n    processed = count_valid_triples(processed)\n    return fallback_function(processed)",
          "tests_passed": 4,
          "total_tests": 4,
          "time": 1541.4944491386414,
          "iterations_used": 2
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "bf",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import Tuple\n\ndef validate_and_sanitize_planets(planet1, planet2):\n    known_planets = {\n        \"Mercury\", \"Venus\", \"Earth\", \"Mars\",\n        \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\n    }\n    try:\n        assert isinstance(planet1, str) and isinstance(planet2, str)\n    except AssertionError:\n        return False, \"\", \"\"\n    sanitized1 = planet1.strip().title()\n    sanitized2 = planet2.strip().title()\n    is_valid = sanitized1 in known_planets and sanitized2 in known_planets\n    return is_valid, sanitized1, sanitized2\n\ndef get_intermediate_planets(planet1: str, planet2: str) -> Tuple[str, ...]:\n    orbital_order = [\n        \"Mercury\", \"Venus\", \"Earth\", \"Mars\",\n        \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\n    ]\n    idx1 = orbital_order.index(planet1)\n    idx2 = orbital_order.index(planet2)\n    if idx1 == idx2 or abs(idx1 - idx2) == 1:\n        return ()\n    start, end = sorted((idx1, idx2))\n    return tuple(orbital_order[start + 1:end])\n\ndef bf(planet1, planet2) -> Tuple[str, ...]:\n    is_valid, p1, p2 = validate_and_sanitize_planets(planet1, planet2)\n    if not is_valid:\n        return ()\n    return get_intermediate_planets(p1, p2)",
          "tests_passed": 7,
          "total_tests": 7,
          "time": 333.2438678741455,
          "iterations_used": 2
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "sorted_list_sum",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import List, Any, Optional, Union, Tuple, Dict\n\ndef validate_and_sanitize_input(input_list):\n    # REASONING: Validate that input is a list or None\n    if input_list is None:\n        # REASONING: None input is treated as empty list\n        return []\n    if not isinstance(input_list, list):\n        # REASONING: Raise error if not a list\n        raise TypeError('input_list must be a list')\n    # REASONING: Prepare result list\n    result = []\n    try:\n        for idx, item in enumerate(input_list):\n            # REASONING: Check each element is a string\n            if not isinstance(item, str):\n                # REASONING: Raise error for non-string element\n                raise ValueError(f'Element at index {idx} is not a string')\n            # REASONING: Strip whitespace and add to result\n            cleaned = item.strip()\n            result.append(cleaned)\n    except Exception as e:\n        # REASONING: Log exception and re-raise\n        import logging\n        logging.exception('Error during input sanitization')\n        raise\n    # REASONING: Assert postcondition that result is list of strings\n    assert isinstance(result, list), 'Result is not a list'\n    assert all(isinstance(x, str) for x in result), 'Result contains non-string elements'\n    return result\n\nimport logging\nfrom typing import List\n\ndef filter_and_sort_words(words: List[str]) -> List[str]:\n    # REASONING: Configure logger for debugging\n    logger = logging.getLogger(__name__)\n    logger.setLevel(logging.DEBUG)\n    if not logger.handlers:\n        handler = logging.StreamHandler()\n        formatter = logging.Formatter('%(levelname)s:%(name)s:%(message)s')\n        handler.setFormatter(formatter)\n        logger.addHandler(handler)\n\n    # REASONING: Validate input type\n    if not isinstance(words, list):\n        logger.error('Input is not a list')\n        raise TypeError('words must be a list of strings')\n\n    # REASONING: Validate each element is a string\n    for idx, w in enumerate(words):\n        if not isinstance(w, str):\n            logger.error('Element at index %d is not a string: %r' % (idx, w))\n            raise ValueError('All elements must be strings, found %s at index %d' % (type(w).__name__, idx))\n\n    # REASONING: Filter words with even length\n    try:\n        even_words = [w for w in words if len(w) % 2 == 0]\n    except Exception as e:\n        logger.exception('Error during filtering')\n        raise\n\n    # REASONING: Sort by length then alphabetically\n    try:\n        sorted_words = sorted(even_words, key=lambda w: (len(w), w))\n    except Exception as e:\n        logger.exception('Error during sorting')\n        raise\n\n    # REASONING: Assertions for postconditions\n    assert isinstance(sorted_words, list), 'Output is not a list'\n    for w in sorted_words:\n        assert isinstance(w, str), 'Output contains non-string'\n        assert len(w) % 2 == 0, 'Output contains odd-length word'\n\n    return sorted_words\n\nimport logging\n\ndef format_output(sorted_words):\n    # REASONING: Set up a logger for debugging and traceability\n    logger = logging.getLogger(__name__)\n    # REASONING: Validate that the input is a list\n    if not isinstance(sorted_words, list):\n        logger.error('Input is not a list')\n        raise TypeError('sorted_words must be a list')\n    # REASONING: Validate that every element in the list is a string\n    for idx, word in enumerate(sorted_words):\n        if not isinstance(word, str):\n            logger.error(f'Element at index {idx} is not a string')\n            raise ValueError('All elements in sorted_words must be strings')\n    # REASONING: Handle the edge case where the list is empty\n    if not sorted_words:\n        logger.debug('Input list is empty, returning empty list')\n        return []\n    # REASONING: Process the list inside a try block to catch unexpected errors\n    try:\n        # In this simple pass-through, we return a shallow copy of the list\n        result = list(sorted_words)\n        # REASONING: Assert that the result is a list of strings\n        assert isinstance(result, list), 'Result is not a list'\n        assert all(isinstance(w, str) for w in result), 'Result contains non-string elements'\n        return result\n    except Exception as e:\n        logger.exception('Unexpected error during formatting')\n        raise\n    finally:\n        logger.debug('format_output completed')\n\n\ndef sorted_list_sum(lst) -> Any:\n    \"\"\"\n    Main function that integrates all modular components to solve the problem.\n    Generated by Modular ToT Self-Reflective Architecture.\n    \"\"\"\n    # Module execution chain\n    processed = validate_and_sanitize_input(lst)\n    processed = filter_and_sort_words(processed)\n    return format_output(processed)\n",
          "tests_passed": 7,
          "total_tests": 7,
          "time": 670.213546037674,
          "iterations_used": 1
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "x_or_y",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import Any\n\ndef validate_and_sanitize_input(n, x, y):\n    \"\"\"Validate that n, x, and y are integers and that n is positive.\"\"\"\n    try:\n        n_val = int(n)\n        x_val = int(x)\n        y_val = int(y)\n    except (TypeError, ValueError) as e:\n        raise ValueError(\"n, x, and y must be integers\") from e\n\n    if n_val <= 0:\n        raise ValueError(\"n must be a positive integer\")\n\n    return n_val, x_val, y_val\n\n\ndef is_prime(n: int) -> bool:\n    \"\"\"Return True if n is a prime number, False otherwise.\"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\n\ndef select_value_based_on_prime(n: int, x: int, y: int) -> int:\n    \"\"\"Return x if n is prime, otherwise return y.\"\"\"\n    return x if is_prime(n) else y\n\n\ndef x_or_y(n, x, y) -> Any:\n    \"\"\"Return x if n is prime, otherwise return y.\"\"\"\n    n_val, x_val, y_val = validate_and_sanitize_input(n, x, y)\n    return select_value_based_on_prime(n_val, x_val, y_val)",
          "tests_passed": 10,
          "total_tests": 10,
          "time": 457.7881007194519,
          "iterations_used": 2
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "double_the_difference",
      "samples": [
        {
          "sample_id": 1,
          "passed": false,
          "solution": "def solution(a, b):\n    \"\"\"\n    Return the difference between the sum of the first list and the sum of the second list.\n\n    Parameters\n    ----------\n    a : list[int]\n        First list of integers.\n    b : list[int]\n        Second list of integers.\n\n    Returns\n    -------\n    int\n        The value of sum(a) - sum(b).\n    \"\"\"\n    return sum(a) - sum(b)",
          "tests_passed": 0,
          "total_tests": 7,
          "time": 580.4362020492554,
          "iterations_used": 3
        }
      ],
      "num_passed": 0,
      "num_samples": 1
    },
    {
      "problem": "compare",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import List\n\ndef validate_inputs(scores, guesses):\n    \"\"\"Validate that scores and guesses are non\u2011None lists of equal length\n    containing only integers. Returns the validated lists.\"\"\"\n    assert scores is not None, \"scores cannot be None\"\n    assert guesses is not None, \"guesses cannot be None\"\n    if not isinstance(scores, (list, tuple)):\n        raise TypeError(\"scores must be a list or tuple\")\n    if not isinstance(guesses, (list, tuple)):\n        raise TypeError(\"guesses must be a list or tuple\")\n    if len(scores) != len(guesses):\n        raise ValueError(\"scores and guesses must have the same length\")\n    if len(scores) == 0:\n        return [], []\n    for idx, val in enumerate(scores):\n        if not isinstance(val, int):\n            raise TypeError(f\"Element at index {idx} in scores is not an integer\")\n    for idx, val in enumerate(guesses):\n        if not isinstance(val, int):\n            raise TypeError(f\"Element at index {idx} in guesses is not an integer\")\n    return list(scores), list(guesses)\n\ndef compute_differences(scores: List[int], guesses: List[int]) -> List[int]:\n    \"\"\"Return a list of absolute differences between corresponding elements.\"\"\"\n    if not scores:\n        return []\n    differences = [abs(s - g) for s, g in zip(scores, guesses)]\n    return differences\n\ndef format_output(differences: List[int]) -> List[int]:\n    \"\"\"Return a list containing only integer values from the input.\"\"\"\n    if differences is None:\n        return []\n    if not isinstance(differences, list):\n        raise TypeError(\"differences must be a list or None\")\n    filtered = [item for item in differences if isinstance(item, int)]\n    return filtered\n\ndef compare(game: List[int], guess: List[int]) -> List[int]:\n    \"\"\"Determine how far off each guess was from the actual scores.\"\"\"\n    scores, guesses = validate_inputs(game, guess)\n    differences = compute_differences(scores, guesses)\n    return format_output(differences)",
          "tests_passed": 4,
          "total_tests": 4,
          "time": 500.1560959815979,
          "iterations_used": 2
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "Strongest_Extension",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import List, Tuple\n\ndef validate_and_sanitize_input(class_name: str, extensions: List[str]) -> Tuple[str, List[str]]:\n    \"\"\"\n    Validate and sanitize the input parameters.\n    \"\"\"\n    if not isinstance(class_name, str):\n        raise TypeError(\"class_name must be a string\")\n    sanitized_class_name = class_name.strip()\n    if not sanitized_class_name:\n        raise ValueError(\"class_name cannot be empty or whitespace only\")\n\n    if not isinstance(extensions, (list, tuple)):\n        raise TypeError(\"extensions must be a list or tuple of strings\")\n    if len(extensions) == 0:\n        raise ValueError(\"extensions list cannot be empty\")\n\n    sanitized_extensions: List[str] = []\n    for idx, ext in enumerate(extensions):\n        if not isinstance(ext, str):\n            raise TypeError(f\"extensions[{idx}] must be a string\")\n        stripped_ext = ext.strip()\n        if not stripped_ext:\n            raise ValueError(f\"extensions[{idx}] cannot be empty or whitespace only\")\n        sanitized_extensions.append(stripped_ext)\n\n    return sanitized_class_name, sanitized_extensions\n\ndef compute_strength(name: str) -> int:\n    \"\"\"\n    Compute the strength of an extension name as (number of uppercase letters) - (number of lowercase letters).\n    \"\"\"\n    upper = sum(1 for c in name if c.isupper())\n    lower = sum(1 for c in name if c.islower())\n    return upper - lower\n\ndef compute_strongest_extension(extensions: List[str]) -> str:\n    \"\"\"\n    Return the strongest extension name from the list.\n    If multiple extensions have the same strength, the first one in the list is returned.\n    \"\"\"\n    best_name = extensions[0]\n    best_strength = compute_strength(best_name)\n\n    for ext in extensions[1:]:\n        strength = compute_strength(ext)\n        if strength > best_strength:\n            best_strength = strength\n            best_name = ext\n\n    return best_name\n\ndef format_result(class_name: str, extension_name: str) -> str:\n    \"\"\"\n    Format the final output string as 'ClassName.ExtensionName'.\n    \"\"\"\n    return f\"{class_name}.{extension_name}\"\n\ndef Strongest_Extension(class_name: str, extensions: List[str]) -> str:\n    \"\"\"\n    Main function that integrates all modular components to solve the problem.\n    \"\"\"\n    sanitized_class_name, sanitized_extensions = validate_and_sanitize_input(class_name, extensions)\n    strongest_extension = compute_strongest_extension(sanitized_extensions)\n    return format_result(sanitized_class_name, strongest_extension)",
          "tests_passed": 9,
          "total_tests": 9,
          "time": 1437.2267529964447,
          "iterations_used": 2
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "cycpattern_check",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import List, Any, Optional, Union, Tuple, Dict\n\nimport logging\n\nlogging.basicConfig(level=logging.DEBUG)\nlogger = logging.getLogger(__name__)\n\ndef validate_inputs(word1, word2):\n    '''\n    Validate that word1 and word2 are non-null strings, strip whitespace,\n    and ensure they are not empty after stripping.\n    Returns a tuple of sanitized words or raises ValueError.\n    '''\n    # REASONING: Wrap entire validation in try to catch unexpected errors\n    try:\n        # REASONING: Precondition: inputs must not be None\n        assert word1 is not None and word2 is not None, 'Inputs must not be None'\n        # REASONING: Type check for both inputs\n        if not isinstance(word1, str) or not isinstance(word2, str):\n            raise TypeError('Both inputs must be strings')\n        # REASONING: Strip whitespace from both words\n        sanitized1 = word1.strip()\n        sanitized2 = word2.strip()\n        # REASONING: Postcondition: sanitized words must not be empty\n        if not sanitized1 or not sanitized2:\n            raise ValueError('Input strings must not be empty after stripping')\n        # REASONING: Return tuple of sanitized words\n        result = (sanitized1, sanitized2)\n        # REASONING: Assert postcondition\n        assert isinstance(result, tuple) and len(result) == 2, 'Result must be a tuple of two strings'\n        assert all(isinstance(s, str) and s for s in result), 'Each element must be a non-empty string'\n        return result\n    except (TypeError, ValueError) as e:\n        # REASONING: Re-raise as ValueError for consistency\n        logger.debug('Validation failed: %s', e)\n        raise ValueError(str(e)) from e\n    except Exception as e:\n        # REASONING: Catch any other unexpected exception\n        logger.exception('Unexpected error during validation')\n        raise ValueError('Unexpected error during validation') from e\n\ndef check_rotation_substring(s, sub):\n    # REASONING: Validate input types to avoid unexpected errors.\n    if not isinstance(s, str) or not isinstance(sub, str):\n        raise TypeError(\"Both s and sub must be strings\")\n    # REASONING: Handle empty sub case: empty string is always a substring.\n    if sub == \"\":\n        return True\n    # REASONING: If sub longer than s, no rotation can fit.\n    if len(sub) > len(s):\n        return False\n    # REASONING: Main logic: iterate over all rotations of sub.\n    try:\n        for i in range(len(sub)):\n            rotation = sub[i:] + sub[:i]\n            if rotation in s:\n                return True\n        return False\n    except Exception as e:\n        # REASONING: Catch unexpected errors during rotation checks.\n        raise RuntimeError(\"Error during rotation substring check\") from e\n\nimport logging\n\nlogger = logging.getLogger(__name__)\n\ndef format_result(result):\n    # REASONING: Attempt to convert the input to a boolean value.\n    try:\n        bool_result = bool(result)\n    except Exception as exc:\n        # REASONING: If conversion fails, log the error and use False as a safe fallback.\n        logger.error('Failed to convert result to bool: %s', exc)\n        bool_result = False\n    # REASONING: Ensure the function always returns a boolean.\n    assert isinstance(bool_result, bool), 'Output is not a bool'\n    return bool_result\n\n\ndef cycpattern_check(a, b) -> Any:\n    \"\"\"\n    Main function that integrates all modular components to solve the problem.\n    Generated by Modular ToT Self-Reflective Architecture.\n    \"\"\"\n    # Module execution chain\n    processed = validate_inputs(a)\n    processed = check_rotation_substring(processed)\n    return format_result(processed)\n",
          "tests_passed": 0,
          "total_tests": 0,
          "time": 1406.5132761001587,
          "iterations_used": 1
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "even_odd_count",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import List, Any, Optional, Union, Tuple, Dict\n\nimport logging\n\ndef validate_and_sanitize_input(raw_input):\n    # REASONING: Ensure raw_input is not None to avoid unexpected errors.\n    assert raw_input is not None, 'Input cannot be None'\n    # REASONING: Attempt to convert input to int, handling various types.\n    try:\n        # If raw_input is already an int, return it directly.\n        if isinstance(raw_input, int):\n            return raw_input\n        # If raw_input is a float, convert to int by truncation.\n        if isinstance(raw_input, float):\n            return int(raw_input)\n        # If raw_input is a string, attempt to parse it as an integer.\n        if isinstance(raw_input, str):\n            # Strip whitespace to handle inputs like ' 42 '.\n            stripped = raw_input.strip()\n            # REASONING: Use int() to parse numeric strings; will raise ValueError if invalid.\n            return int(stripped)\n        # For other numeric types (e.g., Decimal, Fraction), attempt to convert via float then int.\n        # REASONING: This covers numeric types that are not int, float, or str.\n        try:\n            return int(float(raw_input))\n        except Exception:\n            # If conversion fails, raise ValueError.\n            raise ValueError(f'Unsupported numeric type: {type(raw_input).__name__}')\n    except (ValueError, TypeError) as e:\n        # REASONING: Log the error for debugging purposes.\n        logging.error(f'Failed to validate and sanitize input: {raw_input!r}. Error: {e}')\n        # REASONING: Re-raise a ValueError to signal failure to caller.\n        raise ValueError(f'Invalid input for integer conversion: {raw_input!r}') from e\n\ndef count_even_odd_digits(number):\n    # REASONING: Validate input type to ensure function receives an integer.\n    if not isinstance(number, int):\n        raise TypeError(\"Input must be an integer.\")\n    # REASONING: Assert precondition that number is an integer.\n    assert isinstance(number, int), \"Precondition failed: number is not int.\"\n    try:\n        # REASONING: Convert number to absolute value to ignore sign.\n        abs_number = abs(number)\n        # REASONING: Convert to string to iterate over digits.\n        digits_str = str(abs_number)\n        even_count = 0\n        odd_count = 0\n        # REASONING: Iterate over each character digit.\n        for ch in digits_str:\n            # REASONING: Convert character to integer digit.\n            digit = int(ch)\n            if digit % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n        # REASONING: Postcondition: counts are non-negative and sum equals number of digits.\n        assert even_count >= 0 and odd_count >= 0, \"Counts must be non-negative.\"\n        assert even_count + odd_count == len(digits_str), \"Counts do not sum to total digits.\"\n        return even_count, odd_count\n    except Exception as e:\n        # REASONING: Catch any unexpected errors and raise a runtime error with context.\n        raise RuntimeError(\"An error occurred while counting digits.\") from e\n\ndef format_and_handle_output(counts):\n    # REASONING: Ensure counts is provided\n    try:\n        if counts is None:\n            raise ValueError('counts cannot be None')\n        # REASONING: Validate type is tuple\n        if not isinstance(counts, tuple):\n            raise TypeError('counts must be a tuple')\n        # REASONING: Validate length\n        if len(counts) != 2:\n            raise ValueError('counts tuple must have exactly two elements')\n        # REASONING: Validate each element is int\n        for idx, val in enumerate(counts):\n            if not isinstance(val, int):\n                raise TypeError('counts element at index {} is not an int'.format(idx))\n        # REASONING: All checks passed, return unchanged\n        # Postcondition assertion\n        assert isinstance(counts, tuple) and len(counts) == 2 and all(isinstance(v, int) for v in counts)\n        return counts\n    except (TypeError, ValueError) as e:\n        # REASONING: Re-raise with context\n        raise\n    finally:\n        # REASONING: No cleanup needed, but finally ensures block executed\n        pass\n\n\ndef even_odd_count(num) -> Any:\n    \"\"\"\n    Main function that integrates all modular components to solve the problem.\n    Generated by Modular ToT Self-Reflective Architecture.\n    \"\"\"\n    # Module execution chain\n    processed = validate_and_sanitize_input(num)\n    processed = count_even_odd_digits(processed)\n    return format_and_handle_output(processed)\n",
          "tests_passed": 8,
          "total_tests": 8,
          "time": 336.6648209095001,
          "iterations_used": 1
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "int_to_mini_roman",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import List, Any, Optional, Union, Tuple, Dict\n\ndef validate_and_sanitize_input(number):\n    # REASONING: Configure logging for debugging purposes\n    import logging\n    logger = logging.getLogger(__name__)\n    logger.setLevel(logging.DEBUG)\n    if not logger.handlers:\n        handler = logging.StreamHandler()\n        formatter = logging.Formatter('%(levelname)s:%(name)s:%(message)s')\n        handler.setFormatter(formatter)\n        logger.addHandler(handler)\n\n    # REASONING: Handle None input explicitly as a fallback\n    if number is None:\n        logger.debug(\"Input is None, returning None as fallback.\")\n        return None\n\n    # REASONING: Attempt to convert input to integer if it is not already an int\n    try:\n        if isinstance(number, float):\n            # REASONING: Convert float to int only if it has no fractional part\n            if number.is_integer():\n                number = int(number)\n            else:\n                raise ValueError(\"Float input has fractional part.\")\n        elif isinstance(number, str):\n            # REASONING: Strip whitespace and convert string to int\n            number = int(number.strip())\n        elif not isinstance(number, int):\n            # REASONING: Unsupported type\n            raise TypeError(f\"Unsupported type: {type(number).__name__}\")\n    except (ValueError, TypeError) as e:\n        logger.error(f\"Conversion error: {e}\")\n        raise ValueError(f\"Invalid input type or value: {e}\") from e\n\n    # REASONING: Assert that the number is now an integer\n    assert isinstance(number, int), \"Number is not an integer after conversion.\"\n\n    # REASONING: Validate range constraints\n    if not (1 <= number <= 1000):\n        logger.error(f\"Number {number} out of allowed range 1-1000.\")\n        raise ValueError(f\"Number {number} is out of allowed range 1-1000.\")\n\n    # REASONING: Postcondition assertion to ensure output validity\n    assert 1 <= number <= 1000, \"Output does not satisfy postcondition.\"\n\n    logger.debug(f\"Validated number: {number}\")\n    return number\n\nimport logging\nlogging.basicConfig(level=logging.DEBUG)\n\ndef convert_to_roman(number):\n    logging.debug(\"Starting conversion for number: %s\", number)\n    # REASONING: Validate input type and range\n    if not isinstance(number, int):\n        raise TypeError(\"Input must be an integer.\")\n    if number < 1 or number > 3999:\n        raise ValueError(\"Input must be between 1 and 3999 inclusive.\")\n    # REASONING: Define mapping of integer values to Roman numerals\n    roman_map = [\n        (1000, \"M\"),\n        (900, \"CM\"),\n        (500, \"D\"),\n        (400, \"CD\"),\n        (100, \"C\"),\n        (90, \"XC\"),\n        (50, \"L\"),\n        (40, \"XL\"),\n        (10, \"X\"),\n        (9, \"IX\"),\n        (5, \"V\"),\n        (4, \"IV\"),\n        (1, \"I\"),\n    ]\n    result = []\n    # REASONING: Convert number to Roman numerals using greedy algorithm\n    try:\n        for value, numeral in roman_map:\n            # REASONING: Append numeral while number is large enough\n            while number >= value:\n                result.append(numeral)\n                number -= value\n    except Exception as exc:\n        # REASONING: Any unexpected error during conversion is wrapped\n        raise RuntimeError(\"Conversion failed.\") from exc\n    # REASONING: Join list into string\n    roman_numeral = \"\".join(result)\n    # REASONING: Postcondition: result is non-empty and uppercase\n    assert roman_numeral, \"Resulting Roman numeral should not be empty.\"\n    assert roman_numeral.isupper(), \"Roman numeral should be uppercase.\"\n    logging.debug(\"Conversion result: %s\", roman_numeral)\n    return roman_numeral\n\nimport logging\n\n# Configure a module-level logger for optional debugging.\nlogger = logging.getLogger(__name__)\n\n\ndef format_roman(roman):\n    \"\"\"Return the Roman numeral string in lowercase.\n\n    Parameters\n    ----------\n    roman : str or None\n        The Roman numeral to format. ``None`` is treated as an empty string.\n\n    Returns\n    -------\n    str\n        The lowercased Roman numeral or an empty string for ``None``/``''``.\n    \"\"\"\n    # REASONING: Validate input type to ensure function receives expected data.\n    if roman is None:\n        # REASONING: None is treated as empty string per fallback logic.\n        logger.debug(\"Input is None; returning empty string.\")\n        return ''\n    if not isinstance(roman, str):\n        # REASONING: Raise TypeError for unexpected types to aid debugging.\n        logger.error(\"Invalid type: %s\", type(roman).__name__)\n        raise TypeError(f\"Expected a string or None, got {type(roman).__name__}\")\n    # REASONING: Empty string is a valid input; return it unchanged.\n    if roman == '':\n        logger.debug(\"Input is an empty string; returning empty string.\")\n        return ''\n    try:\n        # REASONING: Convert to lowercase; this is the core functionality.\n        result = roman.lower()\n    except Exception as e:\n        # REASONING: Catch unexpected errors during string operation.\n        logger.exception(\"Unexpected error during lowercasing\")\n        raise RuntimeError(\"Unexpected error during lowercasing\") from e\n    # REASONING: Assert that result is a string and lowercased.\n    assert isinstance(result, str), \"Result is not a string\"\n    assert result == result.lower(), \"Result is not fully lowercased\"\n    logger.debug(\"Successfully formatted Roman numeral: %s\", result)\n    return result\n\n\ndef int_to_mini_roman(number) -> Any:\n    \"\"\"\n    Main function that integrates all modular components to solve the problem.\n    Generated by Modular ToT Self-Reflective Architecture.\n    \"\"\"\n    # Module execution chain\n    processed = validate_and_sanitize_input(number)\n    processed = convert_to_roman(processed)\n    return format_roman(processed)\n",
          "tests_passed": 14,
          "total_tests": 14,
          "time": 447.74630308151245,
          "iterations_used": 1
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "right_angle_triangle",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import Any\nimport math\n\ndef validate_triangle_sides(a: Any, b: Any, c: Any) -> bool:\n    \"\"\"\n    Validate that the three sides can form a triangle.\n    Returns True if the sides are numeric, positive, and satisfy the triangle inequality.\n    \"\"\"\n    try:\n        a_f, b_f, c_f = float(a), float(b), float(c)\n    except (TypeError, ValueError):\n        return False\n\n    if a_f <= 0 or b_f <= 0 or c_f <= 0:\n        return False\n\n    # Triangle inequality\n    if a_f + b_f <= c_f or a_f + c_f <= b_f or b_f + c_f <= a_f:\n        return False\n\n    return True\n\n\ndef is_right_angle_triangle_core(a: float, b: float, c: float) -> bool:\n    \"\"\"\n    Determine if a triangle with sides a, b, c is right\u2011angled.\n    Assumes the sides form a valid triangle.\n    \"\"\"\n    # Sort sides so that c is the largest (hypotenuse)\n    a, b, c = sorted((a, b, c))\n\n    # Use math.isclose to account for floating\u2011point inaccuracies\n    return math.isclose(a * a + b * b, c * c, rel_tol=1e-9, abs_tol=0.0)\n\n\ndef right_angle_triangle(a: Any, b: Any, c: Any) -> bool:\n    \"\"\"\n    Main function that checks whether the given sides form a right\u2011angled triangle.\n    \"\"\"\n    if not validate_triangle_sides(a, b, c):\n        return False\n\n    # Convert to float for the core check\n    a_f, b_f, c_f = float(a), float(b), float(c)\n    return is_right_angle_triangle_core(a_f, b_f, c_f)",
          "tests_passed": 11,
          "total_tests": 11,
          "time": 1157.8794832229614,
          "iterations_used": 2
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "find_max",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import List, Any, Optional, Union, Tuple, Dict\n\nimport logging\n\n\ndef validate_and_sanitize_words(words):\n    # REASONING: Configure logger for debugging\n    logger = logging.getLogger(__name__)\n    # REASONING: Ensure logger level is set to DEBUG for detailed output\n    logger.setLevel(logging.DEBUG)\n    # REASONING: Add a stream handler if none exists\n    if not logger.handlers:\n        handler = logging.StreamHandler()\n        handler.setFormatter(logging.Formatter('%(levelname)s:%(name)s:%(message)s'))\n        logger.addHandler(handler)\n\n    # REASONING: Validate that input is a list\n    if not isinstance(words, list):\n        logger.error('Input is not a list')\n        raise TypeError('Input must be a list of strings')\n\n    # REASONING: Assert precondition that words is a list\n    assert isinstance(words, list), 'Precondition failed: words is not a list'\n\n    cleaned = []\n    try:\n        # REASONING: Iterate over each element to validate and sanitize\n        for idx, word in enumerate(words):\n            # REASONING: Check that each element is a string\n            if not isinstance(word, str):\n                logger.warning(f'Element at index {idx} is not a string: {word!r}')\n                continue  # Skip non-string elements\n            # REASONING: Strip whitespace to check emptiness\n            stripped = word.strip()\n            if stripped == '':\n                logger.info(f'Element at index {idx} is empty or whitespace only: {word!r}')\n                continue  # Skip empty strings\n            cleaned.append(stripped)\n    except Exception as e:\n        # REASONING: Catch unexpected errors during iteration\n        logger.exception('Unexpected error during sanitization')\n        raise e\n    finally:\n        # REASONING: Log the result of sanitization\n        logger.debug(f'Sanitized list: {cleaned}')\n\n    # REASONING: Assert postcondition that cleaned list contains only non-empty strings\n    assert all(isinstance(w, str) and w != '' for w in cleaned), 'Postcondition failed: cleaned list contains invalid entries'\n\n    return cleaned\n\nimport logging\n\n\ndef find_word_with_max_unique(words):\n    # REASONING: Configure logger for debugging and traceability\n    logger = logging.getLogger(__name__)\n    # REASONING: Validate that the input is a list\n    if not isinstance(words, list):\n        raise TypeError(\"Input must be a list of strings.\")\n    # REASONING: Ensure every element in the list is a string\n    for idx, w in enumerate(words):\n        if not isinstance(w, str):\n            raise TypeError(f\"Element at index {idx} is not a string.\")\n    # REASONING: Handle the empty list edge case by returning an empty string\n    if not words:\n        logger.warning(\"Empty list provided; returning empty string.\")\n        return ''\n    # REASONING: Compute the word with the maximum number of unique characters\n    try:\n        max_unique = -1\n        best_word = ''\n        for word in words:\n            unique_count = len(set(word))\n            # REASONING: Update best_word if a higher unique count is found\n            # or if the same count is found but the word is lexicographically smaller\n            if unique_count > max_unique or (unique_count == max_unique and word < best_word):\n                max_unique = unique_count\n                best_word = word\n        # REASONING: Postcondition: the result must be a string\n        assert isinstance(best_word, str)\n        return best_word\n    except Exception as e:\n        # REASONING: Log unexpected errors and re-raise for visibility\n        logger.exception(\"Unexpected error during computation.\")\n        raise\n\ndef handle_result(result):\n    # REASONING: Validate input type; allow any type but handle None specially\n    if result is None:\n        # REASONING: None indicates missing result; return safe default\n        return \"No result\"\n    # REASONING: If result is an empty string, return it unchanged\n    if isinstance(result, str) and result == \"\":\n        return \"\"\n    # REASONING: Attempt to convert result to string safely\n    try:\n        result_str = str(result)\n    except Exception as e:\n        # REASONING: Conversion failed; log error and return safe default\n        import logging\n        logging.error(\"Failed to convert result to string: %s\", e)\n        return \"Invalid result\"\n    # REASONING: Ensure the result string is not None after conversion\n    if result_str is None:\n        return \"Invalid result\"\n    return result_str\n\n\ndef find_max(words) -> Any:\n    \"\"\"\n    Main function that integrates all modular components to solve the problem.\n    Generated by Modular ToT Self-Reflective Architecture.\n    \"\"\"\n    # Module execution chain\n    processed = validate_and_sanitize_words(words)\n    processed = find_word_with_max_unique(processed)\n    return handle_result(processed)\n",
          "tests_passed": 0,
          "total_tests": 0,
          "time": 350.1590893268585,
          "iterations_used": 1
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "eat",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import List, Tuple\n\ndef validate_inputs(number, need, remaining) -> Tuple[int, int, int]:\n    \"\"\"\n    Validate that the inputs are integers within the allowed range [0, 1000].\n    \"\"\"\n    for name, value in ((\"number\", number), (\"need\", need), (\"remaining\", remaining)):\n        if not isinstance(value, int):\n            raise TypeError(f\"{name} must be an integer\")\n        if value < 0 or value > 1000:\n            raise ValueError(f\"{name} must be between 0 and 1000 inclusive\")\n    return number, need, remaining\n\ndef compute_eating(number: int, need: int, remaining: int) -> Tuple[int, int]:\n    \"\"\"\n    Compute the total number of carrots eaten after the rabbit eats more,\n    and the number of carrots left in stock.\n    \"\"\"\n    eaten_now = min(need, remaining)\n    total_eaten = number + eaten_now\n    remaining_after = remaining - eaten_now\n    return total_eaten, remaining_after\n\ndef format_output(total_eaten: int, remaining_after: int) -> List[int]:\n    \"\"\"\n    Convert the result tuple into the required list format.\n    \"\"\"\n    return [total_eaten, remaining_after]\n\ndef eat(number, need, remaining) -> List[int]:\n    \"\"\"\n    Main function that integrates all modular components to solve the problem.\n    \"\"\"\n    number, need, remaining = validate_inputs(number, need, remaining)\n    total_eaten, remaining_after = compute_eating(number, need, remaining)\n    return format_output(total_eaten, remaining_after)",
          "tests_passed": 6,
          "total_tests": 6,
          "time": 486.35504388809204,
          "iterations_used": 2
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "do_algebra",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import List, Tuple, Any\n\ndef validate_inputs(operators: List[str], operands: List[int]) -> Tuple[List[str], List[int]]:\n    \"\"\"Validate operators and operands lists.\n\n    Returns the original lists if all checks pass.\n    Raises ValueError with a descriptive message otherwise.\n    \"\"\"\n    allowed_ops = {'+', '-', '*', '//', '**'}\n\n    if not isinstance(operators, list):\n        raise TypeError('operators must be a list')\n    if not isinstance(operands, list):\n        raise TypeError('operands must be a list')\n\n    if len(operators) == 0:\n        raise ValueError('operators list cannot be empty')\n    if len(operands) < 2:\n        raise ValueError('operands list must contain at least two items')\n    if len(operators) != len(operands) - 1:\n        raise ValueError('operators and operands length mismatch')\n\n    for op in operators:\n        if op not in allowed_ops:\n            raise ValueError(f'Unsupported operator: {op}')\n\n    for idx, val in enumerate(operands):\n        if not isinstance(val, int):\n            raise TypeError(f'operand at index {idx} is not an integer')\n        if val < 0:\n            raise ValueError(f'operand at index {idx} is negative')\n\n    return operators, operands\n\n\ndef evaluate_expression(operators: List[str], operands: List[int]) -> int:\n    \"\"\"Evaluate the arithmetic expression defined by operators and operands.\"\"\"\n    # Build a string representation of the expression\n    expr = str(operands[0])\n    for op, val in zip(operators, operands[1:]):\n        expr += op + str(val)\n    # Evaluate using Python's eval which respects operator precedence\n    return eval(expr)\n\n\ndef do_algebra(operator: List[str], operand: List[int]) -> Any:\n    \"\"\"Main function that validates input, evaluates the expression, and returns the result.\"\"\"\n    operators, operands = validate_inputs(operator, operand)\n    return evaluate_expression(operators, operands)",
          "tests_passed": 3,
          "total_tests": 3,
          "time": 751.4161720275879,
          "iterations_used": 3
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "string_to_md5",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import Optional\nimport hashlib\nimport logging\n\nlogger = logging.getLogger(__name__)\n\ndef validate_and_sanitize_input(text: str) -> Optional[str]:\n    \"\"\"\n    Validate that the input is a non\u2011empty string.\n    Return the string unchanged if valid, otherwise return None.\n    \"\"\"\n    if not isinstance(text, str):\n        logger.debug(\"Input is not a string: %r\", text)\n        return None\n    if text == \"\":\n        logger.debug(\"Input is an empty string\")\n        return None\n    return text\n\ndef compute_md5_hash(sanitized_text: str) -> str:\n    \"\"\"\n    Compute the MD5 hash of a non\u2011empty string.\n    \"\"\"\n    hash_obj = hashlib.md5()\n    hash_obj.update(sanitized_text.encode(\"utf-8\"))\n    result = hash_obj.hexdigest()\n    assert len(result) == 32, \"MD5 hash length should be 32\"\n    return result\n\ndef format_hash_output(hash_str: Optional[str]) -> Optional[str]:\n    \"\"\"\n    Return the hash string unchanged, or propagate None.\n    \"\"\"\n    return hash_str\n\ndef string_to_md5(text: str) -> Optional[str]:\n    \"\"\"\n    Return the MD5 hash of the given string, or None if the string is empty.\n    \"\"\"\n    sanitized = validate_and_sanitize_input(text)\n    if sanitized is None:\n        return None\n    hash_val = compute_md5_hash(sanitized)\n    return format_hash_output(hash_val)",
          "tests_passed": 4,
          "total_tests": 4,
          "time": 308.6928231716156,
          "iterations_used": 2
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    },
    {
      "problem": "generate_integers",
      "samples": [
        {
          "sample_id": 1,
          "passed": true,
          "solution": "from typing import List, Any\n\ndef generate_even_digits(lower: int, upper: int) -> List[int]:\n    \"\"\"\n    Return the even digits (0-9) that lie between lower and upper inclusive,\n    in ascending order. Handles reversed bounds.\n    \"\"\"\n    if not isinstance(lower, int) or not isinstance(upper, int):\n        raise TypeError(\"Both lower and upper must be integers\")\n\n    # Ensure lower <= upper for comparison\n    low, high = (lower, upper) if lower <= upper else (upper, lower)\n\n    # Even digits between 0 and 9\n    return [d for d in range(0, 10) if d % 2 == 0 and low <= d <= high]\n\n\ndef format_and_handle_output(result: List[int]) -> List[int]:\n    \"\"\"\n    Validate that the result is a list of integers and return it.\n    \"\"\"\n    if not isinstance(result, list):\n        raise TypeError(\"Result must be a list\")\n    if not all(isinstance(x, int) for x in result):\n        raise ValueError(\"All elements in result must be integers\")\n    return result\n\n\ndef generate_integers(a: int, b: int) -> List[int]:\n    \"\"\"\n    Main function that returns the even digits between a and b inclusive.\n    \"\"\"\n    evens = generate_even_digits(a, b)\n    return format_and_handle_output(evens)",
          "tests_passed": 4,
          "total_tests": 4,
          "time": 2471.8779079914093,
          "iterations_used": 2
        }
      ],
      "num_passed": 1,
      "num_samples": 1
    }
  ],
  "current_pass_at_1": 92.3076923076923,
  "problems_completed": 156,
  "problems_passed": 144,
  "total_problems": 164,
  "completion_percentage": 95.1219512195122,
  "last_completed_problem": "generate_integers",
  "last_completed_index": 163,
  "current_batch_count": 8
}


